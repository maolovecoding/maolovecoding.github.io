<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vuex--状态管理篇</title>
      <link href="/2021/11/06/src/vue/vuex/"/>
      <url>/2021/11/06/src/vue/vuex/</url>
      
        <content type="html"><![CDATA[<h1 id="Vuex-的状态管理"><a href="#Vuex-的状态管理" class="headerlink" title="Vuex 的状态管理"></a>Vuex 的状态管理</h1><h2 id="什么是状态管理"><a href="#什么是状态管理" class="headerlink" title="什么是状态管理"></a>什么是状态管理</h2><p>在开发中，我们会的应用程序需要处理各种各样的数据，这些 数据需要保存在我们应用程序中的某一个位置，对于这些数据 的管理我们就称之为是 <strong>状态管理。</strong></p><p>在前面我们是如何管理自己的状态呢？</p><ul><li>在 Vue 开发中，我们使用组件化的开发方式；</li><li>而在组件中我们定义 data 或者在 setup 中返回使用的数据， 这些数据我们称之为 state；</li><li>在模块 template 中我们可以使用这些数据，模块最终会被 渲染成 DOM，我们称之为 View；</li><li>在模块中我们会产生一些行为事件，处理这些行为事件时， 有可能会修改 state，这些行为事件我们称之为 actions；</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210903172421127.png" alt="image-20210903172421127"></p><h2 id="复杂的状态管理"><a href="#复杂的状态管理" class="headerlink" title="复杂的状态管理"></a>复杂的状态管理</h2><p>JavaScript 开发的应用程序，已经变得越来越复杂了：</p><ul><li>JavaScript 需要管理的状态越来越多，越来越复杂；</li><li>这些状态包括服务器返回的数据、缓存数据、用户操作产生的数据等等；</li><li>也包括一些 UI 的状态，比如某些元素是否被选中，是否显示加载动效，当前分页；</li></ul><p>当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：</p><ul><li>多个视图依赖于同一状态；</li><li>来自不同视图的行为需要变更同一状态；</li></ul><p>我们是否可以通过组件数据的传递来完成呢？</p><ul><li>对于一些简单的状态，确实可以通过 props 的传递或者 Provide 的方式来共享状态；</li><li>但是对于复杂的状态管理来说，显然单纯通过传递和共享的方式是不足以解决问题的，比如<strong>兄弟组件如何共享 数据呢</strong>？</li></ul><h2 id="Vuex-的状态管理-1"><a href="#Vuex-的状态管理-1" class="headerlink" title="Vuex 的状态管理"></a>Vuex 的状态管理</h2><ul><li><p>管理不断变化的 state 本身是非常困难的：</p><ul><li>状态之间相互会存在依赖，一个状态的变化会引起另一个状态的变化，View 页面也有可能会引起状态的变化；</li><li>当应用程序复杂时，state 在什么时候，因为什么原因而发生了变化，发生了怎么样的变化，会变得非常难以控 制和追踪；</li></ul></li><li><p>因此，我们是否可以考虑将组件的内部状态抽离出来，以一个全局单例的方式来管理呢？</p><ul><li>在这种模式下，我们的组件树构成了一个巨大的 “试图 View”；</li><li>不管在树的哪个位置，任何组件都能获取状态或者触发行为；</li><li>通过定义和隔离状态管理中的各个概念，并通过强制性的规则来维护视图和状态间的独立性，我们的代码边会 变得更加结构化和易于维护、跟踪；</li></ul></li><li><p>这就是 Vuex 背后的基本思想，它借鉴了 Flux、Redux、Elm（纯函数语言，redux 有借鉴它的思想）：</p></li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210903172709234.png" alt="image-20210903172709234"></p><h3 id="Vuex-的安装"><a href="#Vuex-的安装" class="headerlink" title="Vuex 的安装"></a>Vuex 的安装</h3><p>依然我们要使用 vuex，首先第一步需要安装 vuex：</p><p>我们这里使用的是 vuex4.x，安装的时候需要添加 next 指定版本；</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i vuex@next<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><h4 id="创建-Store"><a href="#创建-Store" class="headerlink" title="创建 Store"></a>创建 Store</h4><ul><li><p>每一个 Vuex 应用的核心就是 store（仓库）：</p><ul><li>store 本质上是一个容器，它包含着你的应用中大部分的状态（state）；</li></ul></li><li><p><strong>Vuex 和单纯的全局对象有什么区别呢？</strong></p><ul><li><p>第一：Vuex 的状态存储是响应式的</p><ul><li>当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会被更新；</li></ul></li><li><p>第二：你不能直接改变 store 中的状态</p><ul><li>改变 store 中的状态的唯一途径就显示提交 (commit) mutation；</li><li>这样使得我们可以方便的跟踪每一个状态的变化，从而让我们能够通过一些工具帮助我们更好的管理应用的状态；</li></ul></li></ul></li><li><p>使用步骤：</p><ul><li>创建 Store 对象；</li><li>在 app 中通过插件安装；</li></ul></li></ul><h4 id="组件中使用-store"><a href="#组件中使用-store" class="headerlink" title="组件中使用 store"></a>组件中使用 store</h4><p>在组件中使用 store，我们按照如下的方式：</p><ul><li>在模板中使用；</li><li>在 options api 中使用，比如 computed；</li><li>在 setup 中使用；</li></ul><h5 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h5><h6 id="store-文件"><a href="#store-文件" class="headerlink" title="store 文件"></a>store 文件</h6><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// vuex全局管理文件</span><span class="token keyword">import</span> <span class="token punctuation">{</span> createStore <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vuex"</span><span class="token punctuation">;</span><span class="token comment">// 创建一个仓库</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token function">state</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      counter<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 在mutations里面定义操作我们vuex的state管理的数据的方法</span>  mutations<span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token comment">// 每个方法都会默认传递state对象参数</span>    <span class="token function">increment</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      state<span class="token punctuation">.</span>counter<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      state<span class="token punctuation">.</span>counter<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 导出</span><span class="token keyword">export</span> <span class="token keyword">default</span> store<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="store-的注册"><a href="#store-的注册" class="headerlink" title="store 的注册"></a>store 的注册</h6><p>直接在 main.js 里面使用 app.use()进行安装即可。</p><h6 id="简单计数器的实现"><a href="#简单计数器的实现" class="headerlink" title="简单计数器的实现"></a>简单计数器的实现</h6><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div&gt;    &lt;!-- $store.state.counter 拿到仓库的数据 通过 $store.state对象进行获取 --&gt;    &lt;h2&gt;{{ $store.state.counter }}&lt;/h2&gt;    &lt;button @click="increment"&gt;+1&lt;/button&gt;    &lt;button @click="decrement"&gt;-1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  name: "App",  methods: {    increment() {      // 使用仓库里面管理的counter数据，并进行操作      // 官方是不建议我们直接操作vuex管理的数据的      // this.$store.state.counter++;      // 我们要修改数据，一般都是会进行commit      this.$store.commit("increment");    },    decrement() {      this.$store.commit("decrement");    },  },};&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210903173548842.png" alt="image-20210903173548842"></p><h4 id="单一状态树"><a href="#单一状态树" class="headerlink" title="单一状态树"></a>单一状态树</h4><p><strong>Vuex 使用单一状态树：</strong></p><ul><li>用一个对象就包含了全部的应用层级状态；</li><li>采用的是 SSOT，Single Source of Truth，也可以翻译成单一数据源；</li><li>这也意味着，每个应用将仅仅包含一个 store 实例；</li><li>单状态树和模块化并不冲突，后面我们会讲到 module 的概念；</li></ul><p>单一状态树的优势：</p><ul><li>如果你的状态信息是保存到多个 Store 对象中的，那么之后的管理和维护等等都会变得特别困难；</li><li>所以 Vuex 也使用了单一状态树来管理应用层级的全部状态；</li><li>单一状态树能够让我们最直接的方式找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便 的管理和维护；</li></ul><h4 id="组件获取状态"><a href="#组件获取状态" class="headerlink" title="组件获取状态"></a>组件获取状态</h4><p>在前面我们已经学习过如何在组件中获取状态了。</p><p>当然，如果觉得那种方式有点繁琐（表达式过长），我们可以使用计算属性：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210903202015859.png" alt="image-20210903202015859"></p><p>也是可以正常显示的。</p><p><strong>但是：</strong>如果我们有很多个状态都需要获取的话，可以使用 mapState 的辅助函数（是 vuex 插件提供给我们的）：</p><ul><li>mapState 的方式一：对象类型；</li><li>mapState 的方式二：数组类型；</li><li>也可以使用展开运算符和来原有的 computed 混合在一起；</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210903202136671.png" alt="image-20210903202136671"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210903203542060.png" alt="image-20210903203542060"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210903203604530.png" alt="image-20210903203604530"></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;Home: {{ $store.state.counter }}&lt;/h2&gt;    &lt;h2&gt;{{ counter }}-{{ name }}-{{ age }}-{{ gender }}&lt;/h2&gt;    &lt;h2&gt;{{ hCounter }}-{{ hName }}-{{ hAge }}-{{ hGender }}&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapState } from "vuex";export default {  name: "Home",  computed: {    // 从仓库state中获取到的数据    /*     mapState() 参数： 1. 数组写法      在数组里面写上我们想要映射过来的属性(就是要获取的数据变量名)    该方法的返回值是一个对象，我们对对象进行展开，全都放到计算属性中    TODO  注意：我们知道，计算属性的格式一般都是 fullName(){return xxx}        既然我们的mapState返回值是对象，而且可以直接展开放到计算属性中，        说明展开的每个属性对应的属性值其实也是函数，也是类似于我们原生的计算属性的。        所以说，返回值其实不是计算属性，是函数    */    ...mapState(["counter", "name", "age", "gender"]),    /*     参数二：对象写法，我们可以自定义属性的名称    属性名：对应的值是一个函数的返回值    */    ...mapState({      // state参数会映射为我们在store里面的state      hCounter: (state) =&gt; state.counter,      hName: (state) =&gt; state.name,      hAge: (state) =&gt; state.age,      hGender: (state) =&gt; state.gender,    }),  },};&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="在-setup-中使用-mapState"><a href="#在-setup-中使用-mapState" class="headerlink" title="在 setup 中使用 mapState"></a>在 setup 中使用 mapState</h4><p>在 setup 中如果我们单个获取装是非常简单的：</p><ul><li><p>通过 useStore 拿到 store 后去获取某个状态即可；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210903205459653.png" alt="image-20210903205459653"></p></li><li><p>但是如果我们需要使用 mapState 的功能呢？</p></li></ul><p><strong>默认情况下，Vuex 并没有提供非常方便的使用 mapState 的方式，这里我们进行了一个函数的封装：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210903213230243.png" alt="image-20210903213230243"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 在 computed里面如何拿到 $store对象 ?</span>    <span class="token comment">// vuex提供了一个hook，使用useStore就可以拿到全局的store对象</span>    <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">useStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> hcounter <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 使用 mapState拿到数据</span>    <span class="token comment">/*      TODO  本质上 其实mapState函数取属性的时候，还是通过 this.$store.state.属性      来获取我们需要的属性值      所以：我们的属性对应的那个函数的返回值会调用 $store.state 属性      那么，我们需要给这个函数传递一个对象，因为setup函数里面是没有this的      既然没有this，那么肯定就没有 this.$store 对象      所以说，我们需要传递给这个函数 $store 对象      这个对象就是前面我们通过 useStore函数拿到的返回值    */</span>    <span class="token keyword">const</span> storeStateFns <span class="token operator">=</span> <span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"counter"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token string">"gender"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 用来保存我们生成的计算属性</span>    <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>storeStateFns<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">fnKey</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> fn <span class="token operator">=</span> storeStateFns<span class="token punctuation">[</span>fnKey<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">{</span> $store<span class="token operator">:</span> store <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      state<span class="token punctuation">[</span>fnKey<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span> hcounter<span class="token punctuation">,</span> <span class="token operator">...</span>state <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="useState-自封装函数"><a href="#useState-自封装函数" class="headerlink" title="useState 自封装函数"></a>useState 自封装函数</h5><p>上面那种在 setup 函数里面写一大坨代码不是我们想要的效果。所以我们进行简单的函数封装，使看起来更舒服。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> useStore<span class="token punctuation">,</span> mapState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vuex"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> computed <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token comment">/** * 封装一个拿到指定属性的函数，返回值是计算属性的对象 * * @export * @param {*} mapper 对象或者数组 {} || [] 两种写法都支持 * @return {*} 返回值就是封装好的对象，对象的属性是计算属性对象 */</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">mapper</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 拿到 $store 对象</span>  <span class="token keyword">const</span> $store <span class="token operator">=</span> <span class="token function">useStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获取到对应的对象的所有函数</span>  <span class="token comment">/*   functions:{    name:function(){},    age:function(){},    ...  }  */</span>  <span class="token keyword">const</span> storeStateFns <span class="token operator">=</span> <span class="token function">mapState</span><span class="token punctuation">(</span>mapper<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 对数据进行转换</span>  <span class="token keyword">const</span> storeState <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>storeStateFns<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">fnKey</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token comment">// 绑定我们的对象，并在函数上赋值我们的 $store属性</span>    <span class="token comment">// 返回的函数就是一个能拿到 $store 属性的函数了</span>    <span class="token keyword">const</span> fn <span class="token operator">=</span> storeStateFns<span class="token punctuation">[</span>fnKey<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">{</span> $store <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 属性转为计算属性，并保存到返回的对象上</span>    storeState<span class="token punctuation">[</span>fnKey<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> storeState<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这样就舒服多了</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210903221635835.png" alt="image-20210903221635835"></p><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><h4 id="getters-的基本使用"><a href="#getters-的基本使用" class="headerlink" title="getters 的基本使用"></a>getters 的基本使用</h4><p>某些属性我们可能需要经过变化后来使用，这个时候可以使用 getters：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210904082048773.png" alt="image-20210904082048773"></p><h4 id="getters-第二个参数"><a href="#getters-第二个参数" class="headerlink" title="getters 第二个参数"></a>getters 第二个参数</h4><p>getters 可以接收第二个参数：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210904082200680.png" alt="image-20210904082200680"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210904082259062.png" alt="image-20210904082259062"></p><h4 id="getters-的返回函数"><a href="#getters-的返回函数" class="headerlink" title="getters 的返回函数"></a>getters 的返回函数</h4><p>getters 中的函数本身，可以返回一个函数，那么在使用的地方相当于可以调用这个函数：</p><p>调用函数的同时也可以传递参数。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210904082506302.png" alt="image-20210904082506302"></p><h4 id="mapGetters-的辅助函数"><a href="#mapGetters-的辅助函数" class="headerlink" title="mapGetters 的辅助函数"></a>mapGetters 的辅助函数</h4><p>这里我们也可以使用 mapGetters 的辅助函数。</p><p><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210904083326466.png" alt="image-20210904083326466"></p><p>在 setup 中使用</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210904084849673.png" alt="image-20210904084849673"></p><h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><h4 id="Mutation-基本使用"><a href="#Mutation-基本使用" class="headerlink" title="Mutation 基本使用"></a>Mutation 基本使用</h4><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation：Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的**事件类型 (type)**和一个**回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210904085430225.png" alt="image-20210904085430225"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210904085849392.png" alt="image-20210904085849392"></p><h4 id="Mutation-携带数据"><a href="#Mutation-携带数据" class="headerlink" title="Mutation 携带数据"></a>Mutation 携带数据</h4><p>很多时候我们在提交 mutation 的时候，会携带一些数据，这个时候我们可以使用参数：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210904090441870.png" alt="image-20210904090441870"></p><p><strong>payload 为对象类型</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210904090801951.png" alt="image-20210904090801951"></p><p><strong>对象风格的提交方式</strong></p><p>和上面的 payload 对象类型的方式提交是等价的。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210904091003783.png" alt="image-20210904091003783"></p><h4 id="Mutation-常量类型"><a href="#Mutation-常量类型" class="headerlink" title="Mutation 常量类型"></a>Mutation 常量类型</h4><p><strong>定义常量：mutation-type.js</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 将mutations的那些定义的函数名，也就是一个个的mutation的名称定义为常量</span><span class="token comment">// 方便外界调用，不会出错</span><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">INCREMENT_N</span> <span class="token operator">=</span> <span class="token string">"incrementN"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>定义 mutation</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 使用定义好的常量作为函数名</span><span class="token punctuation">[</span><span class="token constant">INCREMENT_N</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    state<span class="token punctuation">.</span>counter <span class="token operator">+=</span> payload<span class="token punctuation">.</span>num<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提交 mutation</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token comment">// 提交的mutation的类型直接都写在对象上</span>  <span class="token comment">// type就是我们的mutation类型</span>  type<span class="token operator">:</span> <span class="token constant">INCREMENT_N</span><span class="token punctuation">,</span>  name<span class="token operator">:</span> <span class="token string">"毛毛"</span><span class="token punctuation">,</span>  num<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="mapMutations-辅助函数"><a href="#mapMutations-辅助函数" class="headerlink" title="mapMutations 辅助函数"></a>mapMutations 辅助函数</h4><p>我们也可以借助于辅助函数，帮助我们快速映射到对应的方法中：</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;{{ $store.state.counter }}&lt;/h2&gt;    &lt;!-- 提交 mutation 修改state中的数据--&gt;    &lt;button @click="increment"&gt;+&lt;/button&gt;    &lt;button @click="myDecrement"&gt;-&lt;/button&gt;    &lt;button @click="incrementN({ num: 10 })"&gt;+10&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapMutations } from "vuex";import { INCREMENT_N } from "../store/mutation-types";export default {  name: "Home",  methods: {    // 参数为数组类型    ...mapMutations([      "increment", // 将 `this.increment()` 映射为 `this.$store.commit('increment')`      // 提交带参数，直接在调用的时候传递参数即可      INCREMENT_N, // 将 `this[INCREMENT_N](amount)` 映射为 `this.$store.commit(INCREMENT_N, amount)`    ]),    // 参数为对象类型，可以方便起别名    ...mapMutations({      myDecrement: "decrement", // 将 `this.myDecrement()` 映射为 `this.$store.commit('decrement')`    }),  },};&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210904095152100.png" alt="image-20210904095152100"></p><p><strong>在 setup 中使用也是一样的：</strong></p><p>mapMutations 返回的对象里面的属性值就刚好是函数，不需要再次封装，直接解构即可使用。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210904095629038.png" alt="image-20210904095629038"></p><h4 id="mutation-重要原则"><a href="#mutation-重要原则" class="headerlink" title="mutation 重要原则"></a>mutation 重要原则</h4><p>一条重要的原则就是要记住 <strong>mutation 必须是同步函数</strong></p><ul><li>这是因为 devtool 工具会记录 mutation 的日记；</li><li>每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照；</li><li>但是在 mutation 中执行异步操作，就无法追踪到数据的变化；</li><li>所以 Vuex 的重要原则中要求 mutation 必须是同步函数；</li></ul><h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><h4 id="actions-的基本使用"><a href="#actions-的基本使用" class="headerlink" title="actions 的基本使用"></a>actions 的基本使用</h4><p>Action 类似于 mutation，不同在于：</p><ul><li><p>Action 提交的是 mutation，而不是直接变更状态；</p></li><li><p>Action 可以包含任意异步操作；</p></li></ul><p>这里有一个非常重要的参数 context：</p><ul><li>context 是一个和 store 实例均有相同方法和属性的 context 对象；</li><li>所以我们可以从其中获取到 commit 方法来提交一个 mutation，或者通过 context.state 和 context.getters 来 获取 state 和 getters；</li><li>但是为什么它不是 store 对象呢？这个等到我们讲 Modules 时再具体来说；</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210905094951404.png" alt="image-20210905094951404"></p><h4 id="actions-的分发操作"><a href="#actions-的分发操作" class="headerlink" title="actions 的分发操作"></a>actions 的分发操作</h4><p>如何使用 action 呢？进行 action 的分发：</p><ul><li>分发使用的是 store 上的 dispatch 函数；</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210905101505909.png" alt="image-20210905101505909"></p><ul><li>同样的，它也可以携带我们的参数：</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">incrementN</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 提交antion</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">"incrementNAction"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> num<span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js">actions<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token comment">// payload 就是页面提交action的时候，传递的参数</span>    <span class="token function">incrementNAction</span><span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 执行异步操作 可以发起网络请求等</span>      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">"incrementN"</span><span class="token punctuation">,</span> payload<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>也可以以对象的形式进行分发：</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210905101710585.png" alt="image-20210905101710585"></p><h4 id="actions-的辅助函数-mapActions"><a href="#actions-的辅助函数-mapActions" class="headerlink" title="actions 的辅助函数 mapActions"></a>actions 的辅助函数 mapActions</h4><h5 id="methods-中使用"><a href="#methods-中使用" class="headerlink" title="methods 中使用"></a>methods 中使用</h5><p><strong>action 也有对应的辅助函数：</strong></p><ul><li>数组类型的写法；</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210905102659204.png" alt="image-20210905102659204"></p><ul><li>对象类型的写法</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210905102937069.png" alt="image-20210905102937069"></p><h5 id="在-setup-函数中使用"><a href="#在-setup-函数中使用" class="headerlink" title="在 setup 函数中使用"></a>在 setup 函数中使用</h5><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210905103228015.png" alt="image-20210905103228015"></p><h4 id="actions-的异步操作"><a href="#actions-的异步操作" class="headerlink" title="actions 的异步操作"></a>actions 的异步操作</h4><p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？</p><ul><li>我们可以通过让 action 返回 Promise，在 Promise 的 then 中来处理完成后的操作；</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210905104736067.png" alt="image-20210905104736067"></p><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><h4 id="module-的基本使用"><a href="#module-的基本使用" class="headerlink" title="module 的基本使用"></a>module 的基本使用</h4><p><strong>什么是 Module？</strong></p><ul><li>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象，当应用变得非常复杂时，store 对象就有可 能变得相当臃肿；</li><li>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）；</strong></li><li>每个模块拥有自己的 state、mutation、action、getter、甚至是<strong>嵌套子模块；</strong></li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210905112855452.png" alt="image-20210905112855452"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210905112914375.png" alt="image-20210905112914375"></p><h4 id="module-的局部状态"><a href="#module-的局部状态" class="headerlink" title="module 的局部状态"></a>module 的局部状态</h4><p>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象：</p><p>在 homeModule 里面注册的 mutation，对 increment 进行提交，可以发现，全局的 rootCounter 和 homeCounter 都进行了+1.因为我们在 homeModule 和全局的 mutation 中都注册了 increment 这个 mutation 提交事件。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210905114631515.png" alt="image-20210905114631515"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210905114518377.png" alt="image-20210905114518377"></p><p>只要 mutation 中有叫做 increment 的这个事件，对应的函数全都会被执行一次。</p><p>如果我们想执行（提交）的只是 homeModule 里面的 mutation 呢？</p><p><strong>我们在 module 中定义的 getters，mutations，以及 actions 都是这样的问题。</strong></p><p>我们进行提交，或者获取 getters 里面的数据，以及派发 actions，都是和直接在全局的 store 里面定义都没有什么区别。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210905115847241.png" alt="image-20210905115847241"></p><p><strong>我们如果想进行区分，要如何做呢？</strong></p><h4 id="module-的命名空间"><a href="#module-的命名空间" class="headerlink" title="module 的命名空间"></a>module 的命名空间</h4><p>默认情况下，模块内部的 action 和 mutation 仍然是<strong>注册在全局的命名空间中</strong>的：</p><ul><li>这样使得多个模块能够对同一个 action 或 mutation 作出响应；</li><li>Getter 同样也默认注册在全局命名空间；</li></ul><p>如果我们希望模块具有更高的封装度和复用性，可以添加 <strong>namespaced: true</strong> 的方式使其成为带命名空间的模块：</p><p>当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210905121001586.png" alt="image-20210905121001586"></p><h4 id="module-修改或派发根组件"><a href="#module-修改或派发根组件" class="headerlink" title="module 修改或派发根组件"></a>module 修改或派发根组件</h4><p>如果我们希望在 action 中修改 root 中的 state，那么有如下的方式：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210905131830019.png" alt="image-20210905131830019"></p><h4 id="module-的辅助函数"><a href="#module-的辅助函数" class="headerlink" title="module 的辅助函数"></a>module 的辅助函数</h4><p><strong>辅助函数有三种使用方法：</strong></p><ul><li>方式一：通过完整的模块空间名称来查找；</li><li>方式二：第一个参数传入模块空间名称，后面写上要使用的属性；</li><li>方式三：通过 createNamespacedHelpers 生成一个模块的辅助函数；</li></ul><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{ homeCounter }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{doubleHomeCounter}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 需要使用 getters["注册的模块名称/getters里面注册的getter名称"] --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>homeGetters: {{ $store.getters["home/doubleHomeCounter"] }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>homeIncrement<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>homeCounter+1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>homeIncrementAction<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>homeCounter+1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">import</span> <span class="token punctuation">{</span> mapState<span class="token punctuation">,</span> mapGetters<span class="token punctuation">,</span> mapMutations<span class="token punctuation">,</span> mapActions <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vuex"</span><span class="token punctuation">;</span>  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    name<span class="token operator">:</span> <span class="token string">"Home"</span><span class="token punctuation">,</span>    computed<span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token comment">// 带命名空间的模块数据取出来比较麻烦</span>      <span class="token comment">// 取出带命名空间的state里面的数据，只支持对象的写法</span>      <span class="token comment">// 而且返回值 是 state.模块名.数据变量</span>      <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token function-variable function">homeCounter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>home<span class="token punctuation">.</span>homeCounter<span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token comment">// 也是需要带模块名，后面跟数据名</span>        doubleHomeCounter<span class="token operator">:</span> <span class="token string">"home/doubleHomeCounter"</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        homeIncrement<span class="token operator">:</span> <span class="token string">"home/increment"</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        homeIncrementAction<span class="token operator">:</span> <span class="token string">"home/incrementAction"</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{ homeCounter }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{doubleHomeCounter}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 需要使用 getters["注册的模块名称/getters里面注册的getter名称"] --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>homeGetters: {{ $store.getters["home/doubleHomeCounter"] }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>increment<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>homeCounter+1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>incrementAction<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>homeCounter+1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">import</span> <span class="token punctuation">{</span> mapState<span class="token punctuation">,</span> mapGetters<span class="token punctuation">,</span> mapMutations<span class="token punctuation">,</span> mapActions <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vuex"</span><span class="token punctuation">;</span>  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    name<span class="token operator">:</span> <span class="token string">"Home"</span><span class="token punctuation">,</span>    computed<span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token comment">// 方式二：</span>      <span class="token comment">// 第一个参数是我们的模块名称</span>      <span class="token comment">// 第二个参数是我们这个模块下要获取的数据</span>      <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token string">"home"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"homeCounter"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token comment">// 也是需要带模块名，后面跟数据名</span>        doubleHomeCounter<span class="token operator">:</span> <span class="token string">"home/doubleHomeCounter"</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token string">"home"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"increment"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token string">"home"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"incrementAction"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h5><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{ homeCounter }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{ doubleHomeCounter }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 需要使用 getters["注册的模块名称/getters里面注册的getter名称"] --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>homeGetters: {{ $store.getters["home/doubleHomeCounter"] }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>increment<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>homeCounter+1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>incrementAction<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>homeCounter+1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">import</span> <span class="token punctuation">{</span> createNamespacedHelpers <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vuex"</span><span class="token punctuation">;</span>  <span class="token comment">// 方式三</span>  <span class="token comment">// 使用 createNamespacedHelpers 创建基于某个命名空间辅助函数</span>  <span class="token comment">// 它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：</span>  <span class="token keyword">const</span> <span class="token punctuation">{</span> mapState<span class="token punctuation">,</span> mapGetters<span class="token punctuation">,</span> mapMutations<span class="token punctuation">,</span> mapActions <span class="token punctuation">}</span> <span class="token operator">=</span>    <span class="token function">createNamespacedHelpers</span><span class="token punctuation">(</span><span class="token string">"home"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    name<span class="token operator">:</span> <span class="token string">"Home"</span><span class="token punctuation">,</span>    computed<span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token comment">// 这里也是必须使用对象类型进行获取的</span>      <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token function-variable function">homecounter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>homecounter<span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token comment">// 也是需要带模块名，后面跟数据名</span>        doubleHomeCounter<span class="token operator">:</span> <span class="token string">"doubleHomeCounter"</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"increment"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"incrementAction"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">&gt;</span></span><span class="token style"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="nexttick"><a href="#nexttick" class="headerlink" title="nexttick"></a>nexttick</h3><p>官方解释：将回调推迟到下一个 DOM 更新周期之后执行。在更改了一些数据以等待 DOM 更新后立即使用它。</p><p><strong>比如我们有下面的需求：</strong></p><ul><li>点击一个按钮，我们会修改在 h2 中显示的 message；</li><li>message 被修改后，获取 h2 的高度；</li></ul><p>实现上面的案例我们有三种方式：</p><ul><li><p>方式一：在点击按钮后立即获取到 h2 的高度（错误的做法） 。<strong>这种做法每次获取到的高度都是上次的高度。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210905164631027.png" alt="image-20210905164631027"></p></li><li><p>方式二：在 updated 生命周期函数中获取 h2 的高度（但是其他数据更新，也会执行该操作）</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210905164917043.png" alt="image-20210905164917043"></p></li><li><p>方式三：使用 nexttick 函数；</p></li></ul><p>nexttick 是如何做到的呢？</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210905172202592.png" alt="image-20210905172202592"></p><h3 id="historyApiFallback"><a href="#historyApiFallback" class="headerlink" title="historyApiFallback"></a>historyApiFallback</h3><ul><li><p>historyApiFallback 是开发中一个非常常见的属性，它主要的作用是解决 SPA 页面在路由跳转之后，进行页面刷新 时，返回 404 的错误。</p></li><li><p>boolean 值：默认是 false</p><ul><li>如果设置为 true，那么在刷新时，返回 404 错误时，会自动返回 index.html 的内容；</li></ul></li><li><p>object 类型的值，可以配置 rewrites 属性：</p><ul><li>可以配置 from 来匹配路径，决定要跳转到哪一个页面；</li></ul></li><li><p>事实上 devServer 中实现 historyApiFallback 功能是通过 connect-history-api-fallback 库的：</p></li><li><p>可以查看<a href="https://github.com/bripkens/connect-history-api-fallback">connect-history-api-fallback</a> 文档</p></li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210905172411233.png" alt="image-20210905172411233"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> vuex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> ts </tag>
            
            <tag> webpack </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack5</title>
      <link href="/2021/11/05/src/vue/webpack/"/>
      <url>/2021/11/05/src/vue/webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack-学习之旅"><a href="#webpack-学习之旅" class="headerlink" title="webpack 学习之旅"></a>webpack 学习之旅</h1><h2 id="webpack-基础打包"><a href="#webpack-基础打包" class="headerlink" title="webpack 基础打包"></a>webpack 基础打包</h2><h3 id="认识-webpack"><a href="#认识-webpack" class="headerlink" title="认识 webpack"></a>认识 webpack</h3><p><strong>事实上随着前端的快速发展，目前前端的开发已经变的越来越复杂了：</strong></p><ol><li>比如开发过程中我们需要通过模块化的方式来开发；</li><li>比如也会使用一些高级的特性来加快我们的开发效率或者安全性，比如通过 ES6+、TypeScript 开发脚本逻辑， 通过 sass、less 等方式来编写 css 样式代码；</li><li>比如开发过程中，我们还希望实时的监听文件的变化来并且反映到浏览器上，提高开发的效率；</li><li>比如开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化；</li><li>等等….</li></ol><p>但是对于很多的<strong>前端开发者</strong>来说，并不需要思考这些问题，日常的开发中根本就没有面临这些问题：</p><ol><li>这是因为目前前端开发我们通常都会直接使用三大框架来开发：Vue、React、Angular；</li><li>但是事实上，这三大框架的创建过程我们都是借助于脚手架（CLI）的；</li><li>事实上 Vue-CLI、create-react-app、Angular-CLI 都是基于 webpack 来帮助我们支持模块化、less、 TypeScript、打包优化等的；</li></ol><h4 id="脚手架依赖-webpack"><a href="#脚手架依赖-webpack" class="headerlink" title="脚手架依赖 webpack"></a>脚手架依赖 webpack</h4><p><strong>事实上我们上面提到的所有脚手架都是依赖于 webpack 的：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726131437248.png" alt="image-20210726131437248"></p><h4 id="webpack-是什么"><a href="#webpack-是什么" class="headerlink" title="webpack 是什么"></a>webpack 是什么</h4><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726131238052.png" alt="image-20210726131238052"></p><p><strong>我们先来看一下官方的解释：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726131459921.png" alt="image-20210726131459921"></p><p>webpack 是一个<strong>静态的模块化打包工具</strong>，为现代的 JavaScript 应用程序；</p><p><strong>我们来对上面的解释进行拆解：</strong></p><ol><li><strong>打包 bundler</strong>：webpack 可以将帮助我们进行打包，所以它是一个打包工具</li><li><strong>静态的 static</strong>：这样表述的原因是我们最终可以将代码打包成最终的静态资源（部署到静态服务器）；</li><li><strong>模块化 module</strong>：webpack 默认支持各种模块化开发，ES Module、CommonJS、AMD 等；</li><li><strong>现代的 modern</strong>：我们前端说过，正是因为现代前端开发面临各种各样的问题，才催生了 webpack 的出现和发展；</li></ol><h4 id="Vue-项目加载的文件有哪些"><a href="#Vue-项目加载的文件有哪些" class="headerlink" title="Vue 项目加载的文件有哪些"></a>Vue 项目加载的文件有哪些</h4><p><strong>JavaScript 的打包：</strong></p><ul><li><p>将 ES6 转换成 ES5 的语法；</p></li><li><p>TypeScript 的处理，将其转换成 JavaScript；</p><p><strong>Css 的处理：</strong></p></li><li><p>CSS 文件模块的加载、提取；</p></li><li><p>Less、Sass 等预处理器的处理；</p></li></ul><p><strong>资源文件 img、font：</strong></p><ul><li>图片 img 文件的加载；</li><li>字体 font 文件的加载；</li></ul><p><strong>HTML 资源的处理：</strong></p><ul><li>打包 HTML 资源文件；</li><li>处理 vue 项目的 SFC 文件.vue 文件；</li></ul><h4 id="webpack-使用前提"><a href="#webpack-使用前提" class="headerlink" title="webpack 使用前提"></a>webpack 使用前提</h4><p>webpack 的官方文档是<a href="https://webpack.js.org/">https://webpack.js.org/</a> ；</p><p>webpack 的中文官方文档是<a href="https://webpack.docschina.org/">https://webpack.docschina.org/</a> ；</p><p>DOCUMENTATION：文档详情，也是我们最关注的</p><p><strong>Webpack 的运行是依赖 Node 环境的，所以我们电脑上必须有 Node 环境</strong></p><p>所以我们需要先安装 Node.js，并且同时会安装 npm；</p><p>Node 官方网站：<a href="https://nodejs.org/">https://nodejs.org/</a></p><p><strong>推荐安装 LTS 版本，也就是稳定版</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726131906643.png" alt="image-20210726131906643"></p><h4 id="webpack-的安装"><a href="#webpack-的安装" class="headerlink" title="webpack 的安装"></a>webpack 的安装</h4><p>webpack 的安装目前分为两个：webpack、webpack-cli。</p><p>前期我们多以命令行的方式使用 webpack，因此 webpack-cli 也是必须安装的。但是在实际项目中，一般不需要安装 webpack-cli。</p><p><strong>那么它们是什么关系呢？</strong></p><ol><li>执行 webpack 命令，会执行 node_modules 下的.bin 目录下的 webpack；</li><li>webpack 在执行时是依赖 webpack-cli 的，如果没有安装就会报错；</li><li>而 webpack-cli 中代码执行时，才是真正利用 webpack 进行编译和打包的过程；</li><li>所以在安装 webpack 时，我们需要同时安装 webpack-cli（第三方的脚手架事实上是没有使用 webpack-cli 的，而是类似于自 己的 vue-service-cli 的东西）</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210725232410531.png" alt="image-20210725232410531"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install webpack webpack-cli -g # -g 表示全局安装npm install webpack webpack-cli -D # -D 表示局部安装<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210725232640075.png" alt="image-20210725232640075"></p><p>在命令行输入上面的命令，会默认安装最新的版本。如果没有报错则安装成功。</p><p>我们可以在命令行输入 <code>webpack -v</code>查看我们安装的版本。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210725232812911.png" alt="image-20210725232812911"></p><h3 id="webpack-的打包方式"><a href="#webpack-的打包方式" class="headerlink" title="webpack 的打包方式"></a>webpack 的打包方式</h3><h4 id="1-默认打包"><a href="#1-默认打包" class="headerlink" title="1. 默认打包"></a>1. 默认打包</h4><p>我们可以通过 webpack 进行打包，之后运行打包之后的代码</p><p>在<strong>项目根目录下</strong>直接执行 webpack 命令；</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">webpack<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>只要没报错，就执行成功了。警告暂时我们可以先忽略</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726132343482.png" alt="image-20210726132343482"></p><p>我们发现：</p><p><strong>生成一个 dist 文件夹，里面存放一个 main.js 的文件</strong>，就是我们打包之后的文件：</p><ol><li>这个文件中的代码被压缩和丑化了；</li><li>另外我们发现代码中依然存在 ES6 的语法，比如箭头函数、const 等，这是因为默认情况下 webpack 并不清楚我们打包后的文 件是否需要转成 ES5 之前的语法，后续我们需要通过 babel 来进行转换和设置；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726132601754.png" alt="image-20210726132601754"></p><p><strong>我们发现是可以正常进行打包的，但是有一个问题，webpack 是如何确定我们的入口的呢？</strong></p><ol><li>事实上，当我们运行 webpack 时，webpack 会查找当前目录下的 src/index.js 作为入口；</li><li>所以，如果当前项目中没有存在 src/index.js 文件，那么会报错</li></ol><p><strong>当然，我们也可以通过配置来指定入口和出口</strong></p><p>安装好局部的 webpack，但是我们又安装了全局的 webpack 了，这时候如果在命令行直接输入 webpack 命令进行打包。默认使用的还是全局安装的 webpack。</p><p><strong>如何使用局部的 webpack 进行打包呢？</strong></p><p>可以使用 <code>npx webpack</code><strong>使用该命令打包的时候就会使用局部的 webpack</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 调用当前项目的webpack，并指定打包的入口文件和出口目录和文件npx webpack --entry ./src/main.js --output-path ./build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-创建局部的-webpack"><a href="#2-创建局部的-webpack" class="headerlink" title="2. 创建局部的 webpack"></a>2. 创建局部的 webpack</h4><p>前面我们直接执行 webpack 命令使用的是全局的 webpack，如果希望使用局部的可以按照下面的步骤来操作。</p><p>第一步：创建 package.json 文件，用于管理项目的信息、库依赖等</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm init -y # -y 表示按照默认参数进行初始化<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二步：安装局部的 webpack</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install webpack webpack-cli -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第三步：使用局部的 webpack</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npx webpack # 会去调用node_moudles目录下bin里面的webpack目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第四步：在 package.json 中创建 scripts 脚本，执行脚本打包即可</p><p><strong>虽然第三步也可以使用局部的 webpack 进行打包。但是我们一般很少使用</strong>。<em>我们可以在<code>package.json</code>文件里面的<code>script</code>属性里面配置</em></p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"webpack"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>**然后执行 <code>npm run build</code>**目录进行打包</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm run build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会自动去我们的 node_modules 文件夹下面找命令，也就是局部的 webpack</p><h4 id="3-Webpack-配置文件"><a href="#3-Webpack-配置文件" class="headerlink" title="3. Webpack 配置文件"></a>3. Webpack 配置文件</h4><p>在通常情况下，webpack 需要打包的项目是非常复杂的，并且我们需要一系列的配置来满足要求，默认配置必然 是不可以的。我们可以在根目录下创建一个<strong>webpack.config.js</strong>文件，来作为<strong>webpack 的配置文件</strong>：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 配置webpack</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 导出配置必须使用commonjs规范。因为webpack是运行在nodejs环境上的</span><span class="token comment">// 读取导出的配置肯定是使用nodejs默认的规范的。</span><span class="token comment">// 如果想要使用ES6的规范进行导出，需要进行额外的配置。比较麻烦</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment">// 入口 entry  打包文件时的入口文件</span>  entry<span class="token operator">:</span> <span class="token string">"./src/index.js"</span><span class="token punctuation">,</span>  <span class="token comment">// 出口 打包好文件存放的位置，路径</span>  output<span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token comment">// path属性 需要指定绝对路径</span>    path<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"./build"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// 打包后文件的名称</span>    filename<span class="token operator">:</span> <span class="token string">"bundle.js"</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继续执行 webpack 命令，依然可以正常打包</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm run build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-指定配置文件"><a href="#4-指定配置文件" class="headerlink" title="4. 指定配置文件"></a>4. 指定配置文件</h4><p>但是如果我们的配置文件并不是 webpack.config.js 的名字，而是其他的名字呢？</p><ol><li><p>比如我们将 webpack.config.js 修改成了 wk.config.js</p></li><li><p>这个时候我们可以通过 –config 来指定对应的配置文件；</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wepack --config wk.config.js<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>但是每次这样执行命令来对源码进行编译，会非常繁琐，所以我们可以在 package.json 中增加一个新的脚本：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726134001052.png" alt="image-20210726134001052"></p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"srcipt"</span><span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token property">"build"</span><span class="token operator">:</span><span class="token string">"wepack --config wk.config.js"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p><strong>之后我们执行 <code>npm run build</code>来打包即可。</strong></p><h4 id="5-Webpack-的依赖图"><a href="#5-Webpack-的依赖图" class="headerlink" title="5. Webpack 的依赖图"></a>5. Webpack 的依赖图</h4><p>webpack 到底是如何对我们的项目进行打包的呢？</p><ol><li><p>事实上 webpack 在处理应用程序时，它会根据命令或者配置文件找到入口文件；</p></li><li><p>从入口开始，会生成一个 依赖关系图，这个依赖关系图会包含应用程序中所需的所有模块（比如.js 文件、css 文件、图片、字 体等）；</p></li><li><p>然后遍历图结构，打包一个个模块（根据文件的不同使用不同的 loader 来解析）；</p></li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726134147625.png" alt="image-20210726134147625"></p><h3 id="webpack-打包其他文件"><a href="#webpack-打包其他文件" class="headerlink" title="webpack 打包其他文件"></a>webpack 打包其他文件</h3><p>这里我们创建一个 <code>element.js</code> 文件，以及一个 <code>index.css</code>文件。通过 JavaScript 创建了一个元素，并且希望给它设置一些样式；</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// element.js</span><span class="token keyword">import</span> <span class="token string">"../css/index.css"</span><span class="token punctuation">;</span><span class="token comment">// 创建一个div</span><span class="token keyword">const</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置样式</span>div<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">"title1"</span><span class="token punctuation">;</span>div<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">"title"</span><span class="token punctuation">;</span>div<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"&lt;h2&gt;你好!!!!!!&lt;/h2&gt;"</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>div<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.title</span> <span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> bisque<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行编译打包命令（<code>npm run build</code>）时：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726134628990.png" alt="image-20210726134628990"></p><h4 id="1-css-loader-的使用"><a href="#1-css-loader-的使用" class="headerlink" title="1. css-loader 的使用"></a>1. css-loader 的使用</h4><p>上面的错误信息告诉我们需要一个<strong>loader 来加载这个 css 文件</strong>，但是 loader 是什么呢？</p><ol><li>loader 可以用于对模块的源代码进行转换；</li><li>我们可以将 css 文件也看成是一个模块，我们是通过 import 来加载这个模块的；</li><li>在加载这个模块时，webpack 其实并不知道如何对其进行加载，我们必须制定对应的 loader 来完成这个功能；</li></ol><p>那么我们需要一个什么样的 loader 呢？</p><ol><li><p>对于加载 css 文件来说，我们需要一个可以读取 css 文件的 loader；</p></li><li><p>这个 loader 最常用的是 css-loader。</p></li></ol><p><strong>css-loader 的安装：</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install css-loader -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="css-loader-的使用方案"><a href="#css-loader-的使用方案" class="headerlink" title="css-loader 的使用方案"></a>css-loader 的使用方案</h5><p>如何使用这个 loader 来加载 css 文件呢？有三种方式：</p><ol><li>内联方式；</li><li>CLI 方式（webpack5 中不再使用）；</li><li>配置方式</li></ol><h6 id="内联方式"><a href="#内联方式" class="headerlink" title="内联方式"></a>内联方式</h6><p>内联方式使用较少，因为不方便管理；</p><p><strong>在引入的样式前加上使用的 loader，并且使用!分割</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 导入css</span><span class="token comment">// 内联样式指定加载文件时使用的loader (了解)</span><span class="token comment">// 语法： import 'loader!文件路径'  要注意loader后面有一个叹号 是用来分割加载器和文件的 必须有</span><span class="token keyword">import</span> <span class="token string">"css-loader!../css/index.css"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="CLI-方式"><a href="#CLI-方式" class="headerlink" title="CLI 方式"></a>CLI 方式</h6><ol><li>在 webpack5 的文档中已经没有了–module-bind；</li><li>实际应用中也比较少使用，因为不方便管理；</li></ol><h6 id="loader-配置方式-重点"><a href="#loader-配置方式-重点" class="headerlink" title="loader 配置方式(重点)"></a>loader 配置方式(重点)</h6><p><strong>配置方式表示的意思是在我们的 webpack.config.js 文件中写明配置信息：</strong></p><ol><li>module.rules 中允许我们配置多个 loader（因为我们也会继续使用其他的 loader，来完成其他文件的加载）；</li><li>这种方式可以更好的表示 loader 的配置，也方便后期的维护，同时也让你对各个 Loader 有一个全局的概览；</li></ol><p><strong>module.rules 的配置如下：</strong></p><ul><li>rules 属性对应的值是一个数组：[Rule]</li><li>数组中存放的是一个个的 Rule，Rule 是一个对象，对象中可以设置多个属性：<ul><li><strong>test 属性：</strong>用于对 resource（资源）进行匹配的，通常会设置成正则表达式；</li><li><strong>use 属性：</strong>对应的值时一个数组：[UseEntry]<ul><li>UseEntry 是一个对象，可以通过对象的属性来设置一些其他属性<ul><li>oader：必须有一个 loader 属性，对应的值是一个字符串；</li><li>options：可选的属性，值是一个字符串或者对象，值会被传入到 loader 中； Ø</li><li>query：目前已经使用 options 来替代；</li></ul></li><li>传递字符串（如：use: [ ‘style-loader’ ]）是 loader 属性的简写方式（如：use: [ { loader: ‘style-loader’} ]）；</li></ul></li><li><strong>loader 属性</strong>： Rule.use: [ { loader } ] 的简写。</li></ul></li></ul><p><strong>具体的相关配置如下展示：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726135426942.png" alt="image-20210726135426942"></p><h4 id="2-style-loader"><a href="#2-style-loader" class="headerlink" title="2. style-loader"></a>2. style-loader</h4><p>我们已经可以通过 css-loader 来加载 css 文件了 。但是你会发现这个 css 在我们的代码中并没有生效（页面没有效果）。</p><p><strong>这是为什么呢？</strong></p><ol><li>因为 css-loader 只是负责将.css 文件进行解析，并不会将解析之后的 css 插入到页面中；</li><li>如果我们希望再完成插入 style 的操作，那么我们还需要另外一个 loader，就是 style-loader；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726135858149.png" alt="image-20210726135858149"></p><p><strong>安装 style-loader</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i style-loader -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="配置-style-loader"><a href="#配置-style-loader" class="headerlink" title="配置 style-loader"></a>配置 style-loader</h5><p>那么我们应该如何使用 style-loader：</p><ol><li>在配置文件中，添加 style-loader；</li><li>注意：因为 loader 的执行顺序是从右向左（或者说从下到上，或者说从后到前的），所以我们需要将 styleloader 写到 css-loader 的前面</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726135651286.png" alt="image-20210726135651286"></p><p>重新执行编译 npm run build，可以发现打包后的 css 已经生效了：</p><ol><li>当前目前我们的 css 是通过页内样式的方式添加进来的；</li><li>后续我们也会讲如何将 css 抽取到单独的文件中，并且进行压缩等操作；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726135948555.png" alt="image-20210726135948555"></p><h4 id="3-如何处理-less-文件"><a href="#3-如何处理-less-文件" class="headerlink" title="3. 如何处理 less 文件"></a>3. 如何处理 less 文件</h4><p>在我们开发中，我们可能会使用 less、sass、stylus 的预处理器来编写 css 样式，效率会更高。</p><p>那么，如何可以让我们的环境支持这些<strong>预处理器</strong>呢？</p><p>首先我们需要确定，less、sass 等编写的 css 需要通过工具转换成普通的 css；</p><p>比如我们编写如下的 less 样式：</p><pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token variable">@bgColor<span class="token punctuation">:</span></span> #aca<span class="token punctuation">;</span><span class="token variable">@textDecoration<span class="token punctuation">:</span></span> underline<span class="token punctuation">;</span><span class="token selector">.title</span> <span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token variable">@bgColor</span><span class="token punctuation">;</span>  <span class="token property">text-decoration</span><span class="token punctuation">:</span> <span class="token variable">@textDecoration</span><span class="token punctuation">;</span>  <span class="token property">user-select</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Less-工具处理"><a href="#Less-工具处理" class="headerlink" title="Less 工具处理"></a>Less 工具处理</h5><p>我们可以使用 less 工具来完成它的编译转换：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install less -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行如下命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npx lessc ./src/less/index.less index.css<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726140253295.png" alt="image-20210726140253295"></p><h5 id="less-loader"><a href="#less-loader" class="headerlink" title="less-loader"></a>less-loader</h5><p>但是在项目中我们会编写大量的 css，它们如何可以自动转换呢？</p><p>这个时候我们就可以使用 less-loader，来自动使用 less 工具转换 less 到 css；</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install less-loader -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>配置 webpack.config.js</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726140357318.png" alt="image-20210726140357318"></p><p>执行 npm run build less 就可以自动转换成 css，并且页面也会生效了</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726140554154.png" alt="image-20210726140554154"></p><h4 id="4-PostCSS-工具"><a href="#4-PostCSS-工具" class="headerlink" title="4. PostCSS 工具"></a>4. PostCSS 工具</h4><h5 id="1-认识-postcss"><a href="#1-认识-postcss" class="headerlink" title="1. 认识 postcss"></a>1. 认识 postcss</h5><ol><li><p>什么是 PostCSS 呢？</p><ul><li>PostCSS 是一个通过 JavaScript 来转换样式的工具；</li><li>这个工具可以帮助我们进行一些 CSS 的转换和适配，比如自动添加浏览器前缀、css 样式的重置；</li><li>但是实现这些功能，我们需要借助于 PostCSS 对应的插件；</li></ul></li><li><p>如何使用 PostCSS 呢？主要就是两个步骤：</p><ol><li>第一步：查找 PostCSS 在构建工具中的扩展，比如 webpack 中的 postcss-loader；</li><li>第二步：选择可以添加你需要的 PostCSS 相关的插件；</li></ol></li></ol><h5 id="2-命令行使用-postcss"><a href="#2-命令行使用-postcss" class="headerlink" title="2. 命令行使用 postcss"></a>2. 命令行使用 postcss</h5><p>当然，我们能不能也直接在终端使用 PostCSS 呢？</p><p>也是可以的，但是我们需要单独安装一个工具 postcss-cli；</p><p>我们可以安装一下它们：postcss、postcss-cli：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install postcss postcss-cli -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们编写一个需要添加前缀的 css：</p><ol><li><a href="https://autoprefixer.github.io/">https://autoprefixer.github.io/</a></li><li>我们可以在上面的网站中查询一些添加 css 属性的样式</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726140956883.png" alt="image-20210726140956883"></p><h5 id="3-插件-autoprefixer"><a href="#3-插件-autoprefixer" class="headerlink" title="3. 插件 autoprefixer"></a>3. 插件 autoprefixer</h5><p>因为我们需要添加前缀，所以要安装 autoprefixer：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install autoprefixer -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接使用使用 postcss 工具，并且指定使用 autoprefixer</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npx postcss --use autoprefixer -o end.css ./src/css/style.css<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>转化之后的 css 样式如下：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726141124302.png" alt="image-20210726141124302"></p><h5 id="4-postcss-loader-重点"><a href="#4-postcss-loader-重点" class="headerlink" title="4. postcss-loader(重点)"></a>4. postcss-loader(重点)</h5><p>真实开发中我们必然不会直接使用命令行工具来对 css 进行处理，而是可以借助于构建工具：</p><p>在 webpack 中使用<strong>postcss</strong>就是使用<strong>postcss-loader</strong>来处理的；</p><p>我们来安装 postcss-loader：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install postcss-loader -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们修改加载 less 的 loader:</p><p><strong>注意：</strong>因为 postcss 需要有对应的插件才会起效果，所以我们需要配置它的 plugin；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726141409491.png" alt="image-20210726141409491"></p><h5 id="5-单独的-postcss-配置文件"><a href="#5-单独的-postcss-配置文件" class="headerlink" title="5. 单独的 postcss 配置文件"></a>5. 单独的 postcss 配置文件</h5><p>当然，我们也可以将这些配置信息放到一个单独的文件中进行管理：</p><p><strong>在根目录下创建 postcss.config.js</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment">// 配置plugins 插件</span>  plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"autoprefixer"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726141556045.png" alt="image-20210726141556045"></p><h5 id="6-postcss-preset-env"><a href="#6-postcss-preset-env" class="headerlink" title="6. postcss-preset-env"></a>6. postcss-preset-env</h5><p>事实上，在配置 postcss-loader 时，我们配置插件并不需要使用 autoprefixer。</p><p>我们可以使用另外一个插件：postcss-preset-env</p><ol><li>postcss-preset-env 也是一个 postcss 的插件；</li><li>它可以帮助我们将一些现代的 CSS 特性，转成大多数浏览器认识的 CSS，并且会根据目标浏览器或者运行时环境 添加所需的 polyfill；</li><li>也包括会自动帮助我们添加 autoprefixer（所以相当于已经内置了 autoprefixer）；</li></ol><p>首先，我们需要<strong>安装 postcss-preset-env</strong>：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install postcss-preset-env -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后，我们直接修改掉之前的 autoprefixer 即可：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726141730953.png" alt="image-20210726141730953"></p><p><strong>注意：我们在使用某些 postcss 插件时，也可以直接传入字符串</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210726141811408.png" alt="image-20210726141811408"></p><h3 id="webpack-config-js-本次配置展示"><a href="#webpack-config-js-本次配置展示" class="headerlink" title="webpack.config.js 本次配置展示"></a>webpack.config.js 本次配置展示</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 配置webpack</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  entry<span class="token operator">:</span> <span class="token string">"./src/index.js"</span><span class="token punctuation">,</span>  output<span class="token operator">:</span> <span class="token punctuation">{</span>    path<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"./build"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    filename<span class="token operator">:</span> <span class="token string">"bundle.js"</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 配置打包时所有模块的配置 在 module属性下配置</span>  <span class="token comment">// 一个文件也看成一个模块</span>  module<span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token comment">// 模块打包时的规则</span>    <span class="token comment">// 不同文件有不同的规则，所以规则是一个数组，可以配置不同文件不同的规则</span>    rules<span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token comment">// 配置打包css文件（模块）时的规则</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token comment">// 指定文件后缀  正则表达式</span>        <span class="token comment">// 指定loader (语法糖)</span>        <span class="token comment">// loader: 'css-loader'</span>        <span class="token comment">// 只有一个loader时可以不使用数组，直接指定就行</span>        <span class="token comment">// use: 'css-loader'</span>        <span class="token comment">// 没有其他参数时：只有loader时，直接使用数组，里面放的默认都是loader</span>        <span class="token comment">// use: ['css-loader']</span>        <span class="token comment">// 如果当前使用的loader有相关的其他配置，需要在数组里面将元素指定为对象</span>        <span class="token comment">//use: [</span>        <span class="token comment">// 多个loader就是多个对象，一个对象里面一个loader，以及loader的配置 options</span>        <span class="token comment">//{ loader: 'css-loader', options: { modules: true } }</span>        <span class="token comment">//]</span>        <span class="token comment">// 多个loader的加载顺序 从后往前（最先加载数组最后一个loader）</span>        use<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"style-loader"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> loader<span class="token operator">:</span> <span class="token string">"css-loader"</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token comment">// 处理less文件的配置</span>      <span class="token comment">// postcss 工具 增加浏览器前缀 postcss-loader</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.less$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        use<span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token string">"style-loader"</span><span class="token punctuation">,</span>          <span class="token string">"css-loader"</span><span class="token punctuation">,</span>          <span class="token comment">// 如果我们指定了postcss的配置文件（默认情况下叫做 postcss.config.js）</span>          <span class="token comment">// 则不需要再这里指定相关的配置了，直接写postcss-loader就可以了</span>          <span class="token comment">// 优先读取本文件里面的配置，然后去 postcss.config.js 配置文件里面读取导出的配置</span>          <span class="token string">"postcss-loader"</span><span class="token punctuation">,</span>          <span class="token comment">/* {            loader: 'postcss-loader',            // 配置postcss-loader的加载时的参数，选项            options: {              postcssOptions: {                // 插件可以指定多个 数组形式                plugins: [                  // 导入使用的插件 使用require(插件)                  require('autoprefixer')                ]              }            }          }, */</span>          <span class="token string">"less-loader"</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="postcss-config-js-本次配置展示"><a href="#postcss-config-js-本次配置展示" class="headerlink" title="postcss.config.js 本次配置展示"></a>postcss.config.js 本次配置展示</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// postcss 的配置</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment">// 配置plugins 插件</span>  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token comment">// 实际开发中，我们很少使用 autoprefixer 这个插件</span>    <span class="token comment">// 我们会使用 更好的插件 postcss-prefix-env</span>    <span class="token comment">// require('autoprefixer')</span>    <span class="token comment">// 这个插件的功能更强，切也具有 autoprefixer 插件的功能</span>    <span class="token comment">// 可以理解为具备了 autoprefixer 的功能</span>    <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"postcss-preset-env"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Webpack-打包其他资源"><a href="#Webpack-打包其他资源" class="headerlink" title="Webpack 打包其他资源"></a>Webpack 打包其他资源</h2><p><strong>加载图片案例准备</strong></p><p>为了演示我们项目中可以加载图片，我们需要在项目中使用图片，比较常见的使用图片的方式是两种：</p><ol><li>img 元素，设置 src 属性；</li><li>其他元素（比如 div），设置 background-image 的 css 属性；</li></ol><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.image-bg</span> <span class="token punctuation">{</span>  <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token string url">"../image/3.jpg"</span><span class="token punctuation">)</span></span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 导入背景图片的样式</span><span class="token keyword">import</span> <span class="token string">"../css/index.css"</span><span class="token punctuation">;</span><span class="token keyword">import</span> myImg <span class="token keyword">from</span> <span class="token string">"../image/1.JPG"</span><span class="token punctuation">;</span><span class="token comment">// 设置背景图片</span><span class="token keyword">const</span> bgDiv <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bgDiv<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">"image-bg"</span><span class="token punctuation">;</span><span class="token comment">// 设置img标签的src属性</span><span class="token keyword">const</span> img <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"img"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>img<span class="token punctuation">.</span>src <span class="token operator">=</span> myImg<span class="token punctuation">;</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>bgDiv<span class="token punctuation">)</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这个时候，打包会报错</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728191425399.png" alt="image-20210728191425399"></p><p>报错了，并且提示我们可以需要一个 loader 来解决图片的问题。</p><h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h3><p>要处理 jpg、png 等格式的图片，我们也需要有对应的<strong>loader：file-loader</strong></p><ol><li>file-loader 的作用就是帮助我们处理 import/require()方式引入的一个文件资源，并且会将它放到我们输出的文 件夹中；</li><li>当然我们待会儿可以学习如何修改它的名字和所在文件夹；</li></ol><p><strong>安装 file-loader：</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i file-loader -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置处理图片的 Rule：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 配置打包图片资源的规则</span><span class="token punctuation">{</span>    test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(jpg|png|jpeg|JPG)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>    use<span class="token operator">:</span> <span class="token string">'file-loader'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728191711488.png" alt="image-20210728191711488"></p><p>我们会发现图片也被打包了。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728191748775.png" alt="image-20210728191748775"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728191838557.png" alt="image-20210728191838557"></p><h4 id="文件的命名规则"><a href="#文件的命名规则" class="headerlink" title="文件的命名规则"></a>文件的命名规则</h4><p>有时候我们处理后的<strong>文件名</strong>称按照一定的规则进行显示：</p><ul><li>比如保留原来的文件名、扩展名，同时为了防止重复，包含一个 hash 值等；</li></ul><p>这个时候我们可以使用 PlaceHolders 来完成，webpack 给我们提供了大量的 PlaceHolders 来显示不同的内容：</p><ol><li> <a href="https://webpack.js.org/loaders/file-loader/#placeholders">https://webpack.js.org/loaders/file-loader/#placeholders</a></li><li> 我们可以在文档中查阅自己需要的 placeholder；</li></ol><p>我们这里介绍几个最常用的 placeholder：</p><ul><li>**[ext]**： 处理文件的扩展名；</li><li>**[name]**：处理文件的名称；</li><li>**[hash]**：文件的内容，使用 MD4 的散列函数处理，生成的一个 128 位的 hash 值（32 个十六进制）；</li><li>[contentHash]：在 file-loader 中和[hash]结果是一致的（在 webpack 的一些其他地方不一样，后面会讲到）；</li><li>**[hash:length]**：截图 hash 的长度，默认 32 个字符太长了；</li><li>**[path]**：文件相对于 webpack 配置文件的路径；</li></ul><h4 id="设置文件的名称"><a href="#设置文件的名称" class="headerlink" title="设置文件的名称"></a>设置文件的名称</h4><p>那么我们可以按照如下的格式编写：<strong>这个也是 vue 的写法；</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(jpg|png|jpeg|JPG)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        use<span class="token operator">:</span> <span class="token punctuation">{</span>          loader<span class="token operator">:</span> <span class="token string">'file-loader'</span><span class="token punctuation">,</span>          <span class="token comment">// file-loader的参数配置</span>          options<span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token comment">// 打包后图片文件所在的路径</span>            <span class="token comment">// outputPath: 'image',</span>            <span class="token comment">// 打包后生成文件的名称</span>            <span class="token comment">// [name] 源文件的名称（不含拓展名）</span>            <span class="token comment">// 我们发现不写配置时，文件的名称过长（且文件名是通过hash算法算出来的，为了防止重名）</span>            <span class="token comment">// [hash:6] 默认生成文件名称的hash算法，32位，取前六位</span>            <span class="token comment">// [ext] 使用原来文件的拓展名</span>            <span class="token comment">// name: '[name]_[hash:6].[ext]'</span>            <span class="token comment">// 当然：我们也可以把图片存放的路径和图片名称合在一起</span>            name<span class="token operator">:</span> <span class="token string">'image/[name]-[hash:6].[ext]'</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728192329730.png" alt="image-20210728192329730"></p><h4 id="设置文件的存放路径"><a href="#设置文件的存放路径" class="headerlink" title="设置文件的存放路径"></a>设置文件的存放路径</h4><p>当然，我们刚才通过 img/ 已经设置了文件夹，这个也是 vue、react 脚手架中常见的设置方式：</p><ol><li>其实按照这种设置方式就可以了；</li><li>当然我们也可以通过<strong>outputPath</strong>来设置输出的文件夹；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728192445432.png" alt="image-20210728192445432"></p><h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h3><p><strong>url-loader 和 file-loader</strong>的工作方式是相似的，但是可以将较小的文件，转成 base64 的 URI。</p><p><strong>安装 url-loader：</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i url-loader -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(jpe?g|JPG|png)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        use<span class="token operator">:</span> <span class="token punctuation">{</span>          loader<span class="token operator">:</span> <span class="token string">'url-loader'</span><span class="token punctuation">,</span>          options<span class="token operator">:</span> <span class="token punctuation">{</span>            name<span class="token operator">:</span> <span class="token string">'image/[name]-[hash:6].[ext]'</span><span class="token punctuation">,</span>            <span class="token comment">// 设置图片大小的限制，只有小于多少kb的图片我们才会转为base64格式</span>            <span class="token comment">// 如果大于这个限制 我们就不会转为base64格式。而是继续采用上面的path和name的形式打包，还是保持图片的形式不变</span>            limit<span class="token operator">:</span> <span class="token number">100</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token comment">// 小于100kb的文件才会转为base64格式</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728192652383.png" alt="image-20210728192652383"></p><p><strong>显示结果是一样的，并且图片可以正常显示；</strong></p><p>但是在 dist 文件夹中，我们会看不到 <strong>大于 100kb</strong> 图片文件：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728192839738.png" alt="image-20210728192839738"></p><ol><li>这是因为我的两张图片的大小分别是 38kb 和 129kb；</li><li>默认情况下 url-loader 会将所有的图片文件转成 base64 编码。但是配置了 limit 以后就可以限制小于多少 kb 的图片才会转为 base64 格式。</li></ol><p><strong>可以看见 bundle.js 文件里面的确有 base64 格式的字符串</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728193159584.png" alt="image-20210728193159584"></p><h3 id="url-loader-的-limit"><a href="#url-loader-的-limit" class="headerlink" title="url-loader 的 limit"></a>url-loader 的 limit</h3><p>但是开发中我们往往是小的图片需要转换，但是<strong>大的图片直接使用图片即可</strong></p><ol><li>这是因为小的图片转换 base64 之后可以和页面一起被请求，减少不必要的请求过程；</li><li>而大的图片也进行转换，反而会影响页面的请求速度；</li></ol><p>那么，我们如何可以<strong>限制哪些大小的图片</strong>转换和不转换呢？</p><ol><li>url-loader 有一个 options 属性 limit，可以用于设置转换的限制；</li><li>下面的代码 38kb 的图片会进行 base64 编码，而 129kb 的不会；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728193333744.png" alt="image-20210728193333744"></p><h3 id="asset-module-type"><a href="#asset-module-type" class="headerlink" title="asset module type"></a>asset module type</h3><h4 id="认识-asset-module-type"><a href="#认识-asset-module-type" class="headerlink" title="认识 asset module type"></a>认识 asset module type</h4><p><strong>我们当前使用的 webpack 版本是 webpack5：</strong></p><ol><li>在 webpack5 之前，加载这些资源我们需要使用一些 loader，比如<strong>raw-loader 、url-loader、file-loader；</strong></li><li>在 webpack5 开始，我们可以直接使用<strong>资源模块类型</strong>（asset module type），来替代上面的这些 loader；</li></ol><p><strong>资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader：</strong></p><ol><li><strong>asset/resource</strong> ：发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现；</li><li><strong>asset/inline</strong> ：导出一个资源的 data URI。之前通过使用 url-loader 实现；</li><li><strong>asset/source</strong> ：导出资源的源代码。之前通过使用 raw-loader 实现；</li><li><strong>asset</strong>： 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体 积限制实现；</li></ol><h4 id="asset-module-type-的使用"><a href="#asset-module-type-的使用" class="headerlink" title="asset module type 的使用"></a>asset module type 的使用</h4><p>比如加载图片，我们可以使用下面的方式：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728193636774.png" alt="image-20210728193636774"></p><p><strong>发现依然打包成功！</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728193748026.png" alt="image-20210728193748026"></p><p><strong>但是，如何可以自定义文件的输出路径和文件名呢？</strong></p><p>方式一：修改 output，添加 assetModuleFilename 属性； <strong>（了解即可）</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728193854459.png" alt="image-20210728193854459"></p><p>方式二：在 Rule 中，添加一个 generator 属性，并且设置 filename；</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(JPG|jpe?g|png)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        <span class="token comment">// 这里不在使用use属性 而是type属性</span>        <span class="token comment">// 使用asset/resource 来代替 file-loader</span>        <span class="token comment">// type:'asset/resource'</span>        <span class="token comment">// 比较常用的我们一般直接写成 asset</span>        type<span class="token operator">:</span> <span class="token string">'asset'</span><span class="token punctuation">,</span>        <span class="token comment">// 下面的配置也可以放在 output里面（了解）</span>        <span class="token comment">// generator属性 生成 也就是打包后的图片存放时相关的配置</span>        generator<span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token comment">// 配置图片名称和图片位置</span>          <span class="token comment">// 这里的 [ext] 拿到的文件拓展名包含 .</span>          filename<span class="token operator">:</span> <span class="token string">'image/[name]-[hash:6][ext]'</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728194023352.png" alt="image-20210728194023352"></p><h4 id="url-loader-的-limit-效果"><a href="#url-loader-的-limit-效果" class="headerlink" title="url-loader 的 limit 效果"></a>url-loader 的 limit 效果</h4><p>我们需要两个步骤来实现：</p><ol><li>将 type 必须使用 asset 属性值；</li><li>添加一个 parser 属性，并且制定 dataUrl 的条件，添加 maxSize 属性；</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(JPG|jpe?g|png)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        <span class="token comment">// 比较常用的我们一般直接写成 asset</span>        type<span class="token operator">:</span> <span class="token string">'asset'</span><span class="token punctuation">,</span>        <span class="token comment">// 配置相关的asset参数 使用parser属性</span>        parser<span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token comment">// 数据url条件</span>          dataUrlCondition<span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token comment">// 最大不超过多少kb的图片 我们转为 base64格式</span>            maxSize<span class="token operator">:</span> <span class="token number">100</span> <span class="token operator">*</span> <span class="token number">1024</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        generator<span class="token operator">:</span> <span class="token punctuation">{</span>          filename<span class="token operator">:</span> <span class="token string">'image/[name]-[hash:6][ext]'</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728194251709.png" alt="image-20210728194251709"></p><p><strong>发现打包的只有一个图片文件了。较小的那个已经转为 base64 格式了</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728194347840.png" alt="image-20210728194347840"></p><h3 id="加载字体文件"><a href="#加载字体文件" class="headerlink" title="加载字体文件"></a>加载字体文件</h3><p>如果我们需要使用某些<strong>特殊的字体或者字体图标</strong>，那么我们会引入很多字体相关的文件，这些文件的处理也是一样 的</p><p><strong>首先，我从阿里图标库中下载了几个字体图标：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728195048166.png" alt="image-20210728195048166"></p><p><strong>然后在 font.js 里面引入</strong>，并设置一个 <code>i</code>标签用于显示字体图标</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 引入并使用字体图标</span><span class="token comment">// 加载字体图标的文件</span><span class="token keyword">import</span> <span class="token string">"../font/iconfont.css"</span><span class="token punctuation">;</span><span class="token comment">// i标签</span><span class="token keyword">const</span> i <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"i"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">"iconfont icon-ashbin"</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>然后我们开始打包</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728195219912.png" alt="image-20210728195219912"></p><p><strong>毫无疑问，必然报错，因为我们使用了 webpack 并不认识的模块。并且 webpack 也提醒我们需要使用一个 loader 来解决。</strong></p><h4 id="字体的打包"><a href="#字体的打包" class="headerlink" title="字体的打包"></a>字体的打包</h4><p>这个时候打包会报错，因为<strong>无法正确的处理 eot、ttf、woff 等文件</strong>：</p><p>我们可以选择使用<strong>file-loader</strong>来处理，也可以选择直接使用<strong>webpack5 的资源模块类型</strong>来处理；</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 配置字体和字体图标等文件打包时的规则</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(eot|ttf|woff2?)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        use<span class="token operator">:</span><span class="token punctuation">{</span>          loader<span class="token operator">:</span> <span class="token string">'file-loader'</span><span class="token punctuation">,</span>          options<span class="token operator">:</span><span class="token punctuation">{</span>            name<span class="token operator">:</span> <span class="token string">'font/[name]-[hash:6].[ext]'</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>打包之后，发现不会报错，字体图标正常显示。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728200328258.png" alt="image-20210728200328258"></p><p><strong>使用 webpack5 提供的资源模块类型也可以。</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 也可以使用webpack提供的资源模块类型</span><span class="token punctuation">{</span>    test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(eot|ttf|woff2?)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>    type<span class="token operator">:</span> <span class="token string">'asset/resource'</span><span class="token punctuation">,</span>    generator<span class="token operator">:</span><span class="token punctuation">{</span>        filename<span class="token operator">:</span> <span class="token string">'font/[name]-[hash:6][ext]'</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="webpack-的-plugin"><a href="#webpack-的-plugin" class="headerlink" title="webpack 的 plugin"></a>webpack 的 plugin</h3><h4 id="认识-plugin"><a href="#认识-plugin" class="headerlink" title="认识 plugin"></a>认识 plugin</h4><p>Webpack 的另一个核心是 Plugin，官方有这样一段对 Plugin 的描述：</p><p><strong>While loaders are used to transform certain types of modules, plugins can be leveraged to perform a wider range of tasks like bundle optimization, asset management and injection of environment variables.</strong></p><p>上面表达的含义翻译过来就是：</p><ol><li>Loader 是用于<strong>特定的模块类型进行转换</strong>；</li><li>Plugin 可以用于<strong>执行更加广泛的任务</strong>，比如打包优化、资源管理、环境变量注入等；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728205205354.png" alt="image-20210728205205354"></p><h4 id="CleanWebpackPlugin"><a href="#CleanWebpackPlugin" class="headerlink" title="CleanWebpackPlugin"></a>CleanWebpackPlugin</h4><p>前面我们演示的过程中，每次修改了一些配置，重新打包时，都需要手动删除 dist 文件夹：</p><p>我们可以借助于一个插件来帮助我们完成，这个插件就是<strong>CleanWebpackPlugin；</strong></p><p><strong>首先，我们先安装这个插件：</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i clean-webpack-plugin -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后在插件中配置：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">{</span> CleanWebpackPlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"clean-webpack-plugin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment">// 提供 plugins属性来配置插件</span>  <span class="token comment">// plugins属性是数组，数组元素是一个个的插件对象</span>  plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">CleanWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728205459482.png" alt="image-20210728205459482"></p><p><strong>然后可以发现每次都会帮我们把上次打包的文件夹先删除，然后在进行重新打包。</strong></p><h4 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h4><p>另外还有一个<strong>不太规范</strong>的地方：</p><ol><li>我们的 HTML 文件是编写在根目录下的，而最终打包的 dist 文件夹中是没有 index.html 文件的。</li><li>在进行项目部署的时，必然也是需要有对应的入口文件 index.html；</li><li>所以我们也需要对 index.html 进行打包处理；</li></ol><p>对 HTML 进行打包处理我们可以使用另外一个插件：<strong>HtmlWebpackPlugin；</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i html-webpack-plugin -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728205744529.png" alt="image-20210728205744529"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728205754385.png" alt="image-20210728205754385"></p><h5 id="生成-index-html-分析"><a href="#生成-index-html-分析" class="headerlink" title="生成 index.html 分析"></a>生成 index.html 分析</h5><p>我们会发现，现在自动在 build 文件夹中，生成了一个<strong>index.html</strong>的文件：</p><p>该文件中也自动添加了我们打包的 bundle.js 文件；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728210054115.png" alt="image-20210728210054115"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728205905823.png" alt="image-20210728205905823"></p><p><strong>这个文件是如何生成的呢？</strong></p><ol><li><strong>默认情况</strong>下是根据<strong>ejs 的一个模板</strong>来生成的；</li><li>在 html-webpack-plugin 的源码中，有一个 default_index.ejs 模块；</li></ol><h5 id="自定义-HTML-模板"><a href="#自定义-HTML-模板" class="headerlink" title="自定义 HTML 模板"></a>自定义 HTML 模板</h5><p>如果我们想在自己的模块中加入一些比较特别的内容：</p><ol><li><p>比如添加一个 noscript 标签，在用户的 JavaScript 被关闭时，给予响应的提示；</p></li><li><p>比如在开发 vue 或者 react 项目时，我们需要一个可以挂载后续组件的根标签</p><p>；</p></li></ol><p><strong>这个我们需要一个属于自己的 index.html 模块：</strong></p><p><strong>下面是模板代码（使用 Vue-cli 脚手架开发时的默认的模板就是这个）</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width,initial-scale=1.0<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>icon<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&lt;%= BASE_URL %&gt;favicon.ico<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>noscript</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span>        <span class="token punctuation">&gt;</span></span>We're sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn't work        properly without JavaScript enabled. Please enable it to        continue.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span>      <span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>noscript</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- built files will be auto injected --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>但是：使用这个模板直接进行打包的时候：会发现打包失败！！（使用 html-webpack-plugin 插件的时候需要指定该模板）</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728211538093.png" alt="image-20210728211538093"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728212035161.png" alt="image-20210728212035161"></p><h5 id="自定义模板数据填充"><a href="#自定义模板数据填充" class="headerlink" title="自定义模板数据填充"></a>自定义模板数据填充</h5><p>上面的代码中，会有一些类似这样的语法**&lt;% 变量 %&gt;**，这个是 EJS 模块填充数据的方式。</p><p>在配置 HtmlWebpackPlugin 时，我们可以添加如下配置：</p><ol><li><strong>template</strong>：指定我们要使用的模块所在的路径；</li><li><strong>title</strong>：在进行 htmlWebpackPlugin.options.title 读取时，就会读到该信息；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728212132479.png" alt="image-20210728212132479"></p><p><strong>但是，我们会发现，即使配置了模板啊，标题啊，仍然打包还是报错。</strong></p><p>不要着急，我们可以使用 webpack 内置的一个插件来进行解决。</p><h4 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h4><h5 id="DefinePlugin-的介绍"><a href="#DefinePlugin-的介绍" class="headerlink" title="DefinePlugin 的介绍"></a>DefinePlugin 的介绍</h5><p>我们上面指定了模板以后，发现仍然还是报错。报错的原因是什么呢？</p><p><strong>因为在我们的模块中还使用到一个 BASE_URL 的常量：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728212410783.png" alt="image-20210728212410783"></p><p>这是因为在编译 template 模块时，有一个<strong>BASE_URL</strong>：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>icon<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&lt;%= BASE_URL %&gt;favicon.ico<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是我们并没有设置过这个常量值，所以会出现没有定义的错误；</p><p>这个时候我们可以使用<strong>DefinePlugin 插件</strong>；</p><h5 id="DefinePlugin-的使用"><a href="#DefinePlugin-的使用" class="headerlink" title="DefinePlugin 的使用"></a>DefinePlugin 的使用</h5><p>DefinePlugin 允许在编译时创建配置的<strong>全局常量</strong>，是一个 webpack 内置的插件（不需要单独安装）：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728213427918.png" alt="image-20210728213427918"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728213438757.png" alt="image-20210728213438757"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 导入 DefinePlugin 插件 解决常量 BASE_URL 的问题</span><span class="token keyword">const</span> <span class="token punctuation">{</span> DefinePlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment">// 提供 plugins属性来配置插件</span>  <span class="token comment">// plugins属性是数组，数组元素是一个个的插件对象</span>  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token comment">// 使用 DefinePlugin 插件来定义 常量</span>    <span class="token keyword">new</span> <span class="token class-name">DefinePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      <span class="token constant">BASE_URL</span><span class="token operator">:</span> <span class="token string">"'./'"</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候，编译 template 就可以正确的编译了，会读取到<strong>BASE_URL</strong>的值；</p><h5 id="DefinePlugin-的注意点"><a href="#DefinePlugin-的注意点" class="headerlink" title="DefinePlugin 的注意点"></a>DefinePlugin 的注意点</h5><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">DefinePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token comment">// BASE_URL 会根据后面给的属性值 去本文件上下文中找这个变量</span>  <span class="token comment">// 比如我这里给的是字符串 "filepath"</span>  <span class="token comment">// 也会去上下文中找叫做 filepath 的变量</span>  <span class="token comment">// 如果我们想直接给一个字符串的值</span>  <span class="token comment">// 我们需要在双引号里面嵌套单引号赋值</span>  <span class="token comment">// 当然 单引号里面嵌套双引号赋值也是可以的</span>  <span class="token comment">// BASE_URL: "filepath",</span>  <span class="token constant">BASE_URL</span><span class="token operator">:</span> <span class="token string">"'./'"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CopyWebpackPlugin"><a href="#CopyWebpackPlugin" class="headerlink" title="CopyWebpackPlugin"></a>CopyWebpackPlugin</h3><p>在 vue 的打包过程中，如果我们将一些文件放到 public 的目录下，那么这个目录会被复制到 dist 文件夹中。这个复制的功能，我们可以使用 CopyWebpackPlugin 来完成；</p><p><strong>安装 CopyWebpackPlugin 插件：</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i copy-webpack-plugin -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>接下来配置 CopyWebpackPlugin 即可：</strong></p><ol><li>复制的规则在 patterns 中设置；</li><li><strong>from</strong>：设置从哪一个源中开始复制；</li><li><strong>to</strong>：复制到的位置，可以省略，会默认复制到打包的目录下；</li><li><strong>globOptions</strong>：设置一些额外的选项，其中可以编写需要忽略的文件：<ul><li>.DS_Store：mac 目录下回自动生成的一个文件；</li><li>index.html：也不需要复制，因为我们已经通过 HtmlWebpackPlugin 完成了 index.html 的生成；</li></ul></li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> CopyWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"copy-webpack-plugin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token comment">// 其他省略</span>    <span class="token keyword">new</span> <span class="token class-name">CopyWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      patterns<span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>          <span class="token comment">// 复制的来源</span>          from<span class="token operator">:</span> <span class="token string">"public"</span><span class="token punctuation">,</span>          to<span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>          <span class="token comment">// 全局配置  globOptions</span>          globOptions<span class="token operator">:</span> <span class="token punctuation">{</span>            ignore<span class="token operator">:</span> <span class="token string">"**/index.html"</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>可以看到效果和我们的配置的一样。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728215659702.png" alt="image-20210728215659702"></p><h3 id="Mode-配置"><a href="#Mode-配置" class="headerlink" title="Mode 配置"></a>Mode 配置</h3><p><strong>前面我们一直没有讲 mode。</strong></p><p>Mode 配置选项，可以告知 webpack 使用<strong>响应模式</strong>的内置优化：</p><ol><li>默认值是 production（什么都不设置的情况下）；</li><li>可选值有：’none’ | ‘development’ | ‘production’；</li></ol><table><thead><tr><th align="center">选项</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">development</td><td align="center">会将 <code>DefinePlugin</code> 中 <code>process.env.NODE_ENV</code> 的值设置为 <code>development</code>. 为模块和 chunk 启用有效的名。</td></tr><tr><td align="center">production</td><td align="center">会将 <code>DefinePlugin</code> 中 <code>process.env.NODE_ENV</code> 的值设置为 <code>production</code>。为模块和 chunk 启用确定性的混淆名称，<code>FlagDependencyUsagePlugin</code>，<code>FlagIncludedChunksPlugin</code>，<code>ModuleConcatenationPlugin</code>，<code>NoEmitOnErrorsPlugin</code> 和 <code>TerserPlugin</code> 。</td></tr><tr><td align="center">none</td><td align="center">不使用任何默认优化选项</td></tr></tbody></table><p><strong>如果没有设置，webpack 会给 <code>mode</code> 的默认值设置为 <code>production</code>。</strong></p><p>如果 <code>mode</code> 未通过配置或 CLI 赋值，CLI 将使用可能有效的 <code>NODE_ENV</code> 值作为 <code>mode</code>。当然这是后话了。我们学习 CLI 的时候再来说。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728221004362.png" alt="image-20210728221004362"></p><h4 id="Mode-配置代表更多"><a href="#Mode-配置代表更多" class="headerlink" title="Mode 配置代表更多"></a>Mode 配置代表更多</h4><p><strong>只要设置了 mode 属性，webpack 就会默认帮我们设置很多属性。不需要我们手动再去配置。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728221656536.png" alt="image-20210728221656536"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728221716634.png" alt="image-20210728221716634"></p><h3 id="devtool-配置"><a href="#devtool-配置" class="headerlink" title="devtool 配置"></a>devtool 配置</h3><p><strong>这里顺手补充一波 devtool</strong>。</p><p><strong>devtool</strong>也是和<strong>mode</strong>同级别的配置。默认值是 eval。<em>设置开发时的工具</em></p><p>此选项控制是否生成，以及如何生成 <strong>source map</strong>。</p><h5 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h5><p>在默认值的情况下：<em>默认会使用 eval 函数对源代码进行包裹</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// devtool 属性 ：设置开发时的工具 默认值是 eval</span><span class="token comment">// 默认会使用 eval函数对源代码进行包裹</span>devtool<span class="token operator">:</span> <span class="token string">"eval"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728223031699.png"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728223158431.png" alt="image-20210728223158431"></p><p><strong>发现我们的打包后的代码全都被 eval 函数包裹</strong></p><h5 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h5><p><strong>把属性设置为 source-map</strong>。出现错误就可以定位源码。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 如果想查看源码：可以设置值为 source-map</span><span class="token comment">// 设置为这个属性 会生成对应的打包后的代码和源码映射的文件</span><span class="token comment">// 出现错误可以映射到我们书写的源代码</span>devtool<span class="token operator">:</span> <span class="token string">"source-map"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728223248505.png" alt="image-20210728223248505"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728223306610.png" alt="image-20210728223306610"></p><h5 id="两种方式出现错误后的对比"><a href="#两种方式出现错误后的对比" class="headerlink" title="两种方式出现错误后的对比"></a>两种方式出现错误后的对比</h5><h6 id="eval-配置代码出现错误时"><a href="#eval-配置代码出现错误时" class="headerlink" title="eval 配置代码出现错误时"></a>eval 配置代码出现错误时</h6><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728223827751.png" alt="image-20210728223827751"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728223842559.png" alt="image-20210728223842559"></p><p><strong>发现代码并不是我们自己写的源码。不好辨别具体是那个文件出现错误。</strong></p><h6 id="source-map-配置代码出现错误时"><a href="#source-map-配置代码出现错误时" class="headerlink" title="source-map 配置代码出现错误时"></a>source-map 配置代码出现错误时</h6><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728223957836.png" alt="image-20210728223957836"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210728224005593.png" alt="image-20210728224005593"></p><p><strong>出现错误，可以直接定位到具体是哪一个源文件。很 nice。</strong></p><h5 id="附上-devtool-的各种配置"><a href="#附上-devtool-的各种配置" class="headerlink" title="附上 devtool 的各种配置"></a>附上 devtool 的各种配置</h5><table><thead><tr><th align="left">devtool</th><th align="left">performance</th><th align="left">production</th><th align="left">quality</th><th align="left">comment</th></tr></thead><tbody><tr><td align="left">(none)</td><td align="left"><strong>build</strong>: fastest <strong>rebuild</strong>: fastest</td><td align="left">yes</td><td align="left">bundle</td><td align="left">Recommended choice for production builds with maximum performance.</td></tr><tr><td align="left"><strong><code>eval</code></strong></td><td align="left"><strong>build</strong>: fast <strong>rebuild</strong>: fastest</td><td align="left">no</td><td align="left">generated</td><td align="left">Recommended choice for development builds with maximum performance.</td></tr><tr><td align="left"><code>eval-cheap-source-map</code></td><td align="left"><strong>build</strong>: ok <strong>rebuild</strong>: fast</td><td align="left">no</td><td align="left">transformed</td><td align="left">Tradeoff choice for development builds.</td></tr><tr><td align="left"><code>eval-cheap-module-source-map</code></td><td align="left"><strong>build</strong>: slow <strong>rebuild</strong>: fast</td><td align="left">no</td><td align="left">original lines</td><td align="left">Tradeoff choice for development builds.</td></tr><tr><td align="left"><strong><code>eval-source-map</code></strong></td><td align="left"><strong>build</strong>: slowest <strong>rebuild</strong>: ok</td><td align="left">no</td><td align="left">original</td><td align="left">Recommended choice for development builds with high quality SourceMaps.</td></tr><tr><td align="left"><code>cheap-source-map</code></td><td align="left"><strong>build</strong>: ok <strong>rebuild</strong>: slow</td><td align="left">no</td><td align="left">transformed</td><td align="left"></td></tr><tr><td align="left"><code>cheap-module-source-map</code></td><td align="left"><strong>build</strong>: slow <strong>rebuild</strong>: slow</td><td align="left">no</td><td align="left">original lines</td><td align="left"></td></tr><tr><td align="left"><strong><code>source-map</code></strong></td><td align="left"><strong>build</strong>: slowest <strong>rebuild</strong>: slowest</td><td align="left">yes</td><td align="left">original</td><td align="left">Recommended choice for production builds with high quality SourceMaps.</td></tr><tr><td align="left"><code>inline-cheap-source-map</code></td><td align="left"><strong>build</strong>: ok <strong>rebuild</strong>: slow</td><td align="left">no</td><td align="left">transformed</td><td align="left"></td></tr><tr><td align="left"><code>inline-cheap-module-source-map</code></td><td align="left"><strong>build</strong>: slow <strong>rebuild</strong>: slow</td><td align="left">no</td><td align="left">original lines</td><td align="left"></td></tr><tr><td align="left"><code>inline-source-map</code></td><td align="left"><strong>build</strong>: slowest <strong>rebuild</strong>: slowest</td><td align="left">no</td><td align="left">original</td><td align="left">Possible choice when publishing a single file</td></tr><tr><td align="left"><code>eval-nosources-cheap-source-map</code></td><td align="left"><strong>build</strong>: ok <strong>rebuild</strong>: fast</td><td align="left">no</td><td align="left">transformed</td><td align="left">source code not included</td></tr><tr><td align="left"><code>eval-nosources-cheap-module-source-map</code></td><td align="left"><strong>build</strong>: slow <strong>rebuild</strong>: fast</td><td align="left">no</td><td align="left">original lines</td><td align="left">source code not included</td></tr><tr><td align="left"><code>eval-nosources-source-map</code></td><td align="left"><strong>build</strong>: slowest <strong>rebuild</strong>: ok</td><td align="left">no</td><td align="left">original</td><td align="left">source code not included</td></tr><tr><td align="left"><code>inline-nosources-cheap-source-map</code></td><td align="left"><strong>build</strong>: ok <strong>rebuild</strong>: slow</td><td align="left">no</td><td align="left">transformed</td><td align="left">source code not included</td></tr><tr><td align="left"><code>inline-nosources-cheap-module-source-map</code></td><td align="left"><strong>build</strong>: slow <strong>rebuild</strong>: slow</td><td align="left">no</td><td align="left">original lines</td><td align="left">source code not included</td></tr><tr><td align="left"><code>inline-nosources-source-map</code></td><td align="left"><strong>build</strong>: slowest <strong>rebuild</strong>: slowest</td><td align="left">no</td><td align="left">original</td><td align="left">source code not included</td></tr><tr><td align="left"><code>nosources-cheap-source-map</code></td><td align="left"><strong>build</strong>: ok <strong>rebuild</strong>: slow</td><td align="left">no</td><td align="left">transformed</td><td align="left">source code not included</td></tr><tr><td align="left"><code>nosources-cheap-module-source-map</code></td><td align="left"><strong>build</strong>: slow <strong>rebuild</strong>: slow</td><td align="left">no</td><td align="left">original lines</td><td align="left">source code not included</td></tr><tr><td align="left"><code>nosources-source-map</code></td><td align="left"><strong>build</strong>: slowest <strong>rebuild</strong>: slowest</td><td align="left">yes</td><td align="left">original</td><td align="left">source code not included</td></tr><tr><td align="left"><code>hidden-nosources-cheap-source-map</code></td><td align="left"><strong>build</strong>: ok <strong>rebuild</strong>: slow</td><td align="left">no</td><td align="left">transformed</td><td align="left">no reference, source code not included</td></tr><tr><td align="left"><code>hidden-nosources-cheap-module-source-map</code></td><td align="left"><strong>build</strong>: slow <strong>rebuild</strong>: slow</td><td align="left">no</td><td align="left">original lines</td><td align="left">no reference, source code not included</td></tr><tr><td align="left"><code>hidden-nosources-source-map</code></td><td align="left"><strong>build</strong>: slowest <strong>rebuild</strong>: slowest</td><td align="left">yes</td><td align="left">original</td><td align="left">no reference, source code not included</td></tr><tr><td align="left"><code>hidden-cheap-source-map</code></td><td align="left"><strong>build</strong>: ok <strong>rebuild</strong>: slow</td><td align="left">no</td><td align="left">transformed</td><td align="left">no reference</td></tr><tr><td align="left"><code>hidden-cheap-module-source-map</code></td><td align="left"><strong>build</strong>: slow <strong>rebuild</strong>: slow</td><td align="left">no</td><td align="left">original lines</td><td align="left">no reference</td></tr><tr><td align="left"><code>hidden-source-map</code></td><td align="left"><strong>build</strong>: slowest <strong>rebuild</strong>: slowest</td><td align="left">yes</td><td align="left">original</td><td align="left">no reference. Possible choice when using SourceMap only for error reporting purposes.</td></tr></tbody></table><h3 id="本次使用过的配置代码展示"><a href="#本次使用过的配置代码展示" class="headerlink" title="本次使用过的配置代码展示"></a>本次使用过的配置代码展示</h3><h4 id="plugin-以前的配置"><a href="#plugin-以前的配置" class="headerlink" title="plugin 以前的配置"></a>plugin 以前的配置</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  entry<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"./src/index.js"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  output<span class="token operator">:</span> <span class="token punctuation">{</span>    path<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"./build"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    filename<span class="token operator">:</span> <span class="token string">"bundle.js"</span><span class="token punctuation">,</span>    <span class="token comment">// 使用asset打包的图片不转为base64格式的时候，图片存放的位置以及名称</span>    <span class="token comment">// assetModuleFilename: 'image/[name]-[hash:6][ext]'</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  module<span class="token operator">:</span> <span class="token punctuation">{</span>    rules<span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        use<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"style-loader"</span><span class="token punctuation">,</span> <span class="token string">"css-loader"</span><span class="token punctuation">,</span> <span class="token string">"postcss-loader"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.less$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        use<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"style-loader"</span><span class="token punctuation">,</span> <span class="token string">"css-loader"</span><span class="token punctuation">,</span> <span class="token string">"postcss-loader"</span><span class="token punctuation">,</span> <span class="token string">"less-loader"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token comment">// 配置打包图片资源的规则</span>      <span class="token comment">// {</span>      <span class="token comment">//   test: /\.(jpg|png|jpeg|JPG)$/,</span>      <span class="token comment">//   use: 'file-loader'</span>      <span class="token comment">// }</span>      <span class="token comment">/* {        test: /\.(jpg|png|jpeg|JPG)$/,        use: {          loader: 'file-loader',          // file-loader的参数配置          options: {            // 打包后图片文件所在的路径            // outputPath: 'image',            // 打包后生成文件的名称            // [name] 源文件的名称（不含拓展名）            // 我们发现不写配置时，文件的名称过长（且文件名是通过hash算法算出来的，为了防止重名）            // [hash:6] 默认生成文件名称的hash算法，32位，取前六位            // [ext] 使用原来文件的拓展名            // name: '[name]_[hash:6].[ext]'            // 当然：我们也可以把图片存放的路径和图片名称合在一起            name: 'image/[name]-[hash:6].[ext]'          }        }      } , */</span>      <span class="token comment">// 注意： 使用file-loader就不要使用url-loader</span>      <span class="token comment">// 使用url-loader也不需要使用file-loader</span>      <span class="token comment">// 配置url-loader 设置图片大小的限制，小于某个范围的图片转为base64格式</span>      <span class="token comment">// {</span>      <span class="token comment">//   test: /\.(jpe?g|JPG|png)$/,</span>      <span class="token comment">//   use: {</span>      <span class="token comment">//     loader: 'url-loader',</span>      <span class="token comment">//     options: {</span>      <span class="token comment">//       name: 'image/[name]-[hash:6].[ext]',</span>      <span class="token comment">//       // 设置图片大小的限制，只有小于多少kb的图片我们才会转为base64格式</span>      <span class="token comment">//       // 如果大于这个限制 我们就不会转为base64格式。而是继续采用上面的path和name的形式打包，还是保持图片的形式不变</span>      <span class="token comment">//       limit: 100 * 1024 // 小于100kb的文件才会转为base64格式</span>      <span class="token comment">//     }</span>      <span class="token comment">//   }</span>      <span class="token comment">// }</span>      <span class="token comment">// webpack5开始 可以不在使用file-loader和url-loader来进行打包图片了</span>      <span class="token comment">// 我们直接使用 asset module type 资源模块类型 来替换上面loader</span>      <span class="token comment">// 注意：asset是webpack5自带的</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(JPG|jpe?g|png)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        <span class="token comment">// 这里不在使用use属性 而是type属性</span>        <span class="token comment">// 使用asset/resource 来代替 file-loader</span>        <span class="token comment">// type:'asset/resource'</span>        <span class="token comment">// 比较常用的我们一般直接写成 asset</span>        type<span class="token operator">:</span> <span class="token string">"asset"</span><span class="token punctuation">,</span>        <span class="token comment">// 配置相关的asset参数 使用parser属性</span>        parser<span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token comment">// 数据url条件</span>          dataUrlCondition<span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token comment">// 最大不超过多少kb的图片 我们转为 base64格式</span>            maxSize<span class="token operator">:</span> <span class="token number">100</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment">// 下面的配置也可以放在 output里面（了解）</span>        <span class="token comment">// generator属性 生成 也就是打包后的图片存放时相关的配置</span>        generator<span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token comment">// 配置图片名称和图片位置</span>          <span class="token comment">// 这里的 [ext] 拿到的文件拓展名包含 .</span>          filename<span class="token operator">:</span> <span class="token string">"image/[name]-[hash:6][ext]"</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token comment">// 配置字体和字体图标等文件打包时的规则</span>      <span class="token comment">// {</span>      <span class="token comment">//   test: /\.(eot|ttf|woff2?)$/,</span>      <span class="token comment">//   use:{</span>      <span class="token comment">//     loader: 'file-loader',</span>      <span class="token comment">//     options:{</span>      <span class="token comment">//       // 这里是name属性 不是filename</span>      <span class="token comment">//       name: 'font/[name]-[hash:6].[ext]'</span>      <span class="token comment">//     }</span>      <span class="token comment">//   }</span>      <span class="token comment">// },</span>      <span class="token comment">// 也可以使用webpack提供的资源模块类型</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(eot|ttf|woff2?)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        type<span class="token operator">:</span> <span class="token string">"asset/resource"</span><span class="token punctuation">,</span>        generator<span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token comment">// 这里使用的是filename属性 别忘了！！！！！</span>          filename<span class="token operator">:</span> <span class="token string">"font/[name]-[hash:6][ext]"</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="plugin-开始及以后的配置"><a href="#plugin-开始及以后的配置" class="headerlink" title="plugin 开始及以后的配置"></a>plugin 开始及以后的配置</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 注意：所有的插件都需要导入的，loader不需要</span><span class="token comment">// 导入 clean-webpack-plugin 插件</span><span class="token comment">// 该插件导出的是一个对象，我们需要从对象里面按需获取 CleanWebpackPlugin 这个类</span><span class="token keyword">const</span> <span class="token punctuation">{</span> CleanWebpackPlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"clean-webpack-plugin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 导入 html-webpack-plugin插件 这个插件导出的就是一个类 不需要解构</span><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"html-webpack-plugin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 导入 DefinePlugin 插件 解决常量 BASE_URL 的问题</span><span class="token keyword">const</span> <span class="token punctuation">{</span> DefinePlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"webpack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 导入 CopyWebpackPlugin 插件 该插件导出的也是一个类</span><span class="token comment">// 用来完成文件的复制工作</span><span class="token keyword">const</span> CopyWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"copy-webpack-plugin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment">// 模式配置 mode</span>  <span class="token comment">// development 生产模式 打包的代码不会压缩 易于阅读</span>  mode<span class="token operator">:</span> <span class="token string">"development"</span><span class="token punctuation">,</span>  <span class="token comment">// 开发模式 代码会被压缩 减小体积</span>  <span class="token comment">// mode:"production",</span>  <span class="token comment">// devtool 属性 ：设置开发时的工具 默认值是 eval</span>  <span class="token comment">// 默认会使用 eval函数对源代码进行包裹</span>  <span class="token comment">// devtool: 'eval',</span>  <span class="token comment">// 如果想查看源码：可以设置值为 source-map</span>  <span class="token comment">// 设置为这个属性 会生成对应的打包后的代码和源码映射的文件</span>  <span class="token comment">// 出现错误可以映射到我们书写的源代码</span>  devtool<span class="token operator">:</span> <span class="token string">"source-map"</span><span class="token punctuation">,</span>  <span class="token comment">// 提供 plugins属性来配置插件</span>  <span class="token comment">// plugins属性是数组，数组元素是一个个的插件对象</span>  <span class="token comment">// 插件是书写没有先后顺序！！！！！！！！！！</span>  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token comment">// 使用 CleanWebpackPlugin 插件对象</span>    <span class="token comment">// 因为 CleanWebpackPlugin 是一个class类，我们需要 new 实例化成对象</span>    <span class="token comment">// CleanWebpackPlugin 插件会删除我们生成的打包后的那么文件夹，然后重新打包</span>    <span class="token keyword">new</span> <span class="token class-name">CleanWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// 使用 HtmlWebpackPlugin 插件</span>    <span class="token comment">// new HtmlWebpackPlugin(),</span>    <span class="token comment">// 使用 HtmlWebpackPlugin 插件 并指定html的模板</span>    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      <span class="token comment">// 按照这个html文件的模板来进行打包，生成的index.html和这个模板一样</span>      template<span class="token operator">:</span> <span class="token string">"./public/index.html"</span><span class="token punctuation">,</span>      title<span class="token operator">:</span> <span class="token string">"webpack-plugin 的学习"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// 使用 DefinePlugin 插件来定义 常量</span>    <span class="token keyword">new</span> <span class="token class-name">DefinePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      <span class="token comment">// BASE_URL 会根据后面给的属性值 去本文件上下文中找这个变量</span>      <span class="token comment">// 比如我这里给的是字符串 "filepath"</span>      <span class="token comment">// 也会去上下文中找叫做 filepath 的变量</span>      <span class="token comment">// 如果我们想直接给一个字符串的值</span>      <span class="token comment">// 我们需要在双引号里面嵌套单引号赋值</span>      <span class="token comment">// 当然 单引号里面嵌套双引号赋值也是可以的</span>      <span class="token comment">// BASE_URL: "filepath",</span>      <span class="token constant">BASE_URL</span><span class="token operator">:</span> <span class="token string">"'./'"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// 使用 CopyWebpackPlugin 插件</span>    <span class="token keyword">new</span> <span class="token class-name">CopyWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      <span class="token comment">// patterns属性： 匹配规则 数组</span>      patterns<span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>          <span class="token comment">// 复制的来源</span>          from<span class="token operator">:</span> <span class="token string">"public"</span><span class="token punctuation">,</span>          <span class="token comment">// 复制后放到哪里</span>          <span class="token comment">// 不写，或者给空字符串 最后都是把拷贝的文件放在打包后的根目录下</span>          to<span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>          <span class="token comment">// 全局配置  globOptions</span>          globOptions<span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token comment">// 忽略那些文件</span>            <span class="token comment">// ignore: ['**/index.html'],</span>            <span class="token comment">// 只有一个忽略的规则时 可以直接写一个字符串</span>            ignore<span class="token operator">:</span> <span class="token string">"**/index.html"</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  entry<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"./src/index.js"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  output<span class="token operator">:</span> <span class="token punctuation">{</span>    path<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"./build"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    filename<span class="token operator">:</span> <span class="token string">"bundle.js"</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  module<span class="token operator">:</span> <span class="token punctuation">{</span>    rules<span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        use<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"style-loader"</span><span class="token punctuation">,</span> <span class="token string">"css-loader"</span><span class="token punctuation">,</span> <span class="token string">"postcss-loader"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.less$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        use<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"style-loader"</span><span class="token punctuation">,</span> <span class="token string">"css-loader"</span><span class="token punctuation">,</span> <span class="token string">"postcss-loader"</span><span class="token punctuation">,</span> <span class="token string">"less-loader"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token comment">// webpack5开始 可以不在使用file-loader和url-loader来进行打包图片了</span>      <span class="token comment">// 我们直接使用 asset module type 资源模块类型 来替换上面loader</span>      <span class="token comment">// 注意：asset是webpack5自带的</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(JPG|jpe?g|png)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        <span class="token comment">// 这里不在使用use属性 而是type属性</span>        <span class="token comment">// 使用asset/resource 来代替 file-loader</span>        <span class="token comment">// type:'asset/resource'</span>        <span class="token comment">// 比较常用的我们一般直接写成 asset</span>        type<span class="token operator">:</span> <span class="token string">"asset"</span><span class="token punctuation">,</span>        <span class="token comment">// 配置相关的asset参数 使用parser属性</span>        parser<span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token comment">// 数据url条件</span>          dataUrlCondition<span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token comment">// 最大不超过多少kb的图片 我们转为 base64格式</span>            maxSize<span class="token operator">:</span> <span class="token number">100</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment">// 下面的配置也可以放在 output里面（了解）</span>        <span class="token comment">// generator属性 生成 也就是打包后的图片存放时相关的配置</span>        generator<span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token comment">// 配置图片名称和图片位置</span>          <span class="token comment">// 这里的 [ext] 拿到的文件拓展名包含 .</span>          filename<span class="token operator">:</span> <span class="token string">"image/[name]-[hash:6][ext]"</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token comment">// 也可以使用webpack提供的资源模块类型</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(eot|ttf|woff2?)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        type<span class="token operator">:</span> <span class="token string">"asset/resource"</span><span class="token punctuation">,</span>        generator<span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token comment">// 这里使用的是filename属性 别忘了！！！！！</span>          filename<span class="token operator">:</span> <span class="token string">"font/[name]-[hash:6][ext]"</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Babel-和-Vue-的-sfc"><a href="#Babel-和-Vue-的-sfc" class="headerlink" title="Babel 和 Vue 的 sfc"></a>Babel 和 Vue 的 sfc</h2><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><h4 id="为什么需要-babel？"><a href="#为什么需要-babel？" class="headerlink" title="为什么需要 babel？"></a>为什么需要 babel？</h4><p>事实上，在开发中我们很少<strong>直接去接触 babel</strong>，但是 babel 对于前端开发来说，目前是不可缺少的一部分：</p><ol><li>开发中，我们想要使用<strong>ES6+<strong>的语法，想要使用</strong>TypeScrip</strong>t，开发<strong>React</strong>项目，它们都是离不开 Babel 的；</li><li>所以，<strong>学习 Babel</strong>对于我们理解代码从编写到线上的转变过程至关重要；</li></ol><p><strong>那么，Babel 到底是什么呢？</strong></p><p>Babel 是一个<strong>工具链</strong>，主要用于旧浏览器或者环境中将 ECMAScript 2015+代码转换为向后兼容版本的 JavaScript；</p><p><strong>包括：语法转换、源代码转换等；</strong></p><h4 id="Babel-命令行使用"><a href="#Babel-命令行使用" class="headerlink" title="Babel 命令行使用"></a>Babel 命令行使用</h4><p>babel 本身可以作为一个<strong>独立的工具</strong>（和 postcss 一样），不和 webpack 等构建工具配置来单独使用。</p><p>如果我们希望在命令行尝试使用 babel，需要安装如下库：</p><ul><li>@babel/core：babel 的核心代码，必须安装；</li><li>@babel/cli：可以让我们在命令行使用 babel；</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i @babel/core @babel/cli -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>使用 babel 来处理我们的源代码：</strong></p><ul><li>src：是源文件的目录；也可以直接指定文件</li><li>–out-dir：指定要输出的文件夹 dist；</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npx babel src --out-dir dict<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="插件的使用"><a href="#插件的使用" class="headerlink" title="插件的使用"></a>插件的使用</h4><p>比如我们需要转换<strong>箭头函数</strong>，那么我们就可以使用箭头函数转换相关的插件：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install @babel/plugin-transform-arrow-functions -Dnpx babel src --out-dir dist --plugins=@babel/plugin-transform-arrow-functions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210731084446775.png" alt="image-20210731084446775"></p><p><strong>源代码：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">"毛毛"</span><span class="token punctuation">;</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr<span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>目标代码：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">"毛毛"</span><span class="token punctuation">;</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr<span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210731084619271.png" alt="image-20210731084619271"></p><p>查看转换后的结果：我们会发现 <strong>const</strong> 并没有转成 <strong>var</strong></p><ul><li>这是因为 plugin-transform-arrow-functions，并没有提供这样的功能；</li><li>我们需要使用 plugin-transform-block-scoping 来完成这样的功能；</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install @babel/plugin-transform-block-scoping -Dnpx babel src --out-dir dist --plugins=@babel/plugin-transform-block-scoping,@babel/plugin-transform-arrow-functions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210731084842846.png" alt="image-20210731084842846"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210731084854742.png" alt="image-20210731084854742"></p><h4 id="Babel-的预设-preset"><a href="#Babel-的预设-preset" class="headerlink" title="Babel 的预设 preset"></a>Babel 的预设 preset</h4><p>但是如果要转换的内容过多，一个个设置是比较麻烦的，我们可以使用预设（preset）：<strong>后面我们再具体来讲预设代表的含义；</strong></p><p>安装@babel/preset-env 预设：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install @babel/preset-env -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>执行如下命令：</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npx babel src --out-dir dist --presets=@babel/preset-env<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210731085152844.png" alt="image-20210731085152844"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210731085201827.png" alt="image-20210731085201827"></p><h4 id="Babel-的底层原理"><a href="#Babel-的底层原理" class="headerlink" title="Babel 的底层原理"></a>Babel 的底层原理</h4><p>babel 是如何做到将我们的一段代码（<strong>ES6、TypeScript、Reac</strong>t）转成另外一段代码（ES5）的呢？</p><p>从一种源代码（原生语言）转换成另一种源代码（目标语言），这是什么的工作呢？</p><p><strong>就是编译器，事实上我们可以将 babel 看成就是一个编译器</strong>；Babel 编译器的作用就是将我们的源代码，转换成浏览器可以直接识别的另外一段源代码；</p><p><strong>Babel 也拥有编译器的工作流程：</strong></p><ol><li>解析阶段（Parsing）</li><li>转换阶段（Transformation）</li><li>生成阶段（Code Generation）</li></ol><h4 id="Babel-编译器执行原理"><a href="#Babel-编译器执行原理" class="headerlink" title="Babel 编译器执行原理"></a>Babel 编译器执行原理</h4><h5 id="Babel-的执行阶段"><a href="#Babel-的执行阶段" class="headerlink" title="Babel 的执行阶段"></a>Babel 的执行阶段</h5><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210731085400687.png" alt="image-20210731085400687"></p><p><strong>当然，这只是一个简化版的编译器工具流程，在每个阶段又会有自己具体的工作：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210731085426851.png" alt="image-20210731085426851"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210731085436745.png" alt="image-20210731085436745"></p><h4 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h4><p>在实际开发中，我们通常会在构建工具中通过配置 babel 来对其进行使用的，比如在 webpack 中</p><p>那么我们就需要去安装相关的依赖：如果之前已经安装了@babel/core，那么这里不需要再次安装；</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install babel-loader @babel/core -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以设置一个规则，在加载 js 文件时，使用我们的 babel：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210731094048189.png" alt="image-20210731094048189"></p><h5 id="指定使用的插件"><a href="#指定使用的插件" class="headerlink" title="指定使用的插件"></a>指定使用的插件</h5><p>我们必须指定使用的插件才会生效:</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210731094141175.png" alt="image-20210731094141175"></p><h5 id="babel-preset"><a href="#babel-preset" class="headerlink" title="babel-preset"></a>babel-preset</h5><p>如果我们一个个去安装使用插件，那么需要手动来管理大量的 babel 插件，我们可以直接给 webpack 提供一个 preset，webpack 会根据我们的预设来加载对应的插件列表，并且将其传递给 babel</p><p><strong>比如常见的预设有三个：</strong></p><ol><li>env</li><li>react</li><li>TypeScript</li></ol><p><strong>安装 preset-env：</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install @babel/preset-env<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210731094336858.png" alt="image-20210731094336858"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 对js代码进行转换</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.js$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        use<span class="token operator">:</span> <span class="token punctuation">{</span>          loader<span class="token operator">:</span> <span class="token string">"babel-loader"</span><span class="token punctuation">,</span>          <span class="token comment">// loader的选项</span>          options<span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token comment">// 使用babel-loader的时候，babel需要的插件</span>            plugins<span class="token operator">:</span><span class="token punctuation">[</span>              <span class="token string">"@babel/plugin-transform-arrow-functions"</span><span class="token punctuation">,</span>              <span class="token string">"@babel/plugin-transform-block-scoping"</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token comment">// 使用预设</span>            presets<span class="token operator">:</span><span class="token punctuation">[</span>              <span class="token comment">// 没有参数直接这样写预设，</span>              <span class="token string">"@babel/preset-env"</span><span class="token punctuation">,</span>              <span class="token comment">// 有参数时：</span>              <span class="token punctuation">[</span><span class="token string">"@babel/preset-env"</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>            <span class="token punctuation">]</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Babel-的配置文件"><a href="#Babel-的配置文件" class="headerlink" title="Babel 的配置文件"></a>Babel 的配置文件</h5><p>像之前一样，我们可以将 babel 的配置信息放到一个独立的文件中，babel 给我们提供了两种配置文件的编写：</p><ol><li>babel.config.json（或者.js，.cjs，.mjs）文件；</li><li>.babelrc.json（或者.babelrc，.js，.cjs，.mjs）文件；</li></ol><p>它们两个有什么区别呢？目前很多的项目都采用了多包管理的方式（babel 本身、element-plus、umi 等）；</p><ul><li>.babelrc.json：早期使用较多的配置方式，但是对于配置 Monorepos 项目是比较麻烦的；</li><li>babel.config.json（babel7）：可以直接作用于 Monorepos 项目的子包，更加推荐；</li></ul><p><strong>我这里采取的 babel.config.js 的方式</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// babel 配置文件</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  presets<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"@babel/preset-env"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment">// plugins:[]</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><h4 id="Vue-源码的打包"><a href="#Vue-源码的打包" class="headerlink" title="Vue 源码的打包"></a>Vue 源码的打包</h4><p>我们主要是学习 Vue 的，那么我们应该包含 Vue 相关的代码：</p><p><strong>安装 vue</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i vue@next # 安装的是vue3，且是生产依赖<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>书写使用 vue 的代码</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 使用vue</span><span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  template<span class="token operator">:</span> <span class="token string">"&lt;h2&gt;我是vue渲染出来的！&lt;/h2&gt;"</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      title<span class="token operator">:</span> <span class="token string">"啊哈哈！"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">"#app"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用 webpack 进行打包</strong></p><p>发现：<strong>界面上是没有效果的：</strong></p><p>并且我们查看运行的控制台，会发现如下的警告信息；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210731095804576.png" alt="image-20210731095804576"></p><h4 id="Vue-打包后不同版本解析"><a href="#Vue-打包后不同版本解析" class="headerlink" title="Vue 打包后不同版本解析"></a>Vue 打包后不同版本解析</h4><h5 id="vue-runtime-global-prod-js："><a href="#vue-runtime-global-prod-js：" class="headerlink" title="vue(.runtime).global(.prod).js："></a><strong>vue(.runtime).global(.prod).js：</strong></h5><ol><li>通过浏览器中的 <code>&lt;srcipt src="..."&gt;</code>直接引入</li><li>我们之前通过 CDN 引入和下载的 Vue 版本就是这个版本；</li><li>会暴露一个全局的 Vue 来使用；</li></ol><h5 id="vue-runtime-esm-browser-prod-js："><a href="#vue-runtime-esm-browser-prod-js：" class="headerlink" title="vue(.runtime).esm-browser(.prod).js："></a>vue(.runtime).esm-browser(.prod).js：</h5><p>用于通过原生 ES 模块导入使用 (在浏览器中通过</p><h5 id="vue-runtime-esm-bundler-js："><a href="#vue-runtime-esm-bundler-js：" class="headerlink" title="vue(.runtime).esm-bundler.js："></a>vue(.runtime).esm-bundler.js：</h5><ol><li>用于 <strong>webpack，rollup 和 parcel</strong> 等构建工具；</li><li>构建工具中默认是<strong>vue.runtime.esm-bundler.js</strong>；</li><li>如果我们需要解析模板 template，那么需要手动指定 vue.esm-bundler.js；</li></ol><h5 id="vue-cjs-prod-js："><a href="#vue-cjs-prod-js：" class="headerlink" title="vue.cjs(.prod).js："></a>vue.cjs(.prod).js：</h5><ol><li>服务器端渲染使用；</li><li>通过 require()在 Node.js 中使用；</li></ol><h4 id="运行时-编译器-vs-仅运行时"><a href="#运行时-编译器-vs-仅运行时" class="headerlink" title="运行时+编译器 vs 仅运行时"></a>运行时+编译器 vs 仅运行时</h4><p>在 Vue 的开发过程中我们有三种方式来编写 DOM 元素：</p><ul><li>方式一：template 模板的方式（之前经常使用的方式）；</li><li>方式二：render 函数的方式，使用 h 函数来编写渲染的内容；</li><li>方式三：通过.vue 文件中的 template 来编写模板；</li></ul><p>它们的模板分别是如何处理的呢？</p><p><strong>方式二</strong>中的 h 函数可以直接返回一个虚拟节点，也就是 Vnode 节点；</p><p><strong>方式一和方式三</strong>的 template 都需要有<strong>特定的代码</strong>来对其进行解析：</p><ul><li>方式三.vue 文件中的 template 可以通过在 vue-loader 对其进行编译和处理；</li><li>方式一种的 template 我们必须要通过源码中一部分代码来进行编译；</li></ul><p>所以，Vue 在让我们选择版本的时候分为 <strong>运行时+编译器 vs 仅运行时</strong></p><ol><li>运行时+编译器包含了对 template 模板的编译代码，更加完整，但是也更大一些；</li><li>仅运行时没有包含对 template 版本的编译代码，相对更小一些；</li></ol><p><strong>所以我们引入 vue3 应使用如下方式：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue/dist/vue.esm-bundler"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210731102206823.png" alt="image-20210731102206823"></p><h4 id="全局标识的配置"><a href="#全局标识的配置" class="headerlink" title="全局标识的配置"></a>全局标识的配置</h4><p><strong>我们会发现控制台还有另外的一个警告：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210731101951525.png" alt="image-20210731101951525"></p><p>在 GitHub 上的文档中我们可以找到说明：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210731102019738.png" alt="image-20210731102019738"></p><p>这是两个特性的标识，一个是使用 Vue 的 Options，一个是 Production 模式下是否支持 devtools 工具；</p><p>虽然他们都有默认值，但是强烈建议我们手动对他们进行配置；</p><p><strong>可以使用 DefinePlugin 插件配置这两个常量</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">DefinePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token constant">BASE_URL</span><span class="token operator">:</span> <span class="token string">"'./'"</span><span class="token punctuation">,</span>  __VUE_OPTIONS_API__<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  __VUE_PROD_DEVTOOLS__<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="编写-App-vue-代码"><a href="#编写-App-vue-代码" class="headerlink" title="编写 App.vue 代码"></a>编写 App.vue 代码</h4><p>在前面我们提到过，真实开发中多数情况下我们都是使用<strong>SFC（ single-file components (单文件组件) ）</strong>。</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template lang=""&gt;  &lt;h2&gt;你好 vue3 哈哈哈哈 sfc&lt;/h2&gt;  &lt;h3&gt;{{ message }}&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;export default {  data() {    return {      message: "哈哈",    };  },};&lt;/script&gt;&lt;style scoped&gt;h2,h3 {  color: aquamarine;}&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 使用 .vue单文件组件的方式</span><span class="token comment">// 可以直接导入vue就可以了。不需要上面的那种导入方式，来解决template模板的解析问题</span><span class="token comment">// 因为现在已经没有template了。而vue文件里面的template会被vue-loader解析</span><span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">"../vue/App.vue"</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">"#app"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="App-vue-的打包过程"><a href="#App-vue-的打包过程" class="headerlink" title="App.vue 的打包过程"></a>App.vue 的打包过程</h5><p>我们对代码打包会报错：提示我们需要合适的 Loader 来处理文件。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210731110600146.png" alt="image-20210731110600146"></p><p><strong>这个时候我们需要使用 vue-loader：</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install vue-loader@next -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>在 webpack 的模板规则中进行配置：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210731110659522.png" alt="image-20210731110659522"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 配置 .vue文件的加载打包规则</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.vue$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        loader<span class="token operator">:</span> <span class="token string">"vue-loader"</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="vue-compiler-sfc"><a href="#vue-compiler-sfc" class="headerlink" title="@vue/compiler-sfc"></a>@vue/compiler-sfc</h5><p>打包依然会报错，这是因为我们必须添加**@vue/compiler-sfc**来对 template 进行解析：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install @vue/compiler-sfc -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外我们需要配置对应的 Vue 插件：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 引入Vue-loader的插件 帮助loader做一些事情</span><span class="token keyword">const</span> <span class="token punctuation">{</span> VueLoaderPlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"vue-loader/dist/index"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">VueLoaderPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>重新打包即可支持 App.vue 的写法</strong></p><p>另外，我们也可以编写其他的.vue 文件来编写自己的组件；</p><h2 id="webpack-devServer-和-Vue-CLI"><a href="#webpack-devServer-和-Vue-CLI" class="headerlink" title="webpack-devServer 和 Vue-CLI"></a>webpack-devServer 和 Vue-CLI</h2><h3 id="devServer-热部署"><a href="#devServer-热部署" class="headerlink" title="devServer(热部署)"></a>devServer(热部署)</h3><p><strong>目前我们开发的代码，为了运行需要有两个操作：</strong></p><p><strong>操作一</strong>：npm run build，编译相关的代码；</p><p><strong>操作二</strong>：通过 live server 或者直接通过浏览器，打开 index.html 代码，查看效果；</p><p>这个过程经常操作会影响我们的开发效率，我们希望可以做到，当文件发生变化时，可以自动的完成 <strong>编译 和 展示</strong>；</p><p><strong>为了完成自动编译，webpack 提供了几种可选的方式：</strong></p><ol><li>webpack watch mode；</li><li>webpack-dev-server（常用）；</li><li>webpack-dev-middleware；</li></ol><h4 id="Webpack-watch"><a href="#Webpack-watch" class="headerlink" title="Webpack watch"></a>Webpack watch</h4><p>webpack 给我们提供了<strong>watch 模式</strong>：</p><ol><li>在该模式下，webpack 依赖图中的所有文件，只要有一个发生了更新，那么代码将被重新编译；</li><li>我们不需要手动去运行 <strong>npm run build</strong>指令了；</li></ol><h5 id="如何开启-watch-呢？两种方式："><a href="#如何开启-watch-呢？两种方式：" class="headerlink" title="如何开启 watch 呢？两种方式："></a><strong>如何开启 watch 呢？两种方式：</strong></h5><p>方式一：在导出的配置中，添加 watch: true；</p><p>方式二：在启动 webpack 的命令中，添加 <strong>–watch 的标识</strong>；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210802172245108.png" alt="image-20210802172245108"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210802172200638.png" alt="image-20210802172200638"></p><p><strong>方式二</strong>是在 package.json 的 scripts 中添加一个 watch 的脚本。</p><h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p>上面的方式可以监听到文件的变化，但是事实上它本身是没有自动刷新浏览器的功能的：</p><ol><li>当然，目前我们可以在 VSCode 中使用<strong>live-server</strong>来完成这样的功能；</li><li>但是，我们希望在不使用 live-server 的情况下，可以具备<strong>live reloading</strong>（<strong>实时重新加载</strong>）的功能；</li></ol><p><strong>安装 webpack-dev-server</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i webpack-dev-server -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改配置文件，告知 dev server，从什么位置查找文件：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment">// 其他配置均省略</span>  <span class="token comment">// 热部署（热更新）的配置</span>  devServer<span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token comment">// 如果需要的资源没有在webpack里面加载到，会去contentBase指定的文件夹里面寻找</span>    contentBase<span class="token operator">:</span> <span class="token string">"./public"</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 打包的是node环境 还是 web 环境</span>  target<span class="token operator">:</span> <span class="token string">"web"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210802172713684.png" alt="image-20210802172713684"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210802172725403.png" alt="image-20210802172725403"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210802172828915.png" alt="image-20210802172828915"></p><h4 id="认识模块热替换"><a href="#认识模块热替换" class="headerlink" title="认识模块热替换"></a>认识模块热替换</h4><p><strong>什么是 HMR 呢？</strong></p><ol><li>HMR 的全称是 Hot Module Replacement，翻译为模块热替换；</li><li>模块热替换是指在 应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个页面；</li></ol><p><strong>HMR 通过如下几种方式，来提高开发的速度：</strong></p><ol><li>不重新加载整个页面，这样可以保留某些应用程序的状态不丢失；</li><li>只更新需要变化的内容，节省开发的时间；</li><li>修改了 css、js 源代码，会立即在浏览器更新，相当于直接在浏览器的 devtools 中直接修改样式；</li></ol><p><strong>如何使用 HMR 呢？</strong></p><ol><li>默认情况下，webpack-dev-server 已经支持 HMR，我们只需要开启即可；</li><li>在不开启 HMR 的情况下，当我们修改了源代码之后，整个页面会自动刷新，使用的是 live reloading；</li></ol><h5 id="开启-HMR"><a href="#开启-HMR" class="headerlink" title="开启 HMR"></a>开启 HMR</h5><p><strong>修改 webpack 的配置：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210802173037587.png" alt="image-20210802173037587"></p><p><strong>浏览器可以看到如下效果：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210802173057967.png" alt="image-20210802173057967"></p><p>但是你会发现，当我们修改了某一个模块的代码时，依然是刷新的整个页面：</p><p>这是因为我们需要去<strong>指定哪些模块</strong>发生更新时，<strong>进行 HMR</strong>；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210802173232460.png" alt="image-20210802173232460"></p><h4 id="框架的-HMR"><a href="#框架的-HMR" class="headerlink" title="框架的 HMR"></a>框架的 HMR</h4><p><strong>有一个问题：在开发其他项目时，我们是否需要经常手动去写入 module.hot.accpet 相关的 API 呢？</strong></p><ol><li>比如开发 Vue、React 项目，我们修改了组件，希望进行热更新，这个时候应该如何去操作呢？</li><li>事实上社区已经针对这些有很成熟的解决方案了；</li><li>比如 vue 开发中，我们使用 vue-loader，此 loader 支持 vue 组件的 HMR，提供开箱即用的体验；</li><li>比如 react 开发中，有 React Hot Loader，实时调整 react 组件（目前 React 官方已经弃用了，改成使用 reactrefresh）；</li></ol><h4 id="HMR-的原理"><a href="#HMR-的原理" class="headerlink" title="HMR 的原理"></a>HMR 的原理</h4><p><strong>那么 HMR 的原理是什么呢？如何可以做到只更新一个模块中的内容呢？</strong></p><ol><li>webpack-dev-server 会创建两个服务：提供静态资源的服务（express）和 Socket 服务（net.Socket）；</li><li>express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）；</li></ol><p><strong>HMR Socket Server，是一个 socket 的长连接：</strong></p><ol><li>长连接有一个最好的好处是建立连接后双方可以通信（服务器可以直接发送文件到客户端）；</li><li>当服务器监听到对应的模块发生变化时，会生成两个文件.json（manifest 文件）和.js 文件（update chunk）；</li><li>通过长连接，可以直接将这两个文件主动发送给客户端（浏览器）；</li><li>浏览器拿到两个新的文件后，通过 HMR runtime 机制，加载这两个文件，并且针对修改的模块进行更新；</li></ol><h5 id="HMR-的原理图"><a href="#HMR-的原理图" class="headerlink" title="HMR 的原理图"></a>HMR 的原理图</h5><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210802173450624.png" alt="image-20210802173450624"></p><h5 id="hotOnly、host-配置"><a href="#hotOnly、host-配置" class="headerlink" title="hotOnly、host 配置"></a>hotOnly、host 配置</h5><h6 id="host-设置主机地址："><a href="#host-设置主机地址：" class="headerlink" title="host 设置主机地址："></a><strong>host 设置主机地址：</strong></h6><p>默认值是 localhost；如果希望其他地方也可以访问，可以设置为 0.0.0.0；</p><h6 id="localhost-和-0-0-0-0-的区别："><a href="#localhost-和-0-0-0-0-的区别：" class="headerlink" title="localhost 和 0.0.0.0 的区别："></a><strong>localhost 和 0.0.0.0 的区别</strong>：</h6><ol><li>localhost：本质上是一个域名，通常情况下会被解析成 127.0.0.1;</li><li>127.0.0.1：回环地址(Loop Back Address)，表达的意思其实是我们主机自己发出去的包，直接被自己接收;<ul><li>正常的数据库包经常 应用层 - 传输层 - 网络层 - 数据链路层 - 物理层 ;</li><li>而回环地址，是在网络层直接就被获取到了，是不会经常数据链路层和物理层的;</li><li>比如我们监听 127.0.0.1 时，在同一个网段下的主机中，通过 ip 地址是不能访问的;</li></ul></li><li>0.0.0.0：监听 IPV4 上所有的地址，再根据端口找到不同的应用程序；比如我们监听 0.0.0.0 时，在同一个网段下的主机中，通过 ip 地址是可以访问的;</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210802174005433.png" alt="image-20210802174005433"></p><h5 id="port、open、compress"><a href="#port、open、compress" class="headerlink" title="port、open、compress"></a>port、open、compress</h5><h6 id="prot"><a href="#prot" class="headerlink" title="prot"></a>prot</h6><p><strong>port 设置监听的端口，默认情况下是 8080</strong></p><h6 id="open"><a href="#open" class="headerlink" title="open"></a>open</h6><p><strong>open 是否打开浏览器：</strong></p><ol><li>默认值是 false，设置为 true 会打开浏览器；</li><li>也可以设置为类似于 Google Chrome 等值；</li></ol><h6 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h6><p><strong>compress 是否为静态文件开启 gzip compression：</strong></p><p>默认值是 false，可以设置为 true；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210802174040312.png" alt="image-20210802174040312"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210802174054174.png" alt="image-20210802174054174"></p><h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p><strong>proxy 是我们开发中非常常用的一个配置选项，它的目的设置代理来解决跨域访问的问题：</strong></p><p>比如我们的一个 api 请求是 <a href="http://localhost:8888，但是本地启动服务器的域名是">http://localhost:8888，但是本地启动服务器的域名是</a> <a href="http://localhost:8000，这">http://localhost:8000，这</a> 个时候发送网络请求就会出现跨域的问题；</p><p>那么我们可以将请求先发送到一个代理服务器，代理服务器和 API 服务器没有跨域的问题，就可以解决我们的跨 域问题了；</p><p><strong>我们可以进行如下的设置</strong></p><p><strong>target</strong>：表示的是代理到的目标地址，比如 /api-hy/moment 会被代理到 <a href="http://localhost:8888/api-mhy/moment">http://localhost:8888/api-mhy/moment</a></p><p><strong>pathRewrite</strong>：默认情况下，我们的 /api-hy 也会被写入到 URL 中，如果希望删除，可以使用 pathRewrite；</p><p><strong>secure</strong>：默认情况下不接收转发到 https 的服务器上，如果希望支持，可以设置为 false；</p><p><strong>changeOrigin</strong>：它表示是否更新代理后请求的 headers 中 host 地址</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210802174327012.png" alt="image-20210802174327012"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  devServer<span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token comment">// 配置 proxy 代理 解决跨域问题</span>    <span class="token comment">// 只适用于开发阶段</span>    <span class="token comment">// 相当于请求交给本地服务器发送给远程的服务器</span>    <span class="token comment">// 然后请求到的数据在给页面的请求</span>    proxy<span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token comment">// 配置映射关系</span>      <span class="token comment">// 相当于在项目中请求 /api地址 就是请求后面配置的地址</span>      <span class="token string">"/api"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        target<span class="token operator">:</span> <span class="token string">"http://www.baidu.com"</span><span class="token punctuation">,</span>        <span class="token comment">// 路径重写 将 /api开头的请求地址的 /api 给替换为 "" 空字符串</span>        pathRewrite<span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"^/api"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment">// 默认不支持 转发到https的服务器上，如果需要，设置 secure为false</span>        secure<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token comment">// 是否更新代理后请求的headers中的host地址</span>        changeOrigin<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="changeOrigin-的解析"><a href="#changeOrigin-的解析" class="headerlink" title="changeOrigin 的解析"></a>changeOrigin 的解析</h4><p>这个 changeOrigin 官方说的非常模糊，通过查看源码我发现其实是要修改代理请求中的 headers 中的 host 属性：</p><ol><li>因为我们真实的请求，其实是需要通过 <a href="http://localhost:8888/">http://localhost:8888</a> 来请求的；</li><li>但是因为使用了代码，默认情况下它的值时 <a href="http://localhost:8000；">http://localhost:8000；</a></li><li>如果我们需要修改，那么可以将 changeOrigin 设置为 true 即可；</li></ol><h3 id="resolve-模块解析"><a href="#resolve-模块解析" class="headerlink" title="resolve 模块解析"></a>resolve 模块解析</h3><p><strong>resolve 用于设置模块如何被解析：</strong></p><ol><li>在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库；</li><li>resolve 可以帮助 webpack 从每个 require/import 语句中，找到需要引入到合适的模块代码；</li><li>webpack 使用 enhanced-resolve 来解析文件路径；</li></ol><p><strong>webpack 能解析三种文件路径：</strong></p><p><strong>绝对路径</strong> :由于已经获得文件的绝对路径，因此不需要再做进一步解析。</p><p><strong>相对路径</strong></p><ol><li>在这种情况下，使用 import 或 require 的资源文件所处的目录，被认为是上下文目录；</li><li>在 import/require 中给定的相对路径，会拼接此上下文路径，来生成模块的绝对路径；</li></ol><p><strong>模块路径</strong></p><p>在 resolve.modules 中指定的所有目录检索模块；</p><ol><li>默认值是 [‘node_modules’]，所以默认会从 node_modules 中查找文件；</li><li>我们可以通过设置别名的方式来替换初识模块路径，具体后面讲解 alias 的配置；</li></ol><h5 id="确实文件还是文件夹"><a href="#确实文件还是文件夹" class="headerlink" title="确实文件还是文件夹"></a>确实文件还是文件夹</h5><p>如果是一个文件：</p><ol><li>如果文件具有扩展名，则直接打包文件；</li><li>否则，将使用 resolve.extensions 选项作为文件扩展名解析；</li></ol><p><strong>如果是一个文件夹：</strong></p><p>会在文件夹中根据 resolve.mainFiles 配置选项中指定的文件顺序查找；</p><ol><li>resolve.mainFiles 的默认值是 [‘index’]；</li><li>再根据 resolve.extensions 来解析扩展名</li></ol><h4 id="extensions-和-alias-配置"><a href="#extensions-和-alias-配置" class="headerlink" title="extensions 和 alias 配置"></a><strong>extensions 和 alias 配置</strong></h4><h5 id="extentions"><a href="#extentions" class="headerlink" title="extentions"></a>extentions</h5><p>extensions 是解析到文件时自动添加扩展名：</p><ol><li>默认值是 [‘.wasm’, ‘.mjs’, ‘.js’, ‘.json’]；</li><li>所以如果我们代码中想要添加加载 .vue 或者 jsx 或者 ts 等文件时，我们必须自己写上扩展名；</li></ol><h5 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h5><p><strong>另一个非常好用的功能是配置别名 alias</strong></p><ol><li>特别是当我们项目的目录结构比较深的时候，或者一个文件的路径可能需要 ../../../这种路径片段；</li><li>我们可以给某些常见的路径起一个别名；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210802174852517.png" alt="image-20210802174852517"></p><h3 id="如何区分开发环境"><a href="#如何区分开发环境" class="headerlink" title="如何区分开发环境"></a>如何区分开发环境</h3><p><strong>目前我们所有的 webpack 配置信息都是放到一个配置文件中的：webpack.config.js</strong></p><ol><li>当配置越来越多时，这个文件会变得越来越不容易维护；</li><li>并且某些配置是在开发环境需要使用的，某些配置是在生成环境需要使用的，当然某些配置是在开发和生成环 境都会使用的；</li><li>所以，我们最好对配置进行划分，方便我们维护和管理；</li></ol><p>那么，在启动时如何可以区分不同的配置呢？</p><ol><li><strong>方案一</strong>：编写两个不同的配置文件，开发和生成时，分别加载不同的配置文件即可；</li><li><strong>方式二</strong>：使用相同的一个入口配置文件，通过设置参数来区分它们；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210802175011294.png" alt="image-20210802175011294"></p><h4 id="入口文件解析"><a href="#入口文件解析" class="headerlink" title="入口文件解析"></a>入口文件解析</h4><p>我们之前编写入口文件的规则是这样的：./src/index.js，但是如果我们的配置文件所在的位置变成了 config 目录， 我们是否应该变成 ../src/index.js 呢</p><ol><li>如果我们这样编写，会发现是报错的，依然要写成 ./src/index.js；</li><li>这是因为入口文件其实是和另一个属性时有关的 context</li></ol><p>context 的作用是用于解析入口（entry point）和加载器（loader）：</p><p>官方说法：默认是当前路径（但是经过我测试，默认应该是 webpack 的启动目录）</p><p>另外推荐在配置中传入一个值；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210802175152242.png" alt="image-20210802175152242"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210802175158275.png" alt="image-20210802175158275"></p><h4 id="区分开发和生成环境配置"><a href="#区分开发和生成环境配置" class="headerlink" title="区分开发和生成环境配置"></a>区分开发和生成环境配置</h4><p><strong>这里我们创建三个文件：</strong></p><ol><li>webpack.common.js</li><li>webpack.prod.js</li><li>webpack.dev.js</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210802175252457.png" alt="image-20210802175252457"></p><p><strong>将公共代码和生产环境的配置以及开发时的配置分开，然后使用 webpack-merge 插件进行配置文件的合并。</strong></p><p><strong>webpack.common.js</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 公共的环境</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"html-webpack-plugin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token punctuation">{</span> DefinePlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"webpack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 引入Vue-loader的插件 帮助loader做一些事情</span><span class="token keyword">const</span> <span class="token punctuation">{</span> VueLoaderPlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"vue-loader/dist/index"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  entry<span class="token operator">:</span> <span class="token string">"./src/index.js"</span><span class="token punctuation">,</span>  output<span class="token operator">:</span> <span class="token punctuation">{</span>    path<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"../build"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    filename<span class="token operator">:</span> <span class="token string">"bundle.js"</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  module<span class="token operator">:</span> <span class="token punctuation">{</span>    rules<span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        use<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"style-loader"</span><span class="token punctuation">,</span> <span class="token string">"css-loader"</span><span class="token punctuation">,</span> <span class="token string">"postcss-loader"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.less$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        use<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"style-loader"</span><span class="token punctuation">,</span> <span class="token string">"css-loader"</span><span class="token punctuation">,</span> <span class="token string">"postcss-loader"</span><span class="token punctuation">,</span> <span class="token string">"less-loader"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token comment">// 处理图片</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(png|jpe?g|JPG)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        type<span class="token operator">:</span> <span class="token string">"asset"</span><span class="token punctuation">,</span>        generator<span class="token operator">:</span> <span class="token punctuation">{</span>          filename<span class="token operator">:</span> <span class="token string">"image/[name]-[hash:6][ext]"</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        parser<span class="token operator">:</span> <span class="token punctuation">{</span>          dataUrlCondition<span class="token operator">:</span> <span class="token punctuation">{</span>            maxSize<span class="token operator">:</span> <span class="token number">40</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(eot|ttf|woff2?)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        type<span class="token operator">:</span> <span class="token string">"asset/resource"</span><span class="token punctuation">,</span>        generator<span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token comment">// 这里使用的是filename属性 别忘了！！！！！</span>          filename<span class="token operator">:</span> <span class="token string">"font/[name]-[hash:6][ext]"</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token comment">// 对js代码进行转换</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.js$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        loader<span class="token operator">:</span> <span class="token string">"babel-loader"</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token comment">// 配置 .vue文件的加载打包规则</span>      <span class="token punctuation">{</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.vue$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>        loader<span class="token operator">:</span> <span class="token string">"vue-loader"</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      <span class="token comment">// 要注意：相对路径是从项目根路径出发的，！！！！！！！！！！！</span>      template<span class="token operator">:</span> <span class="token string">"./public/index.html"</span><span class="token punctuation">,</span>      title<span class="token operator">:</span> <span class="token string">"babel 学习！"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">DefinePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      <span class="token constant">BASE_URL</span><span class="token operator">:</span> <span class="token string">"'./'"</span><span class="token punctuation">,</span>      __VUE_OPTIONS_API__<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      __VUE_PROD_DEVTOOLS__<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">VueLoaderPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment">// resolve 模块解析</span>  <span class="token comment">// 用于设置模块如何被解析</span>  resolve<span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token comment">// 默认值就是 node_modules</span>    modules<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"node_modules"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token comment">// 文件拓展名 默认值有js mjs json wasm</span>    extensions<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">".js"</span><span class="token punctuation">,</span> <span class="token string">".ts"</span><span class="token punctuation">,</span> <span class="token string">".json"</span><span class="token punctuation">,</span> <span class="token string">".vue"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token comment">// 如果加载的模块是一个文件夹 会自动去文件夹里面的 index.xx 文件来加载</span>    mainFiles<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"index"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token comment">// 配置路径的别名</span>    alias<span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token comment">// 在路径的地方使用的js，就代表后面的这个路径</span>      js<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"../src/js"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 打包的是node环境 还是 web 环境</span>  target<span class="token operator">:</span> <span class="token string">"web"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>webpack.prod.js</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 生产环境</span><span class="token keyword">const</span> <span class="token punctuation">{</span> CleanWebpackPlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"clean-webpack-plugin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> CopyPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"copy-webpack-plugin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 合并当前环境和公共的common环境 使用 webpack-merge插件</span><span class="token keyword">const</span> <span class="token punctuation">{</span> merge <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"webpack-merge"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 导入 公共环境的配置</span><span class="token keyword">const</span> commonConfig <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./webpack.common"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>commonConfig<span class="token punctuation">,</span> <span class="token punctuation">{</span>  mode<span class="token operator">:</span> <span class="token string">"production"</span><span class="token punctuation">,</span>  devtool<span class="token operator">:</span> <span class="token string">"eval"</span><span class="token punctuation">,</span>  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">CleanWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">CopyPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      patterns<span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>          from<span class="token operator">:</span> <span class="token string">"public"</span><span class="token punctuation">,</span>          globOptions<span class="token operator">:</span> <span class="token punctuation">{</span>            ignore<span class="token operator">:</span> <span class="token string">"**/index.html"</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>webpack.dev.js</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 开发环境</span><span class="token comment">// 合并当前环境和公共的common环境 使用 webpack-merge插件</span><span class="token keyword">const</span> <span class="token punctuation">{</span> merge <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"webpack-merge"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 导入 公共环境的配置</span><span class="token keyword">const</span> commonConfig <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./webpack.common"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>commonConfig<span class="token punctuation">,</span> <span class="token punctuation">{</span>  mode<span class="token operator">:</span> <span class="token string">"development"</span><span class="token punctuation">,</span>  devtool<span class="token operator">:</span> <span class="token string">"source-map"</span><span class="token punctuation">,</span>  <span class="token comment">// 热部署（热更新）的配置</span>  devServer<span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token comment">// 如果需要的资源没有在webpack里面加载到，会去contentBase指定的文件夹里面寻找</span>    contentBase<span class="token operator">:</span> <span class="token string">"../public"</span><span class="token punctuation">,</span>    <span class="token comment">// 开启HMR 热模块替换 (最好配置一下target属性，跟DevServer同级)</span>    hot<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token comment">// 设置ip地址 主机</span>    host<span class="token operator">:</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span>    <span class="token comment">// 端口号</span>    port<span class="token operator">:</span> <span class="token number">8800</span><span class="token punctuation">,</span>    <span class="token comment">// 是否在服务启动时打开浏览器</span>    open<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token comment">// 开启 gzip压缩 传输速率提高(一般html这种文件不会压缩)</span>    compress<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token comment">// 配置 proxy 代理 解决跨域问题</span>    <span class="token comment">// 只适用于开发阶段</span>    <span class="token comment">// 相当于请求交给本地服务器发送给远程的服务器</span>    <span class="token comment">// 然后请求到的数据在给页面的请求</span>    proxy<span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token comment">// 配置映射关系</span>      <span class="token comment">// 相当于在项目中请求 /api地址 就是请求后面配置的地址</span>      <span class="token string">"/api"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        target<span class="token operator">:</span> <span class="token string">"http://www.baidu.com"</span><span class="token punctuation">,</span>        <span class="token comment">// 路径重写 将 /api开头的请求地址的 /api 给替换为 "" 空字符串</span>        pathRewrite<span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token string">"^/api"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment">// 默认不支持 转发到https的服务器上，如果需要，设置 secure为false</span>        secure<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token comment">// 是否更新代理后请求的headers中的host地址</span>        changeOrigin<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> ts </tag>
            
            <tag> webpack </tag>
            
            <tag> loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-CLI 和 Vite &amp; 尤大大新宠</title>
      <link href="/2021/11/05/src/vue/vuecli-vite/"/>
      <url>/2021/11/05/src/vue/vuecli-vite/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-CLI-和-Vite"><a href="#Vue-CLI-和-Vite" class="headerlink" title="Vue-CLI 和 Vite"></a>Vue-CLI 和 Vite</h1><h2 id="Vue-CLI"><a href="#Vue-CLI" class="headerlink" title="Vue-CLI"></a>Vue-CLI</h2><h3 id="Vue-CLI-脚手架"><a href="#Vue-CLI-脚手架" class="headerlink" title="Vue CLI 脚手架"></a>Vue CLI 脚手架</h3><p><strong>什么是 Vue 脚手架？</strong></p><ol><li>我们前面学习了如何通过 webpack 配置 Vue 的开发环境，但是在真实开发中我们不可能每一个项目从头来完成 所有的 webpack 配置，这样显示开发的效率会大大的降低；</li><li>所以在真实开发中，我们通常会使用脚手架来创建一个项目，Vue 的项目我们使用的就是 Vue 的脚手架；</li><li>脚手架其实是建筑工程中的一个概念，在我们软件工程中也会将一些帮助我们搭建项目的工具称之为脚手架；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210803202535806.png" alt="image-20210803202535806"></p><p><strong>Vue 的脚手架就是 Vue CLI：</strong></p><ol><li>CLI 是 Command-Line Interface, 翻译为命令行界面；</li><li>我们可以通过 CLI 选择项目的配置和创建出我们的项目；</li><li>Vue CLI 已经内置了 webpack 相关的配置，我们不需要从零来配置；</li></ol><h3 id="Vue-CLI-安装和使用"><a href="#Vue-CLI-安装和使用" class="headerlink" title="Vue CLI 安装和使用"></a>Vue CLI 安装和使用</h3><h4 id="安装-Vue-CLI（4-x）"><a href="#安装-Vue-CLI（4-x）" class="headerlink" title="安装 Vue CLI（4.x）"></a>安装 Vue CLI（4.x）</h4><p>这边建议安装脚手架的版本在 4.5 以上。也可以实时安装最新版。<strong>目前最新的稳定版是 4.5.13</strong></p><p>我们是进行全局安装，这样在任何时候都可以通过 vue 的命令来创建项目；</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install @vue/cli -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="升级-Vue-CLI"><a href="#升级-Vue-CLI" class="headerlink" title="升级 Vue CLI"></a>升级 Vue CLI</h4><p>如果是比较旧的版本，可以通过下面的命令来升级</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm update @vue/cli -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210803203850993.png" alt="image-20210803203850993"></p><p><strong>安装成功则可以看见版本号。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210803203921186.png" alt="image-20210803203921186"></p><h4 id="脚手架的使用"><a href="#脚手架的使用" class="headerlink" title="脚手架的使用"></a>脚手架的使用</h4><p>通过 Vue 的命令来创建项目</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vue create 项目名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="vue-create-项目的过程"><a href="#vue-create-项目的过程" class="headerlink" title="vue create 项目的过程"></a>vue create 项目的过程</h3><p><strong>通过方向键进行上下移动，空格表示选中，回车则进入下一项的配置。</strong></p><ol><li><p>输入 <code>vue create 项目名称</code> 来创建项目，然后回车。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210803204034383.png" alt="image-20210803204034383"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210803204200868.png" alt="image-20210803204200868"></p><p><strong>如果是第一次使用脚手架，应该是下面这个样式；</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210803204600259.png" alt="image-20210803204600259"></p></li><li><p>可以看见有两个 default 的配置。</p><ol><li><p>第一个是创建基于 vue2 的项目。</p></li><li><p>第二个是基于 vue3 的项目。</p></li><li><p>第三个，也就是最后一行，选择该项表示我们需要的配置要我们自己指定。<strong>（这里我们选择第三个，然后回车）</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210803204721043.png" alt="image-20210803204721043"></p></li><li><p>这一轮是来选择我们需要的插件或者说是特性。</p></li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210803205316231.png" alt="image-20210803205316231"></p><p><strong>这里作为 demo 只选前两个，回车</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210803205641992.png" alt="image-20210803205641992"></p></li><li><p>选择我们 vue 的版本，我们选择 vue3，回车</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210803205725446.png" alt="image-20210803205725446"></p></li><li><p>配置选项的配置是否生成自己单独的配置文件，回车</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210803205917707.png" alt="image-20210803205917707"></p></li><li><p>是否将我们前面做的配置和选择作为预设，方便下次直接一步创建项目，<strong>y</strong>表示作为预设，这里我们输入 <strong>n</strong>，不作为预设。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210803210211258.png" alt="image-20210803210211258"></p></li><li><p>接下来就会帮我们创建项目了</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210803210318647.png" alt="image-20210803210318647"></p></li><li><p>稍等一会就可以发现创建成功了</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210803210403126.png" alt="image-20210803210403126"></p></li></ol><h3 id="项目的目录结构"><a href="#项目的目录结构" class="headerlink" title="项目的目录结构"></a>项目的目录结构</h3><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210803211025274.png" alt="image-20210803211025274"></p><h4 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h4><h5 id="适配浏览器的配置"><a href="#适配浏览器的配置" class="headerlink" title="适配浏览器的配置"></a>适配浏览器的配置</h5><p><strong>.browserslistrc</strong>：该文件的作用是设置适配浏览器的范围的。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210803211344669.png" alt="image-20210803211344669"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&gt;</span> <span class="token number">1</span><span class="token operator">%</span> <span class="token comment">// 市场份额大于 1% 的浏览器</span>last <span class="token number">2</span> versions  <span class="token comment">// 适配最新（后）的两个版本</span>not dead  <span class="token comment">// 浏览器的版本还在维护，24个月更新或者维护认为dead</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>一般情况下我们使用默认的配置就可以了。</strong></p><h5 id="git-忽略文件"><a href="#git-忽略文件" class="headerlink" title="git 忽略文件"></a>git 忽略文件</h5><p><strong>.gitignore</strong>：提交代码时忽略的文件，文件夹等。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210803211804505.png" alt="image-20210803211804505"></p><h5 id="babel-配置文件"><a href="#babel-配置文件" class="headerlink" title="babel 配置文件"></a>babel 配置文件</h5><pre class="line-numbers language-js" data-language="js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment">// vue自己写的预设</span>  presets<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"@vue/cli-plugin-babel/preset"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="vue-cli-源码"><a href="#vue-cli-源码" class="headerlink" title="vue-cli 源码"></a>vue-cli 源码</h3><ol><li>运行 <code>npm run serve/build</code></li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804135045444.png" alt="image-20210804135045444"></p><ol start="2"><li><p>来到 <code>node_modules/.bin/vue-cli-service</code></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804135222443.png" alt="image-20210804135222443"></p></li><li><p>然后会去到 <code>@vue/cli-service</code>里面</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804135313087.png" alt="image-20210804135313087"></p></li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804135333130.png" alt="image-20210804135333130"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804135405718.png" alt="image-20210804135405718"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804135439886.png" alt="image-20210804135439886"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804135450489.png" alt="image-20210804135450489"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804135510977.png" alt="image-20210804135510977"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804135529852.png" alt="image-20210804135529852"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804135545291.png" alt="image-20210804135545291"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804135616973.png" alt="image-20210804135616973"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804135633785.png" alt="image-20210804135633785"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804135728707.png" alt="image-20210804135728707"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804135822150.png" alt="image-20210804135822150"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804135847264.png" alt="image-20210804135847264"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804135906870.png" alt="image-20210804135906870"></p><h2 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h2><h3 id="认识-Vite"><a href="#认识-Vite" class="headerlink" title="认识 Vite"></a>认识 Vite</h3><h4 id="什么是-vite"><a href="#什么是-vite" class="headerlink" title="什么是 vite"></a>什么是 vite</h4><p>Webpack 是目前整个前端使用最多的构建工具，但是除了 webpack 之后也有其他的一些构建工具：</p><p>比如 rollup、parcel、gulp、vite 等等</p><p><strong>什么是 vite 呢？ 官方的定位：下一代前端开发与构建工具；</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804140326263.png" alt="image-20210804140326263"></p><p><strong>如何定义下一代开发和构建工具呢？</strong></p><ol><li>我们知道在实际开发中，我们编写的代码往往是不能被浏览器直接识别的，比如 ES6、TypeScript、Vue 文件等 等；</li><li>所以我们必须通过构建工具来对代码进行转换、编译，类似的工具有 webpack、rollup、parcel；</li><li>但是随着项目越来越大，需要处理的 JavaScript 呈指数级增长，模块越来越多；</li><li>构建工具需要很长的时间才能开启服务器，HMR 也需要几秒钟才能在浏览器反应出来；</li><li>所以也有这样的说法：天下苦 webpack 久矣；</li></ol><p><strong>Vite (法语意为 “快速的”，发音 /vit/) 是一种新型前端构建工具，能够显著提升前端开发体验。</strong></p><h4 id="Vite-的构造"><a href="#Vite-的构造" class="headerlink" title="Vite 的构造"></a>Vite 的构造</h4><p><strong>它主要由两部分组成：</strong></p><ol><li>一个开发服务器，它基于原生 ES 模块提供了丰富的内建功能，HMR 的速度非常快速；</li><li>一套构建指令，它使用 rollup 打开我们的代码，并且它是预配置的，可以输出生成环境的优化过的静态资源；</li></ol><h4 id="vite-前景"><a href="#vite-前景" class="headerlink" title="vite 前景"></a>vite 前景</h4><p><strong>目前是否要大力学习 vite？vite 的未来是怎么样的？</strong></p><ol><li>我个人非常看好 vite 的未来，也希望它可以有更好的发展；</li><li>但是，目前 vite 虽然已经更新到 2.0，依然并不算非常的稳定，并且比较少大型项目（或框架）使用 vite 来进行 构建；</li><li>vite 的整个社区插件等支持也还不够完善；</li><li>包括 vue 脚手架本身，目前也还没有打算迁移到 vite，而依然使用 webpack（虽然后期一定是有这个打算的）；</li><li>所以 vite 看起来非常的火热，在面试也可能会问到，但是实际项目中应用的还比较少；</li></ol><h3 id="浏览器原生支持模块化"><a href="#浏览器原生支持模块化" class="headerlink" title="浏览器原生支持模块化"></a>浏览器原生支持模块化</h3><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804142321245.png" alt="image-20210804142321245"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804142329557.png" alt="image-20210804142329557"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804142341357.png" alt="image-20210804142341357"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804142350221.png" alt="image-20210804142350221"></p><p>但是如果我们不借助于其他工具，直接使用 ES Module 来开发有什么问题呢？</p><ol><li>首先，我们会发现在使用 loadash 时，加载了上百个模块的 js 代码，对于浏览器发送请求是巨大的消耗；</li><li>其次，我们的<strong>代码中如果有 TypeScript、less、vue 等代码时，浏览器并不能直接识别；</strong></li></ol><p><strong>事实上，vite 就帮助我们解决了上面的所有问题。</strong></p><p><strong>注意：安装一下 lodash-es（工具包），来帮助我们管理 es 模块化。</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install lodash-es<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="lodash-es-的使用"><a href="#lodash-es-的使用" class="headerlink" title="lodash-es 的使用"></a>lodash-es 的使用</h4><p>直接进行使用，发现<strong>浏览器报错</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804143222638.png" alt="image-20210804143222638"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804143236443.png" alt="image-20210804143236443"></p><p>浏览器并不支持这种直接书写 node 的模块的语法。</p><p><strong>必须直接导入对应的 js 文件才可以。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804143420451.png" alt="image-20210804143420451"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804143431065.png" alt="image-20210804143431065"></p><h4 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h4><p>上面那种导入模块的方式弊端很大。我们可以发现，导入一个第三方模块发起了很多的请求。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804143619817.png" alt="image-20210804143619817"></p><p>因为 lodash-es 这个模块的文件依赖了很多其他的文件，所以也会被浏览器请求给加载。<strong>这样是很消耗浏览器性能的。</strong></p><h3 id="Vite-的安装和使用"><a href="#Vite-的安装和使用" class="headerlink" title="Vite 的安装和使用"></a>Vite 的安装和使用</h3><p><strong>注意：Vite 本身也是依赖 Node 的，所以也需要安装好 Node 环境</strong></p><p>并且 Vite 要求<strong>Node 版本是大于 12</strong>版本的；</p><p><strong>首先，我们安装一下 vite 工具</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install vite –g # 全局安装npm install vite –D # 局部安装<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>通过 vite 来启动项目：</strong></p><p>局部安装启动命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npx vite<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804144910851.png" alt="image-20210804144910851"></p><p><strong>vite 会创建一个本地服务器。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804144944185.png" alt="image-20210804144944185"></p><p><strong>现在导入模块可以不加后缀名了，也可以直接导入第三方模块了。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804145206590.png" alt="image-20210804145206590"></p><p><strong>可以看见浏览器正常支持</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804145230838.png" alt="image-20210804145230838"></p><p><strong>也可以发现明显加载的请求资源变少了，意味着不会那么消耗浏览器的性能，并且加载速度也会明显提升。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804145330594.png" alt="image-20210804145330594"></p><h3 id="vite-对第三方的支持"><a href="#vite-对第三方的支持" class="headerlink" title="vite 对第三方的支持"></a>vite 对第三方的支持</h3><h4 id="1-Vite-对-css-的支持"><a href="#1-Vite-对-css-的支持" class="headerlink" title="1. Vite 对 css 的支持"></a>1. Vite 对 css 的支持</h4><p>vite 可以直接支持 css 的处理，直接导入 css 即可；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804145642817.png" alt="image-20210804145642817"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804145657089.png" alt="image-20210804145657089"></p><p><strong>vite 可以直接支持 css 预处理器，比如 less</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804150224428.png" alt="image-20210804150224428"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804150209543.png" alt="image-20210804150209543"></p><ol><li><p>直接导入 less； 发现报错了。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804150240951.png" alt="image-20210804150240951"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804150312741.png" alt="image-20210804150312741"></p></li><li><p>之后安装 less 编译器；</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install less -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804150713422.png" alt="image-20210804150713422"></p></li></ol><p><strong>vite 直接支持 postcss 的转换：</strong></p><p>只需要安装 postcss，并且配置 postcss.config.js 的配置文件即可；</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install postcss postcss-preset-env -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804151320335.png" alt="image-20210804151320335"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804151325968.png" alt="image-20210804151325968"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804151339979.png" alt="image-20210804151339979"></p><h4 id="2-Vite-对-TypeScript-的支持"><a href="#2-Vite-对-TypeScript-的支持" class="headerlink" title="2. Vite 对 TypeScript 的支持"></a>2. Vite 对 TypeScript 的支持</h4><p><strong>注意：ts 我会在后面的博客中推出的。这里只是简单使用</strong></p><p>vite 对 TypeScript 是原生支持的，它会直接使用 ESBuild 来完成编译：</p><p><strong>只需要直接导入即可；</strong></p><p>如果我们查看浏览器中的请求，会发现请求的依然是 ts 的代码：</p><ol><li>这是因为 vite 中的服务器 Connect 会对我们的请求进行转发；</li><li>获取 ts 编译后的代码，给浏览器返回，浏览器可以直接进行解析；</li></ol><p><strong>注意：在 vite2 中，已经不再使用 Koa 了，而是使用 Connect 来搭建的服务器</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804151707985.png" alt="image-20210804151707985"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804151947452.png" alt="image-20210804151947452"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804151956647.png" alt="image-20210804151956647"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804152011050.png" alt="image-20210804152011050"></p><p>vite 直接就支持 ts 文件的书写和直接导入使用。</p><p><strong>也可以发现请求的是 ts 文件。浏览器的确是不能解析 ts 的，但是 vite 帮我们做了请求转发，中间解析了 ts</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804152122557.png" alt="image-20210804152122557"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804153141517.png" alt="image-20210804153141517"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804153222121.png" alt="image-20210804153222121"></p><h4 id="3-Vite-对-vue-的支持"><a href="#3-Vite-对-vue-的支持" class="headerlink" title="3. Vite 对 vue 的支持"></a>3. Vite 对 vue 的支持</h4><p><strong>vite 对 vue 提供第一优先级支持：</strong></p><ol><li>Vue 3 单文件组件支持：@vitejs/plugin-vue</li><li>Vue 3 JSX 支持：@vitejs/plugin-vue-jsx</li><li>Vue 2 支持：underfin/vite-plugin-vue2</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804154430894.png" alt="image-20210804154430894"></p><p><strong>页面上需要有 id 为 app 的盒子。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804154506453.png" alt="image-20210804154506453"></p><p><strong>直接运行，发现报错，提示我们缺少插件</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804154417082.png" alt="image-20210804154417082"></p><p><strong>安装支持 vue 的插件：</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install @vitejs/plugin-vue -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>在 vite.config.js 中配置插件：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> vue <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"@vitejs/plugin-vue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>此时仍然缺少插件，vue 单文件的编译插件</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804154937792.png" alt="image-20210804154937792"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cnpm i @vue/compiler-sfc -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>成功运行</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804155433188.png" alt="image-20210804155433188"></p><h4 id="4-Vite-打包项目"><a href="#4-Vite-打包项目" class="headerlink" title="4. Vite 打包项目"></a>4. Vite 打包项目</h4><p><strong>其实：vite 在每次运行项目时，都会进行预打包。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804160344336.png" alt="image-20210804160344336"></p><p>我们可以直接通过 vite build 来完成对当前项目的打包工具：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npx vite build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804160021478.png" alt="image-20210804160021478"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804160034400.png" alt="image-20210804160034400"></p><p>我们可以通过<strong>preview</strong>的方式，开启一个本地服务来预览打包后的效果：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npx vite preview<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804160129791.png" alt="image-20210804160129791"></p><p><strong>有毛病吗，没有任何毛病！</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804160210226.png" alt="image-20210804160210226"></p><h4 id="5-ESBuild-解析"><a href="#5-ESBuild-解析" class="headerlink" title="5. ESBuild 解析"></a>5. ESBuild 解析</h4><p><strong>ESBuild 的特点：</strong></p><ol><li>超快的构建速度，并且不需要缓存；</li><li>支持 ES6 和 CommonJS 的模块化；</li><li>支持 ES6 的 Tree Shaking；</li><li>支持 Go、JavaScript 的 API；</li><li>支持 TypeScript、JSX 等语法编译；</li><li>支持 SourceMap；</li><li>支持代码压缩；</li><li>支持扩展其他插件；</li></ol><h5 id="ESBuild-的构建速度"><a href="#ESBuild-的构建速度" class="headerlink" title="ESBuild 的构建速度"></a>ESBuild 的构建速度</h5><p>ESBuild 的构建速度和其他构建工具速度对比：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804160421489.png" alt="image-20210804160421489"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804161237324.png" alt="image-20210804161237324"></p><p>ESBuild 为什么这么快呢？</p><ol><li>使用 Go 语言编写的，可以直接转换成机器代码，而无需经过字节码；</li><li>ESBuild 可以充分利用 CPU 的多内核，尽可能让它们饱和运行；</li><li>ESBuild 的所有内容都是从零开始编写的，而不是使用第三方，所以从一开始就可以考虑各种性能问题；</li><li>等等…</li></ol><h3 id="Vite-脚手架工具"><a href="#Vite-脚手架工具" class="headerlink" title="Vite 脚手架工具"></a>Vite 脚手架工具</h3><p>在开发中，我们不可能所有的项目都使用 vite 从零去搭建，比如一个 react 项目、Vue 项目；</p><p>这个时候 vite 还给我们提供了对应的脚手架工具；</p><p><strong>所以 Vite 实际上是有两个工具的：</strong></p><ol><li>vite：相当于是一个构件工具，类似于 webpack、rollup；</li><li>@vitejs/create-app：类似 vue-cli、create-react-app；</li></ol><p><strong>如何使用脚手架工具呢？</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm init @vitejs/app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>上面的做法相当于省略了安装脚手架的过程：</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install @vitejs/create-app -gcreate-app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="vite-cli-脚手架创建过程"><a href="#vite-cli-脚手架创建过程" class="headerlink" title="vite-cli 脚手架创建过程"></a>vite-cli 脚手架创建过程</h4><ol><li>创建项目，指定项目名称</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">create-app 项目名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li><p>选择我们需要的框架，vite 也提供了多种选择，这里我们选 vue，然后回车</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804162300875.png" alt="image-20210804162300875"></p></li><li><p>这里就先选择不带 ts 的。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804162339440.png" alt="image-20210804162339440"></p></li><li><p>然后就创建成功了</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804162402677.png" alt="image-20210804162402677"></p></li><li><p>进入项目文件夹</p></li><li><p>安装依赖（默认是没有帮我们安装依赖的）</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>启动项目</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm run dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804163549269.png" alt="image-20210804163549269"></p></li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210804163727684.png" alt="image-20210804163727684"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> vite </category>
          
          <category> vue-cli </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> ts </tag>
            
            <tag> webpack </tag>
            
            <tag> vueCli </tag>
            
            <tag> vite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3-组件化</title>
      <link href="/2021/11/04/src/vue/vue3-zu-jian-hua/"/>
      <url>/2021/11/04/src/vue/vue3-zu-jian-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-组件化-一-父子组件通信"><a href="#Vue3-组件化-一-父子组件通信" class="headerlink" title="Vue3 组件化(一)-父子组件通信"></a>Vue3 组件化(一)-父子组件通信</h1><h2 id="组件的嵌套"><a href="#组件的嵌套" class="headerlink" title="组件的嵌套"></a>组件的嵌套</h2><h3 id="认识组件的嵌套"><a href="#认识组件的嵌套" class="headerlink" title="认识组件的嵌套"></a>认识组件的嵌套</h3><p><strong>前面我们是将所有的逻辑放到一个 App.vue 中：</strong></p><ol><li>在之前的案例中，我们只是创建了一个组件 App；</li><li>如果我们一个应用程序将所有的逻辑都放在一个组件中，那么这个组件就会变成非 常的臃肿和难以维护；</li><li>所以组件化的核心思想应该是对组件进行拆分，拆分成一个个小的组件；</li><li>再将这些组件组合嵌套在一起，最终形成我们的应用程序；</li></ol><p>我们来分析一下下面代码的嵌套逻辑，假如我们将所有的代码逻辑都放到一个 App.vue 组件中：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210807201258559.png" alt="image-20210807201258559"></p><ol><li>我们会发现，将所有的代码逻辑全部放到一个组件中，代码是非常的臃肿和难以维 护的。</li><li>并且在真实开发中，我们会有更多的内容和代码逻辑，对于扩展性和可维护性来说 都是非常差的。</li><li>所以，在真实的开发中，我们会对组件进行拆分，拆分成一个个功能的小组件。</li></ol><h3 id="组件的拆分"><a href="#组件的拆分" class="headerlink" title="组件的拆分"></a>组件的拆分</h3><p><strong>我们可以按照如下的方式进行拆分：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210807201350134.png" alt="image-20210807201350134"></p><p>按照如上的拆分方式后，我们开发对应的逻辑只需要去对应的组件编写就可。</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">App.vue文件&lt;template lang="html"&gt;  &lt;!-- 使用局部组件 --&gt;  &lt;div id="app"&gt;    &lt;Header&gt;&lt;/Header&gt;    &lt;!-- 如果组件不需要填充数据或标签等，可以直接使用单标签 --&gt;    &lt;Main /&gt;    &lt;Footer /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 导入vue组件import Header from "./Header";import Main from "./Main";import Footer from "./Footer";export default {  data() {    return {};  },  // 注册局部组件  components: {    Header,    Main,    Footer,  },};&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">Header.vue&lt;template lang=""&gt;  &lt;div id="header"&gt;    &lt;h2&gt;哈哈哈&lt;/h2&gt;    &lt;h2&gt;header&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {};&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">Main.vue&lt;template&gt;  &lt;div id="main"&gt;    &lt;h2&gt;haha&lt;/h2&gt;    &lt;h3&gt;main&lt;/h3&gt;    &lt;main-banner&gt;&lt;/main-banner&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MainBanner from "./MainBanner.vue";export default {  components: { MainBanner },};&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">MainBanner.vue&lt;template&gt;  &lt;ul&gt;    &lt;li&gt;商品信息1&lt;/li&gt;    &lt;li&gt;商品信息2&lt;/li&gt;    &lt;li&gt;商品信息3&lt;/li&gt;    &lt;li&gt;商品信息4&lt;/li&gt;    &lt;li&gt;商品信息5&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;export default {};&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">Footer.vue&lt;template&gt;  &lt;div id="footer"&gt;    &lt;h2&gt;main&lt;/h2&gt;    &lt;h2&gt;hahah&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {};&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210807202015394.png" alt="image-20210807202015394"></p><h2 id="组件的通信"><a href="#组件的通信" class="headerlink" title="组件的通信"></a>组件的通信</h2><h3 id="组件的通信-1"><a href="#组件的通信-1" class="headerlink" title="组件的通信"></a>组件的通信</h3><p><strong>上面的嵌套逻辑如下，它们存在如下关系：</strong></p><ol><li>App 组件是 Header、Main、Footer 组件的父组件；</li><li>Main 组件是 Banner、ProductList 组件的父组件；</li></ol><p>在开发过程中，我们会经常遇到需要<strong>组件之间相互进行通信：</strong></p><ol><li>比如 App 可能使用了多个 Header，每个地方的 Header 展示的内容不同，那么我们就需要使用者传递给 Header 一些数据，让其进行展示；</li><li>又比如我们在 Main 中一次性请求了 Banner 数据和 ProductList 数据，那么就需要传递给它们来进行展示；</li><li>也可能是子组件中发生了事件，需要由父组件来完成某些操作，那就需要子组件向父组件传递事件；</li></ol><p>总之，在一个 Vue 项目中，组件之间的通信是非常重要的环节，所以接下来我们就具体学习一下组件之间是如何相 互之间传递数据的；</p><h3 id="父子组件之间通信的方式"><a href="#父子组件之间通信的方式" class="headerlink" title="父子组件之间通信的方式"></a>父子组件之间通信的方式</h3><p><strong>父子组件之间如何进行通信呢？</strong></p><ol><li>父组件传递给子组件：通过<strong>props</strong>属性；</li><li>子组件传递给父组件：通过**$emit**触发事件；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210807201629967.png" alt="image-20210807201629967"></p><h3 id="父组件传递给子组件"><a href="#父组件传递给子组件" class="headerlink" title="父组件传递给子组件"></a>父组件传递给子组件</h3><p>在开发中很常见的就是父子组件之间通信，比如父组件有一些数据，需要子组件来进行展示：</p><p>这个时候我们可以通过<strong>props</strong>来完成组件之间的通信；</p><p><strong>什么是 Props 呢？</strong></p><ol><li>Props 是你可以在组件上注册一些自定义的<strong>attribute；</strong></li><li>父组件给这些 attribute 赋值，子组件通过<strong>attribute</strong>的名称获取到对应的值；</li></ol><p><strong>Props 有两种常见的用法：</strong></p><ol><li>方式一：字符串数组，数组中的字符串就是 attribute 的名称；</li><li>方式二：对象类型，对象类型我们可以在指定 attribute 名称的同时，指定它需要传递的类型、是否是必须的、 默认值等等</li></ol><h4 id="Props-的数组用法"><a href="#Props-的数组用法" class="headerlink" title="Props 的数组用法"></a>Props 的数组用法</h4><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210807202329042.png" alt="image-20210807202329042"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210807202350113.png" alt="image-20210807202350113"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210807202358342.png" alt="image-20210807202358342"></p><h4 id="Props-的对象用法"><a href="#Props-的对象用法" class="headerlink" title="Props 的对象用法"></a>Props 的对象用法</h4><p>数组用法中我们只能说明传入的<strong>attribute</strong>的名称，并不能对其进行任何形式的限制，接下来我们来看一下对象的 写法是如何让我们的<strong>props</strong>变得更加完善的。</p><p><strong>当使用对象语法的时候，我们可以对传入的内容限制更多：</strong></p><ol><li>比如指定传入的 attribute 的类型；</li><li>比如指定传入的 attribute 是否是必传的；</li><li>比如指定没有传入时，attribute 的默认值；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210807202626613.png" alt="image-20210807202626613"></p><h4 id="细节一：type-类型"><a href="#细节一：type-类型" class="headerlink" title="细节一：type 类型"></a>细节一：type 类型</h4><p><strong>那么 type 的类型都可以是哪些呢？</strong></p><ol><li>String</li><li>Number</li><li>Boolean</li><li>Array</li><li>Object</li><li>Date</li><li>Function</li><li>Symbol(ES6 新增的基本类型)</li></ol><h4 id="细节二：对象类型的其他写法"><a href="#细节二：对象类型的其他写法" class="headerlink" title="细节二：对象类型的其他写法"></a>细节二：对象类型的其他写法</h4><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210807204244840.png" alt="image-20210807204244840"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210807204255330.png" alt="image-20210807204255330"></p><h4 id="细节三：Prop-的大小写命名"><a href="#细节三：Prop-的大小写命名" class="headerlink" title="细节三：Prop 的大小写命名"></a>细节三：Prop 的大小写命名</h4><p><strong>Prop 的大小写命名(camelCase vs kebab-case)</strong></p><ol><li>HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符；</li><li>这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短 横线分隔命名) 命名</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210807205803322.png" alt="image-20210807205803322"></p><h4 id="非-Prop-的-Attribute"><a href="#非-Prop-的-Attribute" class="headerlink" title="非 Prop 的 Attribute"></a>非 Prop 的 Attribute</h4><p><strong>什么是非 Prop 的 Attribute 呢？</strong></p><p>当我们传递给一个组件某个属性，但是该属性并没有定义对应的 props 或者 emits 时，就称之为 非 Prop 的 Attribute；</p><p>常见的包括 class、style、id 属性等；</p><p><strong>Attribute 继承</strong></p><p>当组件有单个根节点时，非 Prop 的<strong>Attribute</strong>将自动添加到根节点的 Attribute 中：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210807210559784.png" alt="image-20210807210559784"></p><h4 id="禁用-Attribute-继承和多根节点"><a href="#禁用-Attribute-继承和多根节点" class="headerlink" title="禁用 Attribute 继承和多根节点"></a>禁用 Attribute 继承和多根节点</h4><p>如果我们不希望组件的根元素继承<strong>attribute</strong>，可以在组件中设置 <strong>inheritAttrs: false：</strong></p><ol><li><p>禁用 attribute 继承的常见情况是需要将 attribute 应用于根元素之外的其他元素；</p></li><li><p>我们可以通过 <strong>$attrs</strong>来访问所有的 非 props 的 attribute；</p></li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210808084721740.png" alt="image-20210808084721740"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210808084819837.png" alt="image-20210808084819837"></p><hr><p><strong>多个根节点的 attribute</strong></p><p>多个根节点的<strong>attribute</strong>如果<strong>没有显示的绑定</strong>，那么<strong>会报警告</strong>，我们必须手动的指定要绑定到哪一个属性上：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210808085158545.png" alt="image-20210808085158545"></p><p><strong>如果我们不继承父组件的 attribute 属性，设置了 <code>inheritAttrs:false</code>，那么则不会报警告。没有根节点会继承根元素的属性。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210808085525363.png" alt="image-20210808085525363"></p><h3 id="子组件传递给父组件"><a href="#子组件传递给父组件" class="headerlink" title="子组件传递给父组件"></a>子组件传递给父组件</h3><h4 id="子组件传递给父组件-1"><a href="#子组件传递给父组件-1" class="headerlink" title="子组件传递给父组件"></a>子组件传递给父组件</h4><p><strong>什么情况下子组件需要传递内容到父组件呢</strong></p><ol><li>当子组件有一些事件发生的时候，比如在组件中发生了点击，父组件需要切换内容；</li><li>子组件有一些内容想要传递给父组件的时候；</li></ol><p><strong>我们如何完成上面的操作呢？</strong></p><ul><li>首先，我们需要在子组件中定义好在某些情况下触发的事件名称；</li><li>其次，在父组件中以 v-on 的方式传入要监听的事件名称，并且绑定到对应的方法中；</li><li>最后，在子组件中发生某个事件的时候，根据事件名称触发对应的事件；</li></ul><h4 id="自定义事件的流程"><a href="#自定义事件的流程" class="headerlink" title="自定义事件的流程"></a>自定义事件的流程</h4><p>我们封装一个 CounterOperation.vue 的组件：</p><p>内部其实是监听两个按钮的点击，点击之后通过 this.$emit 的方式发出去事件；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210808094848820.png" alt="image-20210808094848820"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210808095011935.png" alt="image-20210808095011935"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210808095038389.png" alt="image-20210808095038389"></p><h4 id="自定义事件的参数和验证"><a href="#自定义事件的参数和验证" class="headerlink" title="自定义事件的参数和验证"></a>自定义事件的参数和验证</h4><p>自定义事件的时候，我们也可以传递一些参数给父组件：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210808095143390.png" alt="image-20210808095143390"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210808095210856.png" alt="image-20210808095210856"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210808095219037.png" alt="image-20210808095219037"></p><p><strong>在 vue3 当中，我们可以对传递的参数进行验证：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210808095252388.png" alt="image-20210808095252388"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210808095326833.png" alt="image-20210808095326833"></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">App.vue&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;当前计数：{{ counter }}&lt;/h2&gt;    &lt;!-- 监听子组件触发的事件 --&gt;    &lt;!-- 子组件触发的是什么事件，我们就需要监听什么事件 --&gt;    &lt;!-- 就如这里：子组件触发的是add和sub事件，那么我们监听的必然是add和sub事件 --&gt;    &lt;!-- 但是我们监听到的事件用的处理函数是任意的，addOne，subOne是任意的 --&gt;    &lt;counter-operation      @add="addOne"      @sub="subOne"      @addN="addN"    &gt;&lt;/counter-operation&gt;    &lt;!-- 注意：监听子组件的事件时，我们绑定的事件处理函数不要带括号，不然无法接收到子组件传递出来的参数 --&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import CounterOperation from "./CounterOperation.vue";export default {  components: { CounterOperation },  data() {    return {      counter: 0,    };  },  methods: {    addOne() {      this.counter++;    },    subOne() {      this.counter--;    },    // 事件处理函数可以接收子组件触发事件时传递给父组件的参数    // 在括号上写的形参就会直接被子组件传递的参数赋值    // 我们可以直接使用，多个参数也是一样    addN(num) {      this.counter += num;    },  },};&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">CounterOperation.vue&lt;template&gt;  &lt;div&gt;    &lt;button @click="increment"&gt;+&lt;/button&gt;    &lt;button @click="decrement"&gt;-&lt;/button&gt;    &lt;input type="text" v-model.number="num" /&gt;    &lt;br /&gt;    &lt;button @click="incrementN"&gt;+n&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  // 子组件会触发的事件，写在 emits属性上  // emits 可以是数组，也可以是对象，用的多的是数组  // 这是Vue3的写法，需要触发的事件需要先注册  // emits: ['add', 'sub', 'addN'],  // emits 对象写法，可以进行参数的验证  emits: {    // null 表示不需要进行参数的验证    add: null,    sub: null,    // 需要验证的话，触发的事件后面是一个验证参数的函数    // 我们可以写成箭头函数    // 返回 true 表示参数验证通过，fasle则验证失败，会报警告    // 注意：验证失败也会把参数传递过去的！！！！    addN: (payload) =&gt; {      console.log(typeof payload);      // 看看是不是number类型      if (typeof payload === "number") return true;      return false;    },  },  data() {    return {      num: 0,    };  },  methods: {    increment() {      // 触发我们注册的 add事件      this.$emit("add");    },    decrement() {      // 触发我们注册的 sub 事件      this.$emit("sub");    },    incrementN() {      // 触发addN事件，一次加N个数，所以需要我们把加的数也传递出去      // 需要几个参数就传递几个参数      this.$emit("addN", this.num);    },  },};&lt;/script&gt;&lt;style scoped&gt;button {  margin-right: 20px;}&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Vue3-组件化开发-二-非父子组件通信及插槽的使用"><a href="#Vue3-组件化开发-二-非父子组件通信及插槽的使用" class="headerlink" title="Vue3 组件化开发(二)-非父子组件通信及插槽的使用"></a>Vue3 组件化开发(二)-非父子组件通信及插槽的使用</h1><h2 id="非父子组件的通信"><a href="#非父子组件的通信" class="headerlink" title="非父子组件的通信"></a>非父子组件的通信</h2><p>在开发中，我们构建了组件树之后，除了<strong>父子组件之间的通信</strong>之外，还会有非父<strong>子组件之间的通信。</strong></p><p><strong>这里我们主要讲两种方式：</strong></p><ol><li><strong>Provide/Inject；</strong></li><li><strong>Mitt 全局事件总线；</strong></li></ol><h3 id="Provide-和-Inject"><a href="#Provide-和-Inject" class="headerlink" title="Provide 和 Inject"></a>Provide 和 Inject</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Provide/Inject 用于<strong>非父子组件之间共享数据</strong>：</p><ol><li>比如有一些<strong>深度嵌套的组件</strong>，子组件想要获取父组件的部分内 容；</li><li>在这种情况下，如果我们仍然将 props 沿着组件链逐级传递下 去，就会非常的麻烦；</li></ol><p>对于这种情况下，我们可以使用 <strong>Provide 和 Inject</strong> ：</p><ol><li>无论层级结构有多深，父组件都可以作为其所有子组件的依赖 提供者</li><li>父组件有一个 <strong>provide 选项</strong>来提供数据；</li><li>子组件有一个 <strong>inject 选项</strong>来开始使用这些数据；</li></ol><p>实际上，你可以将依赖注入看作是“long range props”，除了：</p><ol><li>父组件不需要知道哪些子组件使用它 provide 的 property</li><li>子组件不需要知道 inject 的 property 来自哪里</li></ol><h4 id="Provide-和-Inject-基本使用"><a href="#Provide-和-Inject-基本使用" class="headerlink" title="Provide 和 Inject 基本使用"></a>Provide 和 Inject 基本使用</h4><p><strong>我们开发一个这样的结构：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210809213806778.png" alt="image-20210809213806778"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210809214129165.png" alt="image-20210809214129165"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210809215147771.png" alt="image-20210809215147771"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210809215151699.png" alt="image-20210809215151699"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210809215402748.png" alt="image-20210809215402748"></p><h4 id="Provide-和-Inject-函数的写法"><a href="#Provide-和-Inject-函数的写法" class="headerlink" title="Provide 和 Inject 函数的写法"></a>Provide 和 Inject 函数的写法</h4><p>如果 Provide 中提供的一些数据是来自 data，那么我们可能会想要通过 this 来获取：</p><p><strong>这个时候会报错：</strong></p><p>这里给大家留一个思考题，我们的 this 使用的是哪里的 this？</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210809215637892.png" alt="image-20210809215637892"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210809215733865.png" alt="image-20210809215733865"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210809215653396.png" alt="image-20210809215653396"></p><h5 id="对象类型的写法"><a href="#对象类型的写法" class="headerlink" title="对象类型的写法"></a>对象类型的写法</h5><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210809220311862.png" alt="image-20210809220311862"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210809220405128.png" alt="image-20210809220405128"></p><p><strong>我们发现往 names 里面添加元素，非子组件拿到的 names 的 length 也不会响应式的方式改变</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210809220611680.png" alt="image-20210809220611680"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210809220623869.png" alt="image-20210809220623869"></p><h4 id="处理响应式数据"><a href="#处理响应式数据" class="headerlink" title="处理响应式数据"></a>处理响应式数据</h4><p>我们先来验证一个结果：如果我们修改了 this.names 的内容，那么使用 length 的子组件会不会是响应式的？</p><p>我们会发现对应的<strong>子组件中是没有反应的：</strong></p><p>这是因为当我们修改了 names 之后，之前在 provide 中引入的 <strong>this.names.length</strong> 本身并不是响应式的；</p><p><strong>那么怎么样可以让我们的数据变成响应式的呢？</strong></p><ol><li>非常的简单，我们可以使用<strong>响应式的一些 API</strong>来完成这些功能，比如说 computed 函数；</li><li>当然，这个<strong>computed 是 vue3</strong>的新特性，在后面我会专门讲解，这里大家可以先直接使用一下；</li></ol><p><strong>注意：我们在使用 length 的时候需要获取其中的 value</strong></p><p>这是因为 computed 返回的是一个 ref 对象，需要取出其中的 value 来使用；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210809221124200.png" alt="image-20210809221124200"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210809221148276.png" alt="image-20210809221148276"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210809221256512.png" alt="image-20210809221256512"></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">App.vue&lt;template&gt;  &lt;div&gt;    &lt;home&gt;&lt;/home&gt;    &lt;!-- 测试数组长度发生改变，通过provide传递到子组件的数组长度是否发生改变 --&gt;    &lt;button @click="names.push('张三')"&gt;添加names&lt;/button&gt;    &lt;!-- 结论：不会发生改变 --&gt;    &lt;ul&gt;      &lt;li v-for="item in names" :key="item"&gt;{{ item }}&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Home from "./Home.vue";// 导入 vue 中的computed函数 （暂时使用，后面会讲）import { computed } from "vue";export default {  components: { Home },  // 我们可以通过 provide属性 直接提供数据供任意层级的子类使用（比如孙子组件，曾孙组件）  /* provide: {    info: {      name: '毛毛',      age: 21,      message: '好好学vue.js！闷声发大财！'    },    test: '哈哈，测试一下别名好不好使！',    length:this.names.length  }, */  // 如果想要在provide中使用data中的数据，那也就是必须用到了this  // 那么这时候我们需要把provide写成函数的形式，返回一个对象  // 这样才能在使用this。函数绑定了当前组件的this  provide() {    return {      info: {        name: "毛毛",        age: 21,        message: "好好学vue.js！闷声发大财！",      },      test: "哈哈，测试一下别名好不好使！",      // 获取 names数组的长度 这种获取的方式并不是响应式的      // length: this.names.length,      // 通过 computed函数 响应式的传递数据      // computed函数的返回值是一个 ref对象      // 我们真正的值在 ref对象的value属性上,所以子类组件取值的时候，需要通过value属性获取      // 一旦我们监听的值发生了改变，就会重新计算      length: computed(() =&gt; this.names.length),    };  },  data() {    return {      names: ["哈哈", "哼哼", "呵呵"],    };  },};&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">Home.vue&lt;template&gt;  &lt;div&gt;    &lt;home-content&gt;&lt;/home-content&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HomeContent from "./HomeContent.vue";export default {  components: { HomeContent },};&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">HomeContent.vue&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;我是HomeContent.vue!&lt;/h2&gt;    &lt;ul&gt;      &lt;li v-for="(value, key) in info" :key="key"&gt;{{ key }}---&gt;{{ value }}&lt;/li&gt;    &lt;/ul&gt;    &lt;h3&gt;{{ homeTest }}&lt;/h3&gt;    &lt;!-- 提示 test 没有被定义 --&gt;    &lt;!-- &lt;h3&gt;{{ test }}&lt;/h3&gt; --&gt;    &lt;!-- 发现父类（统称）传递数据的时候使用了computed函数的话，      我们取值的时候通过该函数返回对象的value属性拿真正的值就是响应式的了    --&gt;    &lt;!-- &lt;h3&gt;{{ length }}&lt;/h3&gt; --&gt;    &lt;h3&gt;{{ length.value }}&lt;/h3&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  // provide提供数据的注入，需要什么属性对应的数据，就注入什么属性  // inject: ['info']  // 起别名： 别名：注册的属性。在组件中可以使用别名，不能使用父组件提供的原来的属性名了  inject: {    info: "info",    homeTest: "test",    length: "length",  },};&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="全局事件总线-mitt-库"><a href="#全局事件总线-mitt-库" class="headerlink" title="全局事件总线 mitt 库"></a>全局事件总线 mitt 库</h3><p><strong>事件总线的函数可以自己写，本质上是使用了发布订阅的设计模式。</strong></p><p>Vue3 从实例中移除了 <strong>$on、$off 和 $once</strong> 方法，所以我们如果希望继续使用全局事件总线，要通过第三方的库：</p><ol><li>Vue3 官方有推荐一些库，例如 <strong>mitt</strong> 或 <strong>tiny-emitter；</strong></li><li>这里我们主要讲解一下 mitt 库的使用；</li></ol><p><strong>首先，我们需要先安装这个库：</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install mitt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>其次，我们可以封装一个工具 eventbus.js：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/* 事件总线的封装 */</span><span class="token comment">// 导入第三方库，返回值是一个函数</span><span class="token keyword">import</span> mitt <span class="token keyword">from</span> <span class="token string">"mitt"</span><span class="token punctuation">;</span><span class="token keyword">const</span> emitter <span class="token operator">=</span> <span class="token function">mitt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> emitter<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用事件总线工具"><a href="#使用事件总线工具" class="headerlink" title="使用事件总线工具"></a>使用事件总线工具</h4><p><strong>在项目中可以使用它们：</strong></p><ol><li>我们在 HomeContent.vue 中监听事件；</li><li>我们在 Subling.vue 中发射（触发）事件；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810090811490.png" alt="image-20210810090811490"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810090846400.png" alt="image-20210810090846400"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810091003293.png" alt="image-20210810091003293"></p><h4 id="Mitt-的事件取消"><a href="#Mitt-的事件取消" class="headerlink" title="Mitt 的事件取消"></a>Mitt 的事件取消</h4><p><strong>在某些情况下我们可能希望取消掉之前注册的函数监听：</strong></p><ol><li><p><strong>取消所有的监听事件</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810091115213.png" alt="image-20210810091115213"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810091126907.png" alt="image-20210810091126907"></p></li><li><p><strong>取消某个事件的监听</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810091717819.png" alt="image-20210810091717819"></p></li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810091746955.png" alt="image-20210810091746955"></p><h2 id="组件插槽-Slot"><a href="#组件插槽-Slot" class="headerlink" title="组件插槽 Slot"></a>组件插槽 Slot</h2><h3 id="认识插槽-Slot"><a href="#认识插槽-Slot" class="headerlink" title="认识插槽 Slot"></a>认识插槽 Slot</h3><p><strong>在开发中，我们会经常封装一个个可复用的组件：</strong></p><ol><li>前面我们会通过 props 传递给组件一些数据，让组件来进行展示；</li><li>但是为了让这个组件具备更强的通用性，我们不能将组件中的内容限制为固定的 div、span 等等这些元素；</li><li>比如某种情况下我们使用组件，希望组件显示的是一个按钮，某种情况下我们使用组件希望显示的是一张图片；</li><li>我们应该让使用者可以决定某一块区域到底存放什么内容和元素；</li></ol><p><strong>举个栗子：假如我们定制一个通用的导航组件 - NavBar</strong></p><ol><li>这个组件分成三块区域：左边-中间-右边，每块区域的内容是不固定；</li><li>左边区域可能显示一个菜单图标，也可能显示一个返回按钮，可能什么都不显示；</li><li>中间区域可能显示一个搜索框，也可能是一个列表，也可能是一个标题，等等；</li><li>右边可能是一个文字，也可能是一个图标，也可能什么都不显示；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810091923684.png" alt="image-20210810091923684"></p><h3 id="如何使用插槽-slot？"><a href="#如何使用插槽-slot？" class="headerlink" title="如何使用插槽 slot？"></a>如何使用插槽 slot？</h3><p><strong>这个时候我们就可以来定义插槽 slot：</strong></p><ol><li>插槽的使用过程其实是抽取共性、预留不同；</li><li>我们会将共同的元素、内容依然在组件内进行封装；</li><li>同时会将不同的元素使用 slot 作为占位，让外部决定到底显示什么样的元素；</li></ol><p><strong>如何使用 slot 呢？</strong></p><ol><li>Vue 中将<code>&lt;slot&gt;</code> 元素作为承载分发内容的出口；</li><li>在封装组件中，使用特殊的元素<code>&lt;slot&gt;</code>就可以为封装组件开启一个插槽；</li><li>该插槽<strong>插入什么内容</strong>取决于父组件如何使用；</li></ol><h3 id="插槽的基本使用"><a href="#插槽的基本使用" class="headerlink" title="插槽的基本使用"></a>插槽的基本使用</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>我们一个组件 MySlotCpn.vue：该组件中有一个插槽，我们可以在插槽中放入需要显示的内容；</p><p>我们在 App.vue 中使用它们：我们可以插入普通的内容、html 元素、组件元素，都可以是可以的；</p><p><strong>预留的插槽我们不填充任何数据时：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810095927253.png" alt="image-20210810095927253"></p><p><strong>使用组件时往插槽插入数据：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810100208843.png" alt="image-20210810100208843"></p><p><strong>往组件插槽中填充自定义组件：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810100931706.png" alt="image-20210810100931706"></p><h4 id="插槽的默认内容"><a href="#插槽的默认内容" class="headerlink" title="插槽的默认内容"></a>插槽的默认内容</h4><p>有时候我们希望在使用插槽时，如果没有插入对应的内容，那么我们需要显示一个<strong>默认的内容</strong>：</p><p>当然这个默认的内容只会在没有提供插入的内容时，才会显示；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810101443748.png" alt="image-20210810101443748"></p><h4 id="多个插槽的效果"><a href="#多个插槽的效果" class="headerlink" title="多个插槽的效果"></a>多个插槽的效果</h4><p>我们先测试一个知识点：如果一个组件中含有<strong>多个插槽</strong>，我们插入多个内容时是什么效果？</p><p>我们会发现默认情况下每个插槽都会获取到我们插入的内容来显示；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810104919157.png" alt="image-20210810104919157"></p><h4 id="具名插槽的使用"><a href="#具名插槽的使用" class="headerlink" title="具名插槽的使用"></a>具名插槽的使用</h4><p>事实上，我们希望达到的效果是插槽对应的显示，这个时候我们就可以使用 具名插槽：</p><ol><li>具名插槽顾名思义就是给插槽起一个名字，<code>&lt;slot&gt;</code> 元素有一个特殊的 <strong>attribute：name；</strong></li><li>一个<strong>不带 name</strong> 的 slot，会带有隐含的名字 default；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810112506472.png" alt="image-20210810112506472"></p><h4 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h4><p><strong>什么是动态插槽名呢？</strong></p><ol><li>目前我们使用的插槽名称都是固定的；</li><li>比如 v-slot:left、v-slot:center 等等；</li><li>我们可以通过 v-slot:[dynamicSlotName]方式动态绑定一个名称；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810113654563.png" alt="image-20210810113654563"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810113842773.png" alt="image-20210810113842773"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810113909486.png" alt="image-20210810113909486"></p><h4 id="具名插槽使用的时候缩写"><a href="#具名插槽使用的时候缩写" class="headerlink" title="具名插槽使用的时候缩写"></a>具名插槽使用的时候缩写</h4><p><strong>具名插槽使用的时候缩写：</strong></p><ol><li>跟 <strong>v-on 和 v-bind</strong> 一样，<strong>v-slot</strong> 也有缩写；</li><li>即把参数之前的所有内容 <strong>(v-slot:)</strong> 替换为字符 **#**；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810130048326.png" alt="image-20210810130048326"></p><h2 id="渲染作用域"><a href="#渲染作用域" class="headerlink" title="渲染作用域"></a>渲染作用域</h2><p><strong>在 Vue 中有渲染作用域的概念：</strong></p><ol><li>父级模板里的所有内容都是在<strong>父级作用域</strong>中编译的；</li><li>子模板里的所有内容都是在<strong>子作用域中编译</strong>的；</li></ol><p>如何理解这句话呢？我们来看一个案例：</p><ol><li>在我们的案例中 ChildCpn 自然是可以让问自己作用域中的 title 内容的；</li><li>但是在 App 中，是访问不了 ChildCpn 中的内容的，因为它们是跨作用域的访问；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810131433831.png" alt="image-20210810131433831"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810131437971.png" alt="image-20210810131437971"></p><h3 id="认识作用域插槽"><a href="#认识作用域插槽" class="headerlink" title="认识作用域插槽"></a>认识作用域插槽</h3><p><strong>但是有时候我们希望插槽可以访问到子组件中的内容是非常重要的：</strong></p><ol><li>当一个组件被用来渲染一个数组元素时，我们使用插槽，并且希望插槽中没有显示每项的内容；</li><li>这个 Vue 给我们提供了作用域插槽；</li></ol><p><strong>我们来看下面的一个案例：</strong></p><ol><li>在 App.vue 中定义好数据</li><li>传递给 ShowNames 组件中</li><li>ShowNames 组件中遍历 names 数据</li><li>定义插槽的 prop</li><li>通过 v-slot:default 的方式获取到 slot 的 props</li><li>使用 slotProps 中的 item 和 index</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810133254354.png" alt="image-20210810133254354"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810133335479.png" alt="image-20210810133335479"></p><p><strong>发现我们传递的标签不同，最后的显示效果就不同，甚至我们还可以控制那些数据显示，那些不显示</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810133425113.png" alt="image-20210810133425113"></p><h4 id="独占默认插槽的缩写"><a href="#独占默认插槽的缩写" class="headerlink" title="独占默认插槽的缩写"></a>独占默认插槽的缩写</h4><p>如果我们的插槽是默认插槽 default，那么在使用的时候 v-slot:default=”slotProps”可以简写为 v-slot=”slotProps”：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810134528571.png" alt="image-20210810134528571"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810134532181.png" alt="image-20210810134532181"></p><p>并且如果我们的插槽只有默认插槽时，组件的标签可以被当做插槽的模板来使用，这样，我们就可以将 <strong>v-slot</strong> 直 接用在组件上：</p><p><strong>这种写法是简写，可以不使用到 template 标签。但是有局限</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810134623858.png" alt="image-20210810134623858"></p><h4 id="默认插槽和具名插槽混合"><a href="#默认插槽和具名插槽混合" class="headerlink" title="默认插槽和具名插槽混合"></a>默认插槽和具名插槽混合</h4><p><strong>但是，如果我们有默认插槽和具名插槽，那么按照完整的 template 来编写。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810134955626.png" alt="image-20210810134955626"></p><p><strong>只要出现多个插槽，请始终为所有的插槽使用完整的基于 <code>&lt;template&gt;语法</code></strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210810135256596.png" alt="image-20210810135256596"></p><h1 id="Vue3-组件化开发-三-动态-异步组件-vue3-生命周期"><a href="#Vue3-组件化开发-三-动态-异步组件-vue3-生命周期" class="headerlink" title="Vue3 组件化开发(三)-动态/异步组件-vue3 生命周期"></a>Vue3 组件化开发(三)-动态/异步组件-vue3 生命周期</h1><h2 id="切换组件案例"><a href="#切换组件案例" class="headerlink" title="切换组件案例"></a>切换组件案例</h2><p><strong>比如我们现在想要实现了一个功能：</strong></p><p>点击一个 tab-bar，切换不同的组件显示；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210811211016025.png" alt="image-20210811211016025"></p><p><strong>这个案例我们可以通过两种不同的实现思路来实现：</strong></p><ol><li>方式一：通过<strong>v-if</strong>来判断，显示不同的组件；</li><li>方式二：<strong>动态组件</strong>的方式；</li><li>方式三：<strong>路由实现</strong>（日后学到再说）</li></ol><h3 id="v-if-实现"><a href="#v-if-实现" class="headerlink" title="v-if 实现"></a>v-if 实现</h3><p>我们可以先通过 v-if 来判断显示不同的组件，这个可以使用我们之前讲过的知识来实现：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210811211229950.png" alt="image-20210811211229950"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210811211332131.png" alt="image-20210811211332131"></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div&gt;    &lt;button      :key="item"      v-for="item in tabs"      :class="{ active: currentTab === item }"      @click="toggle(item)"    &gt;      {{ item }}    &lt;/button&gt;    &lt;template v-if="currentTab === 'home'"&gt;      &lt;home&gt;&lt;/home&gt;    &lt;/template&gt;    &lt;template v-if="currentTab === 'about'"&gt;      &lt;about&gt;&lt;/about&gt;    &lt;/template&gt;    &lt;template v-if="currentTab === 'category'"&gt;      &lt;category&gt;&lt;/category&gt;    &lt;/template&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import About from "./page/About.vue";import Category from "./page/Category.vue";import Home from "./page/Home.vue";export default {  components: {    Home,    About,    Category,  },  data() {    return {      tabs: ["home", "about", "category"],      currentTab: "home",    };  },  methods: {    toggle(item) {      this.currentTab = item;    },  },};&lt;/script&gt;&lt;style scoped&gt;.active {  background-color: #aca;  color: aqua;}button {  font-size: 20px;}&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>效果</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210811211416362.png" alt="image-20210811211416362"></p><h3 id="动态组件实现"><a href="#动态组件实现" class="headerlink" title="动态组件实现"></a>动态组件实现</h3><p>动态组件是使用 <strong>component</strong> 组件，通过一个特殊的 attribute <strong>is</strong> 来实现：</p><p><strong>component：</strong> Vue 的内置组件，根据属性 is 的值，来决定那个组件被选渲染。<code>is</code> 的值是一个字符串，它既可以是 HTML 标签名称也可以是组件名称。<strong>如果你传递组件本身到 <code>is</code> 而不是其名字，则不需要注册。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210811212012331.png" alt="image-20210811212012331"></p><p><strong>这个 currentTab 的值需要是什么内容呢？</strong></p><ol><li>可以是通过 component 函数注册的组件；</li><li>在一个组件对象的 components 对象中注册的组件；</li></ol><h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><h3 id="动态组件的传值"><a href="#动态组件的传值" class="headerlink" title="动态组件的传值"></a>动态组件的传值</h3><p><strong>如果是动态组件我们可以给它们传值和监听事件吗？</strong></p><ol><li>也是一样的；</li><li>只是我们需要将属性和监听事件放到 component 上来使用；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210811214920431.png" alt="image-20210811214920431"></p><h2 id="Keep-alive"><a href="#Keep-alive" class="headerlink" title="Keep-alive"></a>Keep-alive</h2><h3 id="认识-keep-alive"><a href="#认识-keep-alive" class="headerlink" title="认识 keep-alive"></a>认识 keep-alive</h3><p><strong>我们先对之前的案例中 About 组件进行改造：</strong></p><p>在其中增加了一个按钮，点击可以递增的功能；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210811220635353.png" alt="image-20210811220635353"></p><p>比如我们将 counter 点到 10，那么在切换到 home 再切换回来 about 时，状态是否<strong>可以保持</strong>呢？</p><ol><li>答案是否定的；</li><li>这是因为默认情况下，我们在切换组件后，about 组件会被销毁掉，再次回来时会重新创建组件；</li></ol><p>但是，在开发中某些情况我们希望<strong>继续保持组件的状态</strong>，而不是销毁掉，这个时候我们就可以使用一个<strong>内置组件</strong>：<strong>keep-alive。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210811221617535.png" alt="image-20210811221617535"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210811221725646.png" alt="image-20210811221725646"></p><p><strong>的确记录了组件所处的状态。</strong></p><h3 id="keep-alive-属性"><a href="#keep-alive-属性" class="headerlink" title="keep-alive 属性"></a>keep-alive 属性</h3><p><strong>keep-alive 有一些属性：</strong></p><ol><li><strong>include</strong> - string | RegExp | Array。只有名称匹配的组件会被缓 存；</li><li><strong>exclude</strong> - string | RegExp | Array。任何名称匹配的组件都不 会被缓存；</li><li><strong>max</strong> - number | string。最多可以缓存多少组件实例，一旦达 到这个数字，那么缓存组件中最近没有被访问的实例会被销毁；</li></ol><p><strong>include 和 exclude prop 允许组件有条件地缓存：</strong></p><ol><li>二者都可以用逗号分隔字符串、正则表达式或一个数组来表示；</li><li>匹配首先检查组件自身的 name 选项；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812090809195.png" alt="image-20210812090809195"></p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 内置组件 keep-alive的使用，    记录组件的状态，切换时不会被销毁 --&gt;&lt;!-- 在 keep-alive 这个组件内，    不要使用注释：不然会报警告，而且也不能记录组件的状态了 --&gt;&lt;!-- include="组件里面的name属性的值，    推荐每个组件都加上name属性，和data同级，多个组件名称逗号分隔    中间不要有空格" --&gt;&lt;!-- include="about,home" v-bind:include="/正则表达式/" --&gt;&lt;!-- include="数组" --&gt;&lt;keep-alive include="about"&gt;      &lt;component :is="currentTab" :name="'毛毛'"       :age="22" @pageClick="click"&gt;&lt;/component&gt;    &lt;/keep-alive&gt;&lt;!-- 排除缓存，这个属性匹配到的都不会被缓存 --&gt;&lt;!-- exclude的用法同上 --&gt;&lt;keep-alive exclude="about"&gt;      &lt;component :is="currentTab" :name="'毛毛'"       :age="22" @pageClick="click"&gt;&lt;/component&gt;    &lt;/keep-alive&gt;&lt;!-- 最大缓存数量，是一个数字，也可以写字符串 --&gt;&lt;!-- 会清除缓存列表中，最长时间没有被访问的那个组件 --&gt;&lt;keep-alive max="2"&gt;      &lt;component :is="currentTab" :name="'毛毛'"       :age="22" @pageClick="click"&gt;&lt;/component&gt;    &lt;/keep-alive&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="缓存组件的生命周期"><a href="#缓存组件的生命周期" class="headerlink" title="缓存组件的生命周期"></a>缓存组件的生命周期</h3><p>对于缓存的组件来说，再次进入时，我们是不会执行<strong>created</strong>或者<strong>mounted</strong>等生命周期函数的：</p><ol><li>但是有时候我们确实希望监听到何时重新进入到了组件，何时离开了组件；</li><li>这个时候我们可以使用 activated 和 deactivated 这两个生命周期钩子函数来监听；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812143746757.png" alt="image-20210812143746757"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812143904102.png" alt="image-20210812143904102"></p><h2 id="Webpack5-打包"><a href="#Webpack5-打包" class="headerlink" title="Webpack5 打包"></a>Webpack5 打包</h2><h3 id="Webpack-的代码分包"><a href="#Webpack-的代码分包" class="headerlink" title="Webpack 的代码分包"></a>Webpack 的代码分包</h3><p><strong>默认的打包过程：</strong></p><p>默认情况下，在构建整个组件树的过程中，因为<strong>组件和组件之间是通过模块化直接依赖的</strong>，那么<strong>webpack 在打包</strong>时就会将组 件模块打包到一起（比如一个<strong>app.js</strong>文件中）；</p><p>这个时候随着项目的不断庞大，app.js 文件的内容过大，会造成<strong>首屏的</strong>渲染速度变慢；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812093141976.png" alt="image-20210812093141976"></p><p><strong>打包时，代码的分包：</strong></p><ol><li>所以，对于一些不需要立即使用的组件，我们可以单独对它们进行拆分，拆分成一些小的代码块 chunk.js；</li><li>这些 chunk.js 会在需要时从服务器加载下来，并且运行代码，显示对应的内容；</li></ol><p><strong>那么 webpack 中如何可以对代码进行分包呢？</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812093944480.png" alt="image-20210812093944480"></p><h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><h3 id="Vue-中实现异步组件"><a href="#Vue-中实现异步组件" class="headerlink" title="Vue 中实现异步组件"></a>Vue 中实现异步组件</h3><p>如果我们的项目过大了，对于<strong>某些组件我们希望通过异步的方式来进行加载</strong>（目的是可以对其进行<strong>分包处理</strong>），那 么 Vue 中给我们提供了一个函数：<strong>defineAsyncComponent</strong>。</p><p><strong>defineAsyncComponent 接受两种类型的参数：</strong></p><ol><li>类型一：工厂函数，该工厂函数需要返回一个 Promise 对象；</li><li>类型二：接受一个对象类型，对异步函数进行配置；</li></ol><h4 id="工厂函数类型一的写法"><a href="#工厂函数类型一的写法" class="headerlink" title="工厂函数类型一的写法"></a>工厂函数类型一的写法</h4><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812095742723.png" alt="image-20210812095742723"></p><h4 id="异步组件对象类型写法"><a href="#异步组件对象类型写法" class="headerlink" title="异步组件对象类型写法"></a>异步组件对象类型写法</h4><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812100721257.png" alt="image-20210812100721257"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// import AsyncCategory from './AsyncCategory.vue'</span><span class="token comment">// 打包组件时也进行分包，需要使用vue3中提供好的一个函数</span><span class="token comment">// defineAsyncComponent</span><span class="token keyword">import</span> <span class="token punctuation">{</span> defineAsyncComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token comment">// 现在这个组件 AsyncCategory 就变成异步组件了，组件的使用和注册还是和以前一样</span><span class="token comment">// const AsyncCategory =</span><span class="token comment">//   defineAsyncComponent(() =&gt; import('./AsyncCategory.vue'));</span><span class="token keyword">const</span> AsyncCategory <span class="token operator">=</span> <span class="token function">defineAsyncComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token comment">// 工厂函数，只有这一个参数时，和上个写法没有区别</span>  <span class="token function-variable function">loader</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"./AsyncCategory.vue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 加载过程中显示的组件，当真正的组件加载完毕时会进行切换</span>  loadingComponent<span class="token operator">:</span> Loading<span class="token punctuation">,</span>  <span class="token comment">// 加载失败时显示的组件</span>  errorComponent<span class="token operator">:</span> ErrorCmp<span class="token punctuation">,</span>  <span class="token comment">// 在显示 loadingComponent 组件之前的延迟，默认值是200 单位ms</span>  <span class="token comment">// 只有指定时长没有加载完毕我们loader指定的组件，才会显示 loadingComponent</span>  delay<span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">,</span>  <span class="token comment">// timeout 超时时间，超过了指定时间没有加载完毕指定组件</span>  <span class="token comment">// 则会显示错误组件，默认值 Infinity 不超时</span>  timeout<span class="token operator">:</span> <span class="token number">Infinity</span><span class="token punctuation">,</span>  <span class="token comment">// 组件是否可以挂起 默认值 true</span>  suspensible<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token comment">// onError 监听组件是否发生错误</span>  <span class="token comment">/*   err: 错误信息  retry: 一个函数，调用该函数则进行重新加载  fail: 一个函数 允许加载程序结束退出（类似于强制结束）  attempts: 重试次数  */</span>  <span class="token function-variable function">onError</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> retry<span class="token punctuation">,</span> fail<span class="token punctuation">,</span> attempts</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  components<span class="token operator">:</span> <span class="token punctuation">{</span> AsyncCategory <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="异步组件和-Suspense"><a href="#异步组件和-Suspense" class="headerlink" title="异步组件和 Suspense"></a>异步组件和 Suspense</h3><h4 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h4><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812102407747.png" alt="image-20210812102407747"></p><p><strong>目前：Suspense 显示的是一个实验性的特性，API 随时可能会修改。</strong></p><p><strong>Suspense 是一个内置的全局组件，该组件有两个插槽：</strong></p><ol><li>default：如果 default 可以显示，那么显示 default 的内容；</li><li>fallback：如果 default 无法显示，那么会显示 fallback 插槽的内容；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812103328161.png" alt="image-20210812103328161"></p><h2 id="引用元素和组件"><a href="#引用元素和组件" class="headerlink" title="$引用元素和组件"></a>$引用元素和组件</h2><h3 id="refs-的使用"><a href="#refs-的使用" class="headerlink" title="$refs 的使用"></a>$refs 的使用</h3><p><strong>某些情况下，我们在组件中想要直接获取到元素对象或者子组件实例：</strong></p><ol><li>在 Vue 开发中我们是不推荐进行 DOM 操作的；</li><li>这个时候，我们可以给元素或者组件绑定一个 ref 的 attribute 属性；</li></ol><p><strong>组件实例有一个$refs 属性：</strong></p><p>它一个对象 Object，持有注册过 <strong>ref attribute</strong> 的所有 DOM 元素和组件实例</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812111727677.png" alt="image-20210812111727677"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812112214446.png" alt="image-20210812112214446"></p><h3 id="parent和-root"><a href="#parent和-root" class="headerlink" title="$parent和$root"></a>$parent和$root</h3><p><strong>我们可以通过$parent 来访问父元素。</strong></p><p>HelloWorld.vue 的实现：</p><p>这里我们也可以<strong>通过$root</strong>来实现，因为 App 是我们的根组件；</p><p>注意：在<strong>Vue3</strong>中已经<strong>移除了$children 的</strong>属性，所以不可以使用了。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812112904661.png" alt="image-20210812112904661"></p><h3 id="el"><a href="#el" class="headerlink" title="$el"></a>$el</h3><p><strong>可以拿到根元素，就是使用本组件的根 DOM 元素。但是不能操作</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812113751687.png" alt="image-20210812113751687"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812113837138.png" alt="image-20210812113837138"></p><p><strong>实际上拿到的就是自己，组件本质上也是一个个的 html，dom 元素，根元素就是本组件的的根元素</strong></p><p><strong>如果本组件出现了多个根标签，比如：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812114118598.png" alt="image-20210812114118598"></p><p><strong>我们不使用 div 进行包裹，那么，获取的值$el 获取的值又会不同</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812114217105.png" alt="image-20210812114217105"></p><p><strong>vue3 已经可以不使用单个根标签了。但是本质上还是被一个其他标签进行了包裹的。</strong></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="认识生命周期"><a href="#认识生命周期" class="headerlink" title="认识生命周期"></a>认识生命周期</h3><p><strong>什么是生命周期呢？</strong></p><ol><li>每个组件都可能会经历从<strong>创建、挂载、更新、卸载</strong>等一系列的过程；</li><li>在这个过程中的某一个阶段，用于可能会想要<strong>添加一些属于自己的代码逻辑</strong>（比如组件创建完后就请求一些服 务器数据）；</li><li>但是我们如何可以知道目前组件正在哪一个过程呢？Vue 给我们提供了组件的<strong>生命周期函数</strong></li></ol><p><strong>生命周期函数：</strong></p><ol><li><strong>生命周期函数是一些钩子函数</strong>，在某个时间会被<strong>Vue 源码内部进行回调；</strong></li><li>通过<strong>对生命周期函数的回调</strong>，我们可以知道<strong>目前组件正在经历什么阶段</strong>；</li><li>那么我们就可以在该生命周期中编写<strong>属于自己的逻辑代码</strong>了；</li></ol><h3 id="生命周期的流程"><a href="#生命周期的流程" class="headerlink" title="生命周期的流程"></a>生命周期的流程</h3><p><a href="https://v3.cn.vuejs.org/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">生命周期图</a></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812134823543.png" alt="image-20210812134823543"></p><h2 id="组件的-v-model"><a href="#组件的-v-model" class="headerlink" title="组件的 v-model"></a>组件的 v-model</h2><h3 id="组件-v-model-的实现"><a href="#组件-v-model-的实现" class="headerlink" title="组件 v-model 的实现"></a>组件 v-model 的实现</h3><p><strong>那么，为了我们的 MyInput 组件可以正常的工作，这个组件内的 <input> 必须：</strong></p><ol><li>将其 value attribute 绑定到一个名叫 <strong>modelValue</strong> 的 prop 上；</li><li>在其 input 事件被触发时，将新的值通过自定义的 <strong>update:modelValue</strong> 事件抛出；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812145850159.png" alt="image-20210812145850159"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812145956762.png" alt="image-20210812145956762"></p><p><strong>如果我们直接在组件内部使用 v-model 绑定外界传进来的属性值来进行双向绑定会怎么样呢？首先这种做法不可取，其次也不会影响到外界的值</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812150633849.png" alt="image-20210812150633849"></p><h3 id="computed-实现"><a href="#computed-实现" class="headerlink" title="computed 实现"></a>computed 实现</h3><p>我们依然希望在组件内部按照双向绑定的做法去完成，应该如何操作呢？我们可以使用<strong>计算属性的 setter 和 getter 来完成。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812151236189.png" alt="image-20210812151236189"></p><h3 id="绑定多个属性"><a href="#绑定多个属性" class="headerlink" title="绑定多个属性"></a>绑定多个属性</h3><p>我们现在通过 v-model 是直接绑定了一个属性，如果我们<strong>希望绑定多个属性呢？</strong></p><ol><li>也就是我们希望在一个组件上使用<strong>多个 v-model 是否可以实现</strong>呢？</li><li>我们知道，默认情况下的 v-model 其实是绑定了 <strong>modelValue</strong> 属性和 <strong>@update:modelValue</strong>的事件；</li><li>如果我们希望绑定更多，可以给<strong>v-model 传入一个参数</strong>，那么这个参数的名称就是<strong>我们绑定属性的名称</strong>；</li></ol><p><strong>注意：这里我是绑定了两个属性的</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812152740822.png" alt="image-20210812152740822"></p><p><strong>v-model:age 相当于做了两件事：</strong></p><ol><li><strong>绑定了 age 属性；</strong></li><li><strong>监听了 @update:age 的事件；</strong></li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812153016033.png" alt="image-20210812153016033"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210812153035830.png" alt="image-20210812153035830"></p><h1 id="Vue3-过渡-amp-动画实现"><a href="#Vue3-过渡-amp-动画实现" class="headerlink" title="Vue3 过渡&amp;动画实现"></a>Vue3 过渡&amp;动画实现</h1><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h3 id="认识动画"><a href="#认识动画" class="headerlink" title="认识动画"></a>认识动画</h3><p>在开发中，我们想要给一个组件的显示和消失添加某种<strong>过渡动画</strong>，可以很好的<strong>增加用户体验</strong>：</p><ol><li>React 框架本身并没有提供任何动画相关的 API，所以在 React 中使用过渡动画我们需要使用一个第三方库 react-transition-group；</li><li>Vue 中为我们提供一些内置组件和对应的 API 来完成动画，利用它们我们可以方便的实现过渡动画效果；</li></ol><p><strong>我们来看一个案例：</strong></p><p>Hello World 的显示和隐藏；</p><p>通过下面的代码实现，是不会有任何动画效果的；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210813163332445.png" alt="image-20210813163332445"></p><hr><p><strong>没有动画的情况下，整个内容的显示和隐藏会非常的生硬：</strong></p><p>如果我们希望给单元素或者组件实现过渡动画，可以使用 <strong>transition</strong> 内置组件来完成动画；</p><h3 id="Vue-的-transition-动画"><a href="#Vue-的-transition-动画" class="headerlink" title="Vue 的 transition 动画"></a>Vue 的 transition 动画</h3><p><strong>Vue 提供了 transition 的封装组件</strong>，在下列情形中，可以给任何元素和组件添加进入/离开过渡：</p><ol><li><strong>p 条件渲染 (使用 v-if)条件展示 (使用 v-show)</strong></li><li><strong>动态组件</strong></li><li><strong>组件根节点</strong></li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210813164522866.png" alt="image-20210813164522866"></p><h3 id="Transition-组件的原理"><a href="#Transition-组件的原理" class="headerlink" title="Transition 组件的原理"></a>Transition 组件的原理</h3><p><strong>我们会发现，Vue 自动给 h2 元素添加了动画，这是什么原因呢？</strong></p><p><strong>当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理：</strong></p><ol><li>自动<strong>嗅探</strong>目标元素是否<strong>应用了 CSS 过渡或者动画</strong>，如果有，那么在恰当的时机<strong>添加/删除 CSS 类名</strong>；</li><li>如果 <strong>transition</strong> 组件提供了<strong>JavaScript 钩子函数</strong>，这些钩子函数将在恰当的时机被调用；</li><li>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，<strong>DOM 插入、删除操作将会立即执行；</strong></li></ol><p><strong>那么都会添加或者删除哪些 class 呢？</strong></p><h3 id="过渡动画-class"><a href="#过渡动画-class" class="headerlink" title="过渡动画 class"></a>过渡动画 class</h3><p><strong>我们会发现上面提到了很多个 class，事实上 Vue 就是帮助我们在这些 class 之间来回切换完成的动画：</strong></p><ol><li> <strong>v-enter-from：</strong>定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li><li> <strong>v-enter-active：</strong>定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动 画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li><li> <strong>v-enter-to：</strong>定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter-from 被移除)，在过渡/ 动画完成之后移除。</li><li> <strong>v-leave-from：</strong>定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li><li> <strong>v-leave-active：</strong>定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在 过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li><li> <strong>v-leave-to：</strong>离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave-from 被删除)，在过渡/ 动画完成之后移除。</li></ol><h4 id="class-添加的时机和命名规则"><a href="#class-添加的时机和命名规则" class="headerlink" title="class 添加的时机和命名规则"></a>class 添加的时机和命名规则</h4><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210813171422027.png" alt="image-20210813171422027"></p><p><strong>class 的 name 命名规则如下：</strong></p><ol><li>如果我们使用的是一个没有 name 的 transition，那么所有的 class 是以 v- 作为默认前缀；</li><li>如果我们添加了一个 name 属性，比如 ，那么所有的 class 会以 <strong>name 属性值-</strong> 开头；</li></ol><h4 id="过渡-css-动画"><a href="#过渡-css-动画" class="headerlink" title="过渡 css 动画"></a>过渡 css 动画</h4><p>前面我们是通过<strong>transition</strong>来实现的动画效果，另外我们也可以通过<strong>animation</strong>来实现。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210813174438158.png" alt="image-20210813174438158"></p><h4 id="同时设置过渡和动画"><a href="#同时设置过渡和动画" class="headerlink" title="同时设置过渡和动画"></a>同时设置过渡和动画</h4><p>Vue 为了知道过渡的完成，内部是在监听 transitionend 或 animationend，到底使用哪一个取决于元素应用的 CSS 规则：</p><p>如果我们只是使用了其中的一个，那么 Vue 能自动识别类型并设置监听；</p><p><strong>但是如果我们同时使用了过渡和动画呢？</strong></p><ol><li>并且在这个情况下可能某一个动画执行结束时，另外一个动画还没有结束；</li><li>在这种情况下，我们可以设置 type 属性为 animation 或者 transition 来明确的告知 Vue 监听的类型；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210813211840483.png" alt="image-20210813211840483"></p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.mydiv</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.mao-enter-from,.mao-leave-to</span> <span class="token punctuation">{</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.mao-enter-to,.mao-enter-from</span> <span class="token punctuation">{</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.mao-enter-active</span> <span class="token punctuation">{</span>  <span class="token property">animation</span><span class="token punctuation">:</span> bounce 2s ease<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.mao-leave-active</span> <span class="token punctuation">{</span>  <span class="token property">animation</span><span class="token punctuation">:</span> bounce 2s reverse<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.mao-enter-active,.mao-leave-active</span> <span class="token punctuation">{</span>  <span class="token property">transition</span><span class="token punctuation">:</span> opacity 1s ease<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 定义动画帧 */</span><span class="token atrule"><span class="token rule">@keyframes</span> bounce</span> <span class="token punctuation">{</span>  <span class="token selector">0%</span> <span class="token punctuation">{</span>    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector">50%</span> <span class="token punctuation">{</span>    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>1.5<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector">100%</span> <span class="token punctuation">{</span>    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="显示的指定动画时间"><a href="#显示的指定动画时间" class="headerlink" title="显示的指定动画时间"></a>显示的指定动画时间</h4><p>我们也可以显示的来指定过渡的时间，<strong>通过 duration 属性。</strong></p><p><strong>duration 可以设置两种类型的值：</strong></p><ol><li>number 类型：同时设置进入和离开的过渡时间；</li><li>object 类型：分别设置进入和离开的过渡时间；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210813212205061.png" alt="image-20210813212205061"></p><h4 id="过渡的模式-mode"><a href="#过渡的模式-mode" class="headerlink" title="过渡的模式 mode"></a>过渡的模式 mode</h4><p><strong>我们来看当前的动画在两个元素之间切换的时候存在的问题：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210813212531361.png" alt="image-20210813212531361"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210813212513947.png" alt="image-20210813212513947"></p><p>我们会发现 <strong>两个元素的动画是同时存在的</strong>：</p><ol><li>这是因为默认情况下进入和离开动画是同时发生的；</li><li>如果确实我们希望达到这个的效果，那么是没有问题；</li></ol><p>但是如果我们<strong>不希望同时执行进入和离开动画</strong>，那么我们需要设置 t<strong>ransition 的过渡模式：</strong></p><ol><li><strong>in-out:</strong> 新元素先进行过渡，完成之后当前元素过渡离开；</li><li><strong>out-in:</strong> 当前元素先进行过渡，完成之后新元素过渡进入；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210813213053898.png" alt="image-20210813213053898"></p><h3 id="动态组件的切换"><a href="#动态组件的切换" class="headerlink" title="动态组件的切换"></a>动态组件的切换</h3><h4 id="动态组件的切换动画"><a href="#动态组件的切换动画" class="headerlink" title="动态组件的切换动画"></a>动态组件的切换动画</h4><p><strong>上面的示例同样适用于我们的动态组件：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210813214234810.png" alt="image-20210813214234810"></p><h4 id="appear-初次渲染"><a href="#appear-初次渲染" class="headerlink" title="appear 初次渲染"></a>appear 初次渲染</h4><p>默认情况下，<strong>首次渲染的时候是没有动画的</strong>，如果我们希望给他添加上去动画，那么就可以增加另外一个属性 <strong>appear</strong>：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210813214335867.png" alt="image-20210813214335867"></p><h3 id="第三方动画库"><a href="#第三方动画库" class="headerlink" title="第三方动画库"></a>第三方动画库</h3><h4 id="认识-animate-css"><a href="#认识-animate-css" class="headerlink" title="认识 animate.css"></a>认识 animate.css</h4><p>如果我们手动一个个来编写这些动画，那么效率是比较低的，所以在开发中我们可能会<strong>引用一些第三方库的动画库， 比如 animate.css。</strong></p><p><strong>什么是 animate.css 呢？</strong></p><p><strong>Animate.css</strong> is a library of ready-to-use, cross-browser animations for use in your web projects. Great for emphasis, home pages, sliders, and attention-guiding hints.</p><p><strong>Animate.css</strong>是一个已经准备好的、跨平台的动画库为我们的 web 项目，对于<strong>强调、主页、滑动、注意力引导</strong> 非常有用；</p><p><strong>如何使用 Animate 库呢？</strong></p><ol><li>第一步：需要安装 animate.css 库；</li><li>第二步：导入 animate.css 库的样式；</li><li>第三步：使用 animation 动画或者 animate 提供的类；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814094340607.png" alt="image-20210814094340607"></p><h4 id="自定义过渡-class"><a href="#自定义过渡-class" class="headerlink" title="自定义过渡 class"></a>自定义过渡 class</h4><p><strong>我们可以通过以下 attribute 来自定义过渡类名：</strong></p><ol><li>enter-from-class</li><li>enter-active-class</li><li>enter-to-class</li><li>leave-from-class</li><li>leave-active-class</li><li>leave-to-class</li></ol><p>他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 <strong>Animate.css</strong>. 结合使用十 分有用。</p><h4 id="animate-css-库的使用"><a href="#animate-css-库的使用" class="headerlink" title="animate.css 库的使用"></a>animate.css 库的使用</h4><p><strong>安装 animate.css：</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i animate.css --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>在 main.js 中导入 animate.css：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token string">"animate.css"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>接下来在使用的时候我们有两种用法：</strong></p><p>用法一：直接使用 animate 库中定义的 keyframes 动画；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814095212789.png" alt="image-20210814095212789"></p><p>用法二：直接使用 animate 库提供给我们的类；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814095242072.png" alt="image-20210814095242072"></p><h3 id="认识-gsap-库"><a href="#认识-gsap-库" class="headerlink" title="认识 gsap 库"></a>认识 gsap 库</h3><p>某些情况下我们希望通过 JavaScript 来实现一些动画的效果，这个时候我们可以选择使用 gsap 库来完成。</p><p><strong>什么是 gsap 呢？</strong></p><ol><li>GSAP 是 The GreenSock Animation Platform（GreenSock 动画平台）的缩写；</li><li>它可以通过 JavaScript 为 CSS 属性、SVG、Canvas 等设置动画，并且是浏览器兼容的；</li></ol><p><strong>这个库应该如何使用呢？</strong></p><ol><li>第一步：需要安装 gsap 库；</li><li>第二步：导入 gsap 库；</li><li>第三步：使用对应的 api 即可；</li></ol><p><strong>我们可以先安装一下 gsap 库：</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i gsap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="JavaScript-钩子"><a href="#JavaScript-钩子" class="headerlink" title="JavaScript 钩子"></a>JavaScript 钩子</h4><p>在使用动画之前，我们先来看一下<strong>transition</strong>组件给我们提供的<strong>JavaScript 钩子，</strong>这些钩子可以帮助我们监听动画执行到 什么阶段了。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814101138774.png" alt="image-20210814101138774"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814101157536.png" alt="image-20210814101157536"></p><p>当我们使用 JavaScript 来执行过渡动画时，需要<strong>进行 done 回调</strong>，否则它们将会被同步调用，过渡会立即完成。</p><p>添加 <strong>:css=”false”，</strong>也会让 <strong>Vue 会跳过 CSS 的检测</strong>，除了性能略高之外，这可以<strong>避免过渡过程中 CSS 规则的影响</strong>。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814101301362.png" alt="image-20210814101301362"></p><h4 id="gsap-库的使用"><a href="#gsap-库的使用" class="headerlink" title="gsap 库的使用"></a>gsap 库的使用</h4><p><strong>那么接下来我们就可以结合 gsap 库来完成动画效果：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814103331698.png" alt="image-20210814103331698"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814103336037.png" alt="image-20210814103336037"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814103339396.png" alt="image-20210814103339396"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814103400933.png" alt="image-20210814103400933"></p><h4 id="gsap-实现数字变化动画"><a href="#gsap-实现数字变化动画" class="headerlink" title="gsap 实现数字变化动画"></a>gsap 实现数字变化动画</h4><p>在一些项目中，我们会见到<strong>数字快速变化的动画效果</strong>，这个动画可以<strong>很容易通过 gsap 来实现：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814104630294.png" alt="image-20210814104630294"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814104646356.png" alt="image-20210814104646356"></p><h4 id="认识列表的过渡"><a href="#认识列表的过渡" class="headerlink" title="认识列表的过渡"></a>认识列表的过渡</h4><p>目前为止，过渡动画我们只要是<strong>针对单个元素或者组件</strong>的：</p><p>要么是单个节点； 要么是同一时间渲染多个节点中的一个；</p><p>那么如果希望渲染的是一个列表，并且<strong>该列表中添加删除数据也希望有动画执行</strong>呢？</p><p>这个时候我们要使用 <transition-group> 组件来完成；</transition-group></p><p><strong>使用<transition-group> 有如下的特点：</transition-group></strong></p><ol><li>默认情况下，它不会渲染一个元素的包裹器，但是你可以指定一个元素并以 tag attribute 进行渲染；</li><li>过渡模式 <strong>mode</strong> 不可用，因为我们不再相互切换特有的元素；</li><li>内部元素总是需要提供唯一的 key attribute 值；</li><li>CSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身；</li></ol><h4 id="列表过渡的基本使用"><a href="#列表过渡的基本使用" class="headerlink" title="列表过渡的基本使用"></a>列表过渡的基本使用</h4><p><strong>我们来做一个案例：</strong></p><p>案例是一列数字，可以继续添加或者删除数字；</p><p><strong>在添加和删除数字的过程中，对添加的或者移除的数字添加动画；</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814111215939.png" alt="image-20210814111215939"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814111236462.png" alt="image-20210814111236462"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814111344677.png" alt="image-20210814111344677"></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>addNum<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>添加数字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>delNum<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>删除数字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!-- 列表的过渡，使用该内置组件进行包裹 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition-group</span> <span class="token attr-name">tag</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>p<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mao<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>number in numbers<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>number<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{ number }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition-group</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token punctuation">{</span>        numbers<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        numberCounter<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token function">addNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// this.numbers.push(this.numberCounter++)</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>numbers<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">randomIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>numberCounter<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token function">delNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>numbers<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">randomIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token function">randomIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>numbers<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">  <span class="token selector">button</span> <span class="token punctuation">{</span>    <span class="token property">margin</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector">span</span> <span class="token punctuation">{</span>    <span class="token property">margin-right</span><span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>    <span class="token comment">/* 转为行内块元素 */</span>    <span class="token comment">/* 行内元素是不能改变宽高等 */</span>    <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector">.mao-enter-from,  .mao-leave-to</span> <span class="token punctuation">{</span>    <span class="token property">opacity</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateY</span><span class="token punctuation">(</span>30px<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector">.mao-enter-active,  .mao-leave-active</span> <span class="token punctuation">{</span>    <span class="token property">transition</span><span class="token punctuation">:</span> all 2s ease-in<span class="token punctuation">;</span>  <span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="列表过渡的移动动画"><a href="#列表过渡的移动动画" class="headerlink" title="列表过渡的移动动画"></a>列表过渡的移动动画</h4><p><strong>在上面的案例中虽然新增的或者删除的节点是有动画的，但是对于哪些其他需要移动的节点是没有动画的：</strong></p><ol><li>我们可以通过使用一个新增的 v-move 的 class 来完成动画；</li><li>它会在元素改变位置的过程中应用；</li><li>像之前的名字一样，我们可以通过 name 来自定义前缀；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814112549656.png" alt="image-20210814112549656"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814112553932.png" alt="image-20210814112553932"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814112658298.png" alt="image-20210814112658298"></p><h4 id="列表的交错过渡案例"><a href="#列表的交错过渡案例" class="headerlink" title="列表的交错过渡案例"></a>列表的交错过渡案例</h4><p><strong>我们来通过 gsap 的延迟 delay 属性，做一个交替消失的动画：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210814115410408.png" alt="image-20210814115410408"></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>keyword<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!-- 使用ul进行包裹动画的元素 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition-group</span>      <span class="token attr-name">tag</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ul<span class="token punctuation">"</span></span>      <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mao<span class="token punctuation">"</span></span>      <span class="token attr-name">@before-enter</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>beforeEnter<span class="token punctuation">"</span></span>      <span class="token attr-name">@enter</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enter<span class="token punctuation">"</span></span>      <span class="token attr-name">@leave</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>leave<span class="token punctuation">"</span></span>      <span class="token attr-name">:css</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span>    <span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(name,index) in showNames<span class="token punctuation">"</span></span> <span class="token attr-name">:data-index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        {{ name }}      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition-group</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">import</span> gsap <span class="token keyword">from</span> <span class="token string">"gsap"</span><span class="token punctuation">;</span>  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token punctuation">{</span>        keyword<span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        names<span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token string">"aaa"</span><span class="token punctuation">,</span>          <span class="token string">"avc"</span><span class="token punctuation">,</span>          <span class="token string">"read"</span><span class="token punctuation">,</span>          <span class="token string">"tre"</span><span class="token punctuation">,</span>          <span class="token string">"tres"</span><span class="token punctuation">,</span>          <span class="token string">"ttt"</span><span class="token punctuation">,</span>          <span class="token string">"www"</span><span class="token punctuation">,</span>          <span class="token string">"mao"</span><span class="token punctuation">,</span>          <span class="token string">"jjj"</span><span class="token punctuation">,</span>          <span class="token string">"gs"</span><span class="token punctuation">,</span>          <span class="token string">"gdj"</span><span class="token punctuation">,</span>          <span class="token string">"adssa"</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    computed<span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token function">showNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>names<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> name<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>keyword<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token comment">// 指定初始化的状态</span>      <span class="token function">beforeEnter</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>opaciy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token function">enter</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> done</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        gsap<span class="token punctuation">.</span><span class="token function">to</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token punctuation">{</span>          opacity<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>          height<span class="token operator">:</span> <span class="token string">"1.5em"</span><span class="token punctuation">,</span>          delay<span class="token operator">:</span> el<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>index <span class="token operator">*</span> <span class="token number">0.2</span><span class="token punctuation">,</span>          onComplete<span class="token operator">:</span> done<span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token function">leave</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> done</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        gsap<span class="token punctuation">.</span><span class="token function">to</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token punctuation">{</span>          opacity<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>          height<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>          delay<span class="token operator">:</span> el<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>index <span class="token operator">*</span> <span class="token number">0.2</span><span class="token punctuation">,</span>          onComplete<span class="token operator">:</span> done<span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">  <span class="token comment">/* .mao-enter-from,.mao-leave-to{    opacity: 0;  }  .mao-enter-to,.mao-leave-from{    opacity: 1;  }  .mao-enter-active,.mao-leave-active{    transition: opacity 2s ease;  } */</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> 组件化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> ts </tag>
            
            <tag> webpack </tag>
            
            <tag> 组件化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-router</title>
      <link href="/2021/11/03/src/vue/vue-router/"/>
      <url>/2021/11/03/src/vue/vue-router/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h1><h2 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h2><h3 id="认识前端路由"><a href="#认识前端路由" class="headerlink" title="认识前端路由"></a>认识前端路由</h3><p><strong>路由其实是网络工程中的一个术语：</strong></p><ul><li>在架构一个网络时，非常重要的两个设备就是路由器和交换机。</li><li>当然，目前在我们生活中路由器也是越来越被大家所熟知，因为我们生活中都会用到路由器：</li><li>事实上，路由器主要维护的是一个映射表；</li><li>映射表会决定数据的流向；</li></ul><p>路由的概念在软件工程中出现，最早是在后端路由中实现的，原因是 web 的发展主要经历了这样一些阶段：</p><ul><li>后端路由阶段；</li><li>前后端分离阶段；</li><li>单页面富应用（SPA）；</li></ul><h3 id="后端路由阶段"><a href="#后端路由阶段" class="headerlink" title="后端路由阶段"></a>后端路由阶段</h3><p>早期的网站开发整个 HTML 页面是由服务器来渲染的.。服务器直接生产渲染好对应的 HTML 页面, 返回给客户端进行展示.</p><p><strong>但是, 一个网站, 这么多页面服务器如何处理呢?</strong></p><ul><li>一个页面有自己对应的网址, 也就是 URL；</li><li>URL 会发送到服务器, 服务器会通过正则对该 URL 进行匹配, 并且最后交给一个 Controller 进行处理；</li><li>Controller 进行各种处理, 最终生成 HTML 或者数据, 返回给前端.</li></ul><p>上面的这种操作, 就是后端路由：</p><ul><li>当我们页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户端.</li><li>这种情况下渲染好的页面, 不需要单独加载任何的 js 和 css, 可以直接交给浏览器展示, 这样也有利于 SEO 的优化.</li></ul><p><strong>后端路由的缺点:</strong></p><ul><li>一种情况是整个页面的模块由后端人员来编写和维护的；</li><li>另一种情况是前端开发人员如果要开发页面, 需要通过 PHP 和 Java 等语言来编写页面代码；</li><li>而且通常情况下 HTML 代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情；</li></ul><h3 id="前后端分离阶段"><a href="#前后端分离阶段" class="headerlink" title="前后端分离阶段"></a>前后端分离阶段</h3><p><strong>前端渲染的理解：</strong></p><ul><li>每次请求涉及到的静态资源都会从静态资源服务器获取，这些资源包括 HTML+CSS+JS，然后在前端对这些请 求回来的资源进行渲染；</li><li>需要注意的是，客户端的每一次请求，都会从静态资源服务器请求文件；</li><li>同时可以看到，和之前的后端路由不同，这时后端只是负责提供 API 了；</li></ul><p><strong>前后端分离阶段：</strong></p><ul><li>随着 Ajax 的出现, 有了前后端分离的开发模式；</li><li>后端只提供 API 来返回数据，前端通过 Ajax 获取数据，并且可以通过 JavaScript 将数据渲染到页面中；</li><li>这样做最大的优点就是前后端责任的清晰，后端专注于数据上，前端专注于交互和可视化上；</li><li>并且当移动端(iOS/Android)出现后，后端不需要进行任何处理，依然使用之前的一套 API 即可；</li><li>目前比较少的网站采用这种模式开发（jQuery 开发模式）；</li></ul><h3 id="URL-的-hash"><a href="#URL-的-hash" class="headerlink" title="URL 的 hash"></a>URL 的 hash</h3><p>前端路由是如何做到 URL 和内容进行映射呢？监听 URL 的改变。</p><p><strong>URL 的 hash</strong></p><ul><li>URL 的 hash 也就是锚点(#), 本质上是改变 window.location 的 href 属性；</li><li>我们可以通过直接赋值 location.hash 来改变 href, 但是页面不发生刷新；</li></ul><p>hash 的优势就是兼容性更好，在老版 IE 中都可以运行，但是缺陷是有一个#，显得不像一个真实的路径。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#/home<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>home<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#/about<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>about<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>router-view<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">const</span> routerView <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#router-view"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// url的hash</span>  <span class="token comment">// URL的hash也就是锚点，本质上就是改变window.location 的 href 属性</span>  <span class="token comment">// 我们可以通过直接赋值location.hash 来改变 href 但是页面不会刷新</span>  window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"hashchange"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>location<span class="token punctuation">.</span>hash <span class="token operator">===</span> <span class="token string">"#/home"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      routerView<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"home"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>location<span class="token punctuation">.</span>hash <span class="token operator">===</span> <span class="token string">"#/about"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      routerView<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"about"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210829195623661.png" alt="image-20210829195623661"></p><h3 id="HTML5-的-History"><a href="#HTML5-的-History" class="headerlink" title="HTML5 的 History"></a>HTML5 的 History</h3><p>history 接口是 HTML5 新增的, 它有 l 六种模式改变 URL 而不刷新页面：</p><ul><li>replaceState：替换原来的路径；</li><li>pushState：使用新的路径；</li><li>popState：路径的回退；</li><li>go：向前或向后改变路径；</li><li>forward：向前改变路径；</li><li>back：向后改变路径；</li></ul><h4 id="HTML5-的-History-测试"><a href="#HTML5-的-History-测试" class="headerlink" title="HTML5 的 History 测试"></a>HTML5 的 History 测试</h4><h4 id="pushState"><a href="#pushState" class="headerlink" title="pushState"></a>pushState</h4><p><code>pushState()</code> 需要三个参数: 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个 URL. 让我们来解释下这三个参数详细内容：</p><ul><li><p><strong>状态对象</strong> — 状态对象 state 是一个 JavaScript 对象，通过 pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态，popstate 事件就会被触发，且该事件的 state 属性包含该历史记录条目状态对象的副本。</p><p>​ 状态对象可以是能被序列化的任何东西。原因在于 Firefox 将状态对象保存在用户的磁盘上，以便在用户重启浏览器时使用，我们规定了状态对象在序列化表示后有 640k 的大小限制。如果你给 <code>pushState()</code> 方法传了一个序列化后大于 640k 的状态对象，该方法会抛出异常。如果你需要更大的空间，建议使用 <code>sessionStorage</code> 以及 <code>localStorage</code>.</p></li><li><p><strong>标题</strong> — Firefox 目前忽略这个参数，但未来可能会用到。在此处传一个空字符串应该可以安全的防范未来这个方法的更改。或者，你可以为跳转的 state 传递一个短标题。</p></li><li><p><strong>URL</strong> — 该参数定义了新的历史 URL 记录。注意，调用 <code>pushState()</code> 后浏览器并不会立即加载这个 URL，但可能会在稍后某些情况下加载这个 URL，比如在用户重新打开浏览器时。新 URL 不必须为绝对路径。如果新 URL 是相对路径，那么它将被作为相对于当前 URL 处理。新 URL 必须与当前 URL 同源，否则 <code>pushState()</code> 会抛出一个异常。该参数是可选的，缺省为当前 URL。</p></li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>home<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>home<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>about<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>about<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>router-view<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">const</span> routerView <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#router-view"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">as</span> <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> arr <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">as</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    item<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// pushState() 需要三个参数: 一个状态对象,</span>      <span class="token comment">//  一个标题 (目前被忽略), 和 (可选的) 一个URL.</span>      <span class="token comment">//history.pushState({}, "", item.getAttribute("href"));</span>      history<span class="token punctuation">.</span><span class="token function">replaceState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> item<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"href"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">historyChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">historyChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// location.pathname 项目根路径开始的虚拟地址</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>pathname<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>pathname<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>location<span class="token punctuation">.</span>pathname<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>pathname<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">case</span> <span class="token string">"/home"</span><span class="token operator">:</span>        routerView<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"home"</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">case</span> <span class="token string">"/about"</span><span class="token operator">:</span>        routerView<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"about"</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">default</span><span class="token operator">:</span>        routerView<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"default"</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"popstate"</span><span class="token punctuation">,</span> historyChange<span class="token punctuation">)</span><span class="token punctuation">;</span>  window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"go"</span><span class="token punctuation">,</span> historyChange<span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h3 id="认识-vue-router"><a href="#认识-vue-router" class="headerlink" title="认识 vue-router"></a>认识 vue-router</h3><p><strong>目前前端流行的三大框架, 都有自己的路由实现:</strong></p><ul><li>Angular 的 ngRouter</li><li>React 的 ReactRouter</li><li>Vue 的 vue-router</li></ul><p>Vue Router 是 Vue.js 的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得非常容易。</p><p>目前 Vue 路由最新的版本是 4.x 版本.</p><p><strong>vue-router 是基于路由和组件的</strong></p><ul><li><p>路由用于设定访问路径, 将路径和组件映射起来.</p></li><li><p>在 vue-router 的单页面应用中, 页面的路径的改变就是组件的切换</p></li></ul><p><strong>安装 vue-router</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 安装 4.xnpm install vue-router@4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="路由的使用步骤"><a href="#路由的使用步骤" class="headerlink" title="路由的使用步骤"></a>路由的使用步骤</h3><p>使用 vue-router 的步骤:</p><ul><li>第一步：创建路由组件的组件；</li><li>第二步：配置路由映射: 组件和路径映射关系的 routes 数组；</li><li>第三步：通过 createRouter 创建路由对象，并且传入 routes 和 history 模式；</li><li>第四步：使用路由通过<code>&lt;router-link&gt;</code>和<code>&lt;router-view&gt;</code>；</li></ul><h3 id="路由的基本使用流程"><a href="#路由的基本使用流程" class="headerlink" title="路由的基本使用流程"></a>路由的基本使用流程</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 路由的配置规则</span><span class="token keyword">import</span> About <span class="token keyword">from</span> <span class="token string">"../pages/About.vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> Home <span class="token keyword">from</span> <span class="token string">"../pages/Home.vue"</span><span class="token punctuation">;</span><span class="token comment">// 导入vue-router</span><span class="token comment">// 导入创建路由对象的函数，以及路由方式的函数</span><span class="token keyword">import</span> <span class="token punctuation">{</span>  createRouter<span class="token punctuation">,</span>  createWebHistory<span class="token punctuation">,</span>  createWebHashHistory<span class="token punctuation">,</span><span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue-router"</span><span class="token punctuation">;</span><span class="token comment">// 路由规则,映射关系</span><span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">"/home"</span><span class="token punctuation">,</span> component<span class="token operator">:</span> Home <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">"/about"</span><span class="token punctuation">,</span> component<span class="token operator">:</span> About <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 路由对象，管理路由的映射</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token function">createRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">,</span>  <span class="token comment">// 指定路由使用的模式 这里指定使用history路由 不使用hash模式了</span>  <span class="token comment">//history: createWebHashHistory(),</span>  history<span class="token operator">:</span> <span class="token function">createWebHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 导出路由</span><span class="token keyword">export</span> <span class="token keyword">default</span> router<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210829213342670.png" alt="image-20210829213342670"></p><p>在浏览器输入地址/home</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210829213424691.png" alt="image-20210829213424691"></p><p>当然这样在地址栏输入地址是比较麻烦的。</p><p>所以我们可以使用<code>&lt;router-link&gt;</code>组件来进行路由的切换。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210829213928215.png" alt="image-20210829213928215"></p><h3 id="路由的默认路径"><a href="#路由的默认路径" class="headerlink" title="路由的默认路径"></a>路由的默认路径</h3><p>我们这里还有一个不太好的实现:</p><ul><li><p>默认情况下, 进入网站的首页, 我们希望渲染首页的内容；</p></li><li><p>但是我们的实现中, 默认没有显示首页组件, 必须让用户点击才可以；</p></li></ul><p>如何可以让路径默认跳到到首页, 并且<router-view>渲染首页组件呢?</router-view></p><p><strong>我们在 routes 中又配置了一个映射：</strong></p><ul><li>path 配置的是根路径: /</li><li>redirect 是重定向, 也就是我们将根路径重定向到/home 的路径下, 这样就可以得到我们想要的结果了</li></ul><p><strong>默认情况下，根路径没有匹配到组件。所以不会显示其他的组件。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210829214824036.png" alt="image-20210829214824036"></p><p><strong>这时，我们可以在路由规则中，配置一下根路径的重定向，让其重定向到/home 路径下。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210829214930953.png" alt="image-20210829214930953"></p><p>这样即使访问的是根路径，也会进行重定向到/home 这个路由。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210829215011288.png" alt="image-20210829215011288"></p><h3 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h3><p>上面的代码的测试，路径 URL 都是采用的 hash 模式。接下来我们将使用 history 模式。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210829215231161.png" alt="image-20210829215231161"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210829215301413.png" alt="image-20210829215301413"></p><p>这种地址看起来更加真实。</p><h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><p><strong>router-link 事实上有很多属性可以配置：</strong></p><ul><li><p>to 属性：</p><ul><li>是一个字符串，或者是一个对象</li></ul></li><li><p>replace 属性：</p><ul><li>设置 replace 属性的话，当点击时，会调用 router.replace()，而不是 router.push()；</li></ul></li><li><p>active-class 属性：</p><ul><li>设置激活 a 元素后应用的 class，默认是 router-link-active</li></ul></li><li><p>exact-active-class 属性：</p><ul><li>链接精准激活时，应用于渲染的 a 标签 的 class，默认是 router-link-exact-active；(<strong>路由嵌套的时候我们再说这个知识</strong>)</li></ul></li></ul><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- 路由的跳转 to属性的值就是我们要前往的地址 --&gt;</span>  <span class="token comment">&lt;!-- to属性 可以是字符串，直接表示路径地址，也可以是对象（暂时不管） --&gt;</span>  <span class="token comment">&lt;!-- replace 属性。    不设置该属性时：    默认情况下路由之间的切换，地址的变化是采用push的方式 history模式里面url的变化可以理解为pushState()    如果设置该属性时：    路由之间的切换以后，是不可以返回上一个路由的。    --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/home<span class="token punctuation">"</span></span> <span class="token attr-name">:replace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>首页home<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/about<span class="token punctuation">"</span></span> <span class="token attr-name">:replace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>关于about<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- 路由的占位符 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210829220319252.png" alt="image-20210829220319252"></p><p>一旦设置该属性，就不能进行路由的返回了。</p><h4 id="active-class、exact-active-class"><a href="#active-class、exact-active-class" class="headerlink" title="active-class、exact-active-class"></a>active-class、exact-active-class</h4><p>当我们点击某个<router-link>组件的时候，vue 会默认在上面添加两个 class 样式。类名默认是 router-link-active 和 router-link-exact-active</router-link></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210829220754248.png" alt="image-20210829220754248"></p><p><strong>激活的 router-link 具有某种样式，有助于我们进行设置。</strong>比如我们可以把激活的那个<router-link>组件的样式进行更改。</router-link></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210829221150533.png" alt="image-20210829221150533"></p><p>当然 active-class 属性可以修改激活路由具有的类名。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- 使用 active-class属性 可以设置当前路由被点击（选中）后的样式 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/home<span class="token punctuation">"</span></span> <span class="token attr-name">active-class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mao-active<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>首页home<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/about<span class="token punctuation">"</span></span> <span class="token attr-name">active-class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mao-active<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>关于about<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 路由的占位符 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210829222349258.png" alt="image-20210829222349258"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210829222411688.png" alt="image-20210829222411688"></p><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载：</p><ul><li>如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会 更加高效；</li><li>也可以提高首屏的渲染效率；</li></ul><p>其实这里还是我们前面讲到过的 webpack 的分包知识，而 Vue Router 默认就支持动态来导入组件：</p><ul><li>这是因为 component 可以传入一个组件，也可以接收一个函数，该函数 需要放回一个 Promise；</li><li>而 import 函数就是返回一个 Promise；</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 路由规则,映射关系</span><span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token comment">// { path: "/", component: Home },</span>  <span class="token comment">// 访问根路径的时候，进行路由的重定向 redirect</span>  <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">"/"</span><span class="token punctuation">,</span> redirect<span class="token operator">:</span> <span class="token string">"/home"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 路由的懒加载 实现懒加载 我们只需要让component属性的值设置为一个函数</span>  <span class="token comment">// 这个函数的返回值是一个promise对象，且也有这个路由匹配的组件</span>  <span class="token punctuation">{</span>    path<span class="token operator">:</span> <span class="token string">"/home"</span><span class="token punctuation">,</span>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      <span class="token comment">// 使用import函数加载文件</span>      <span class="token comment">// import函数的返回值本身就是一个promise对象</span>      <span class="token comment">// 当我们这样配置以后，在使用webpack打包的时候，会自动帮我们进行分包的操作</span>      <span class="token comment">// 只有用到这些组件的时候，或者说这些路由激活以后，</span>      <span class="token comment">// 才会发起请求获取对应的组件数据</span>      <span class="token keyword">return</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../pages/Home.vue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    path<span class="token operator">:</span> <span class="token string">"/about"</span><span class="token punctuation">,</span>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../pages/About.vue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="打包效果分析"><a href="#打包效果分析" class="headerlink" title="打包效果分析"></a>打包效果分析</h4><p>我们看一下打包后的效果：</p><p>我们会发现分包是没有一个很明确的名称的，其实 webpack 从 3.x 开始支持对分包进行命名（chunk name）：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token comment">// { path: "/", component: Home },</span>  <span class="token comment">// 访问根路径的时候，进行路由的重定向 redirect</span>  <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">"/"</span><span class="token punctuation">,</span> redirect<span class="token operator">:</span> <span class="token string">"/home"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 路由的懒加载 实现懒加载 我们只需要让component属性的值设置为一个函数</span>  <span class="token comment">// 这个函数的返回值是一个promise对象，且也有这个路由匹配的组件</span>  <span class="token punctuation">{</span>    path<span class="token operator">:</span> <span class="token string">"/home"</span><span class="token punctuation">,</span>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      <span class="token comment">// 使用import函数加载文件</span>      <span class="token comment">// import函数的返回值本身就是一个promise对象</span>      <span class="token comment">// 当我们这样配置以后，在使用webpack打包的时候，会自动帮我们进行分包的操作</span>      <span class="token comment">// 只有用到这些组件的时候，或者说这些路由激活以后，</span>      <span class="token comment">// 才会发起请求获取对应的组件数据</span>      <span class="token keyword">return</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName:"home-chunk" */</span> <span class="token string">"../pages/Home.vue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    path<span class="token operator">:</span> <span class="token string">"/about"</span><span class="token punctuation">,</span>    <span class="token comment">// TODO   webpack特性</span>    <span class="token comment">// 如果我们想在webpack打包的时候，</span>    <span class="token comment">// 给我们用到的分包管理的路由组件文件 起名字</span>    <span class="token comment">// 那么就用到了 魔法注释</span>    <span class="token comment">// 格式  /**/</span>    <span class="token comment">// 我们在import函数的括号前使用这个魔法注释</span>    <span class="token comment">// 这个注释会被webpack解析的，不能乱写</span>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>      <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName: "about-chunk" */</span> <span class="token string">"../pages/About.vue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>没有进行懒加载时的打包效果：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210829231647731.png" alt="image-20210829231647731"></p><p><strong>组件懒加载后的分包效果：（这里的分包我指定了名称，不使用魔法注释的话其实我们是无法分辨分出来的包对应哪一个文件）</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210829231727222.png" alt="image-20210829231727222"></p><h3 id="路由的其他属性"><a href="#路由的其他属性" class="headerlink" title="路由的其他属性"></a>路由的其他属性</h3><ul><li><p>name 属性：路由记录独一无二的名称；</p></li><li><p>meta 属性：自定义的数据</p></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    path<span class="token operator">:</span> <span class="token string">"/home"</span><span class="token punctuation">,</span>    <span class="token comment">// name 属性 给这个路由起名字 我们进行路由的跳转的时候</span>    <span class="token comment">// 也可以通过name属性的值 进行页面的跳转</span>    name<span class="token operator">:</span> <span class="token string">"home"</span><span class="token punctuation">,</span>    <span class="token comment">// 还可以使用 meta属性 配置一些元数据</span>    meta<span class="token operator">:</span> <span class="token punctuation">{</span>      name<span class="token operator">:</span> <span class="token string">"毛毛"</span><span class="token punctuation">,</span>      age<span class="token operator">:</span> <span class="token number">21</span><span class="token punctuation">,</span>      gender<span class="token operator">:</span> <span class="token string">"男"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName:"home-chunk" */</span><span class="token string">"../pages/Home.vue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><h4 id="动态路由基本匹配"><a href="#动态路由基本匹配" class="headerlink" title="动态路由基本匹配"></a>动态路由基本匹配</h4><p>很多时候我们需要将给定匹配模式的路由映射到同一个组件：</p><ul><li><p>例如，我们可能有一个 User 组件，它应该对所有用户进行渲染，但是用户的 ID 是不同的；</p></li><li><p>在 Vue Router 中，我们可以在路径中使用一个动态字段来实现，我们称之为 路径参数；</p></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 动态路由，有时候我们希望这个路由的路径不是写死的</span>  <span class="token comment">// 比如那个用户登录 就在后面显示那个用户 /user/mao</span>  <span class="token punctuation">{</span>    <span class="token comment">// 动态路由需要在地址上动态传递参数</span>    path<span class="token operator">:</span> <span class="token string">"/user/:username"</span><span class="token punctuation">,</span>    component<span class="token operator">:</span> User  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在 router-link 中进行如下跳转：</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- 动态路由的使用，后面动态地址那部分不是不变的 --&gt;</span><span class="token comment">&lt;!-- /user/mao      /user/fan --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/user/mao<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>用户user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="获取动态路由的值"><a href="#获取动态路由的值" class="headerlink" title="获取动态路由的值"></a>获取动态路由的值</h4><ul><li>那么在 User 中如何获取到对应的值呢？<ul><li>在 template 中，直接通过 $route.params 获取值；</li><li>在 created 中，通过 this.$route.params 获取值；</li><li>在 setup 中，我们要使用 vue-router 库给我们提供的一个 hook useRoute；</li><li>该 Hook 会返回一个 Route 对象，对象中保存着当前路由相关的值；</li></ul></li></ul><h5 id="template"><a href="#template" class="headerlink" title="template"></a>template</h5><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210830094347776.png" alt="image-20210830094347776"></p><h5 id="created"><a href="#created" class="headerlink" title="created"></a>created</h5><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 在组件创建完毕后 就可以拿到动态路由的参数</span>  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 使用 this.$route 就可以拿到当前匹配的路由 获取地址等</span>    <span class="token comment">// 甚至这个参数里面还可以获取到查询字符串</span>    <span class="token comment">// 也可以获取到我们在前面路由中定义的 name，meta等属性的值</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// params 就是我们的动态路由的参数</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210830094443576.png" alt="image-20210830094443576"></p><h5 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h5><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 通过获取该函数的返回值，可以拿到当前要显示的route路由规则对象</span><span class="token keyword">import</span> <span class="token punctuation">{</span> useRoute <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue-router"</span><span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> route <span class="token operator">=</span> <span class="token function">useRoute</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>route<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// mao</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210830095824134.png" alt="image-20210830095824134"></p><h4 id="匹配多个参数"><a href="#匹配多个参数" class="headerlink" title="匹配多个参数"></a>匹配多个参数</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token comment">// 动态路由需要在地址上动态传递参数</span>    path<span class="token operator">:</span> <span class="token string">"/user/:username/:id"</span><span class="token punctuation">,</span>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../pages/User.vue"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210830100102910.png" alt="image-20210830100102910"></p><h4 id="NotFound"><a href="#NotFound" class="headerlink" title="NotFound"></a>NotFound</h4><p>对于哪些没有匹配到的路由，我们通常会匹配到固定的某个页面</p><p>比如 NotFound 的错误页面中，这个时候我们可编写一个动态路由用于匹配所有的页面；</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token comment">// TODO  这个路由的匹配规则优先级最低 只有其他路由匹配不到才会匹配这个</span>    <span class="token comment">// 当匹配不到其他所有的路由的时候，就会匹配这个路由</span>    <span class="token comment">// 这个写法可以匹配所有的路由路径</span>    <span class="token comment">// patchMatch() 路径匹配</span>    <span class="token comment">// ()里面的是正则表达式</span>    path<span class="token operator">:</span> <span class="token string">"/:patchMatch(.*)"</span><span class="token punctuation">,</span>    component<span class="token operator">:</span> NotFound  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210830112535991.png" alt="image-20210830112535991"></p><h4 id="匹配规则加"><a href="#匹配规则加" class="headerlink" title="匹配规则加*"></a>匹配规则加*</h4><p>这里还有另外一种写法：</p><p><strong>注意：我在/:pathMatch(._)后面又加了一个 _；</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token comment">// 如果在patchMatch()函数后面再加上一个 *</span>    <span class="token comment">// 会把我们当前匹配到的路径按照 / 进行分割，放到数组里面</span>    <span class="token comment">// 也就是通过 $route.params.patchMatch 获取到的地址变成了数组</span>    <span class="token comment">// /a/b/c  ---&gt;  ['a','b','c']</span>    path<span class="token operator">:</span> <span class="token string">"/:patchMatch(.*)*"</span><span class="token punctuation">,</span>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../pages/NotFound.vue"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它们的区别在于解析的时候，是否解析 /：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210830130023144.png" alt="image-20210830130023144"></p><h3 id="路由的嵌套"><a href="#路由的嵌套" class="headerlink" title="路由的嵌套"></a>路由的嵌套</h3><p><strong>什么是路由的嵌套呢？</strong></p><ul><li><p>目前我们匹配的 Home、About、User 等都属于底层路由(<strong>也可以叫做一级路由</strong>)，我们在它们之间可以来回进行切换；</p></li><li><p>但是呢，我们 Home 页面本身，也可能会在多个组件之间来回切换：</p><ul><li>比如 Home 中包括 Product、Message，它们可以在 Home 内部来回切换；</li></ul></li><li><p>这个时候我们就需要使用嵌套路由，在 Home 中也使用 router-view 来占位之后需要渲染的组件；</p></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    path<span class="token operator">:</span> <span class="token string">"/home"</span><span class="token punctuation">,</span>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../pages/Home.vue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment">// 嵌套路由 children 是一个数组 可以有多个子路由</span>    children<span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token comment">// 子路由默认是有父级的地址了 /home/</span>      <span class="token comment">// 所以这里只需要写自己独有的地址就可以，且不需要 /</span>      <span class="token punctuation">{</span> <span class="token string">"path"</span><span class="token operator">:</span> <span class="token string">"message"</span><span class="token punctuation">,</span> <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../pages/HomeMessage.vue"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span> <span class="token string">"path"</span><span class="token operator">:</span> <span class="token string">"shops"</span><span class="token punctuation">,</span> <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../pages/HomeShops.vue"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token comment">// 这里在使用一波重定向，默认访问的是 /home/message</span>      <span class="token comment">// 注意，这里不是 / 这里其实是 "" 空字符</span>      <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> redirect<span class="token operator">:</span> <span class="token string">"/home/message"</span> <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210830140019909.png" alt="image-20210830140019909"></p><h4 id="active-class、exact-active-class-1"><a href="#active-class、exact-active-class-1" class="headerlink" title="active-class、exact-active-class"></a>active-class、exact-active-class</h4><p>active-class，只要当前的路由匹配实际地址栏的地址的一部分，也就是路由嵌套的时候，访问的是子路由地址，实际上父路由也算是被访问了。这时候 active-class 就会加在父路由的那个<code>&lt;router-link&gt;</code>上，也会加在子路由的那个标签上。</p><p>而 exact-active-class 只有精准匹配的时候，才会加在对应路由的那个标签上。也就是只会加在发生路由嵌套的的子路由上。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210830141039073.png" alt="image-20210830141039073"></p><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><h4 id="代码的页面跳转"><a href="#代码的页面跳转" class="headerlink" title="代码的页面跳转"></a>代码的页面跳转</h4><p>有时候我们希望通过代码来完成页面的跳转，比如点击的是一个按钮：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210830142740084.png" alt="image-20210830142740084"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210830142801543.png" alt="image-20210830142801543"></p><p><strong>当然，我们也可以传入一个对象：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210830142936031.png" alt="image-20210830142936031"></p><p><strong>如果是在 setup 中编写的代码，那么我们可以通过 useRouter 来获取：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210830143136615.png" alt="image-20210830143136615"></p><h4 id="query-方式的参数"><a href="#query-方式的参数" class="headerlink" title="query 方式的参数"></a>query 方式的参数</h4><p>我们也可以通过 query 的方式来传递参数：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210830143700481.png" alt="image-20210830143700481"></p><p>在界面中通过 <strong>$route.query</strong> 来获取参数：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210830143858156.png" alt="image-20210830143858156"></p><h4 id="替换当前的位置"><a href="#替换当前的位置" class="headerlink" title="替换当前的位置"></a>替换当前的位置</h4><p>使用 push 的特点是压入一个新的页面，那么在用户点击返回时，上一个页面还可以回退，但是如果我们希望当前 页面是一个替换操作，那么可以使用 replace：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210830144058660.png" alt="image-20210830144058660"></p><p><strong>简单来说就是没办法回到上个页面</strong></p><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><router-link :to="地址" replace=""></router-link></td><td>router.replace(地址)</td></tr></tbody></table><h4 id="页面的前进后退"><a href="#页面的前进后退" class="headerlink" title="页面的前进后退"></a>页面的前进后退</h4><p>当然，想要完成这个效果，首页页面的地址栏是有历史记录的地址的。只有可以前进和后退，才能完成我们需要的效果。</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210830145246632.png" alt="image-20210830145246632"></p><ul><li><p>router 的 go 方法：可以完成 back 和 forward 两个方法的效果。</p></li><li><p>router 也有 back：通过调用 history.back() 回溯历史。相当于 router.go(-1)；</p></li><li><p>router 也有 forward：通过调用 history.forward() 在历史中前进。相当于 router.go(1)；</p></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 前进</span><span class="token keyword">const</span> <span class="token function-variable function">goToOneStep</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token comment">// 前进几条地址记录 二者等价 也可以是 -1 表示后退几条历史记录</span>  <span class="token comment">// router.go(1)</span>  router<span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 后退</span><span class="token keyword">const</span> <span class="token function-variable function">backOneStep</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token comment">// 后退几条历史记录</span>  <span class="token comment">// router.back(1)</span>  <span class="token comment">// 使用 go(-n) 也可以达到回退历史记录的效果</span>  router<span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>即使给 back 方法传递负数，也不会达到前进的结果。还是一样是后退。应该是内部做了转换。</strong></p><h3 id="router-link-的-v-slot"><a href="#router-link-的-v-slot" class="headerlink" title="router-link 的 v-slot"></a>router-link 的 v-slot</h3><p>在 vue-router3.x 的时候，router-link 有一个 tag 属性，可以决定 router-link 到底渲染成什么元素：</p><ul><li>但是在 vue-router4.x 开始，该属性被移除了；</li><li>而给我们提供了更加具有灵活性的 v-slot 的方式来定制渲染的内容；</li></ul><p><strong>v-slot 如何使用呢？</strong></p><ul><li><p>首先，我们需要使用 custom 表示我们整个元素要自定义：</p><ul><li>如果不写，那么自定义的内容会被包裹在一个 a 元素中；</li></ul></li><li><p>其次，我们使用 v-slot 来作用域插槽来获取内部传给我们的值：</p><ul><li>href：解析后的 URL；</li><li>route：解析后的规范化的 route 对象；</li><li>navigate：触发导航的函数；</li><li>isActive：是否匹配的状态；</li><li>isExactActive：是否是精准匹配的状态；</li></ul></li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- router-link组件默认渲染出来的是a元素 --&gt;</span><span class="token comment">&lt;!-- 当我们使用了 custom属性以后，a元素就不会在存在了 --&gt;</span><span class="token comment">&lt;!-- v-slot="props" --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/home<span class="token punctuation">"</span></span> <span class="token attr-name">v-slot</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>props<span class="token punctuation">"</span></span> <span class="token attr-name">custom</span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- 使用默认插槽，渲染为按钮 --&gt;</span>  <span class="token comment">&lt;!-- props.navigate 导航函数 点击按钮后可以进行路由的跳转了 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>props.navigate<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>首页home<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span>哈哈哈 我不会跳转的<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 跳转的链接 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>{{ props.href }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!-- 还可以获取当前的路由规则对象 --&gt;</span>    <span class="token comment">&lt;!-- &lt;span&gt;{{ props.route }}&lt;/span&gt; --&gt;</span>    <span class="token comment">&lt;!-- navigate 获取导航函数 --&gt;</span>    <span class="token comment">&lt;!-- &lt;span&gt;{{props.navigate}}&lt;/span&gt; --&gt;</span>    <span class="token comment">&lt;!-- isActive 是否处于路由激活的状态 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>{{props.isActive}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!-- isExactActive 路由是否处于精确的激活状态，完全匹配 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>{{props.isExactActive}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/about<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- 给默认插槽传递自定义组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nav-bar</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>关于about<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nav-bar</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 动态路由的使用，后面动态地址那部分不是不变的 --&gt;</span><span class="token comment">&lt;!-- /user/mao      /user/fan --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/user/mao/1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>用户user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 路由的占位符 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210831112350080.png" alt="image-20210831112350080"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210831112630682.png" alt="image-20210831112630682"></p><h3 id="router-view-的-v-slot"><a href="#router-view-的-v-slot" class="headerlink" title="router-view 的 v-slot"></a>router-view 的 v-slot</h3><p>router-view 也提供给我们一个插槽，可以用于 <strong><transition></transition></strong> 和 <strong><keep-alive>组件来包裹你的路由组件</keep-alive></strong>：</p><ul><li>Component：要渲染的组件；</li><li>route：解析出的标准化路由对象；</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210831130128339.png" alt="image-20210831130128339"></p><h3 id="动态添加路由"><a href="#动态添加路由" class="headerlink" title="动态添加路由"></a>动态添加路由</h3><p>某些情况下我们可能需要动态的来添加路由：</p><ul><li>比如根据用户不同的权限，注册不同的路由；</li><li>这个时候我们可以使用一个方法 addRoute；</li></ul><p>如果我们是为 route 添加一个 children 路由，那么可以<strong>传入对应的 name：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 定义好动态的路由</span><span class="token keyword">const</span> categoryRoute <span class="token operator">=</span> <span class="token punctuation">{</span>  path<span class="token operator">:</span> <span class="token string">"/category"</span><span class="token punctuation">,</span>  <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>    <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName:"category-chunk" */</span> <span class="token string">"../pages/Category.vue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 动态添加路由 ，调用路由对象router的addRouter方法</span><span class="token comment">// 该方法添加的路由为顶级路由</span>router<span class="token punctuation">.</span><span class="token function">addRoute</span><span class="token punctuation">(</span>categoryRoute<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> homeMomentRoute <span class="token operator">=</span> <span class="token punctuation">{</span>  path<span class="token operator">:</span> <span class="token string">"moment"</span><span class="token punctuation">,</span>  <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../pages/HomeMoment.vue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 添加二级路由</span><span class="token comment">// 参数一：父路由的name属性值 参数二：被添加的路由</span>router<span class="token punctuation">.</span><span class="token function">addRoute</span><span class="token punctuation">(</span><span class="token string">"home"</span><span class="token punctuation">,</span> homeMomentRoute<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210831133405377.png" alt="image-20210831133405377"></p><h3 id="动态删除路由"><a href="#动态删除路由" class="headerlink" title="动态删除路由"></a>动态删除路由</h3><p><strong>删除路由有以下三种方式：</strong></p><ul><li>方式一：<strong>添加一个 name 相同的路由</strong>；</li><li>方式二：通过<strong>removeRoute 方法，传入路由的名称</strong>(name 属性值)；</li><li>方式三：通过<strong>addRoute 方法的返回值回调</strong>（返回值是函数，调用这个函数，如果路由存在就会被删除）；</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 定义好动态的路由</span><span class="token keyword">const</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  path<span class="token operator">:</span> <span class="token string">"/category"</span><span class="token punctuation">,</span>  <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../pages/A.vue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  path<span class="token operator">:</span> <span class="token string">"/category"</span><span class="token punctuation">,</span>  <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../pages/B.vue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 添加路由</span>router<span class="token punctuation">.</span><span class="token function">addRoute</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 再次添加相同路径的的路由，会替换调原来的路由</span>router<span class="token punctuation">.</span><span class="token function">addRoute</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 删除路由 删除路由名字name为home的路由</span>router<span class="token punctuation">.</span><span class="token function">removeRoute</span><span class="token punctuation">(</span><span class="token string">"home"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用addRouter的回调函数删除路由</span><span class="token keyword">const</span> removeRoute <span class="token operator">=</span> router<span class="token punctuation">.</span><span class="token function">addRoute</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">removeRoute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除我们添加的这个路由，如果路由存在的话</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>路由的其他方法补充：</p><ul><li><strong>router.hasRoute(routerName)：</strong>检查路由是否存在（<strong>路由的 name 属性值</strong>）。</li><li><strong>router.getRoutes()：</strong>获取一个包含所有路由记录的数组</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210831134601499.png" alt="image-20210831134601499"></p><h3 id="路由导航守卫"><a href="#路由导航守卫" class="headerlink" title="路由导航守卫"></a>路由导航守卫</h3><p>vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。</p><p><strong>全局的前置守卫 beforeEach 是在导航触发时会被回调的：</strong></p><p>它有两个参数：</p><ul><li><strong>to</strong>：即将进入的路由 Route 对象；</li><li><strong>from</strong>：即将离开的路由 Route 对象；</li></ul><p>它有返回值：</p><ul><li>false：取消当前导航；</li><li>不返回或者 undefined：进行默认导航；</li><li>返回一个路由地址：<ul><li>可以是一个 string 类型的路径；</li><li>可以是一个对象，对象中包含 path、query、params 等信息；</li></ul></li></ul><p>可选的<strong>第三个参数</strong>：<strong>next</strong></p><ul><li>在 Vue2 中我们是通过 next 函数来决定如何进行跳转的；</li><li>但是在 Vue3 中我们是通过返回值来控制的，不再推荐使用 next 函数，这是因为开发中很容易调用多次 next；</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 比如用户未登录的情况下，</span><span class="token comment">// 我们不应该可以去往用户界面（这个路由应该不能访问）</span><span class="token comment">// beforeEach 路由前置导航守卫 路由跳转前执行</span><span class="token comment">/*   to 和 from 参数 都是route对象 都是路由  to: 要去的目标路由  from: 从哪个路由跳转来的  next: 进行路由的放行，vue3/vue-router4.x版本 中不在建议使用，所以也别传递该参数了*/</span><span class="token comment">// router.beforeEach((to, from, next) =&gt; {</span>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// console.log(to.path);</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// next()</span>  <span class="token comment">// 在没有next参数的情况下，</span>  <span class="token comment">// 返回值为true，表示允许路由之间的跳转 进行导航</span>  <span class="token comment">// 返回值为false 表示不允许路由之间的跳转 不进行导航</span>  <span class="token comment">// 返回值为undefined或者无返回值 进行默认导航，相当于这里面的代码没有任何作用</span>  <span class="token comment">// 返回值为字符串（表示一个路由的路径）：去会去往这个返回的路劲</span>  <span class="token comment">// 返回值是一个对象，当然必须包含path属性，也可以有query，等属性</span>  <span class="token comment">// 比如： {path:"/home",query:{name:"毛毛"}}</span>  <span class="token comment">// return true;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">.</span>path<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"/home"</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"/about"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="其他导航守卫"><a href="#其他导航守卫" class="headerlink" title="其他导航守卫"></a>其他导航守卫</h3><p>Vue 还提供了很多的其他守卫函数，目的都是在某一个时刻给予我们回调，让我们可以更好的控制程序的流程或者功能：</p><p><a href="https://next.router.vuejs.org/zh/guide/advanced/navigation-guards.html">vue-router</a></p><p>我们一起来看一下完整的导航解析流程：</p><ul><li>导航被触发。</li><li>在失活的组件里调用 beforeRouteLeave 守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫(2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/wei_chat/image-20210831192840706.png" alt="image-20210831192840706"></p>]]></content>
      
      
      <categories>
          
          <category> vue-router </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> ts </tag>
            
            <tag> webpack </tag>
            
            <tag> vue-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3-初体验</title>
      <link href="/2021/11/02/src/vue/vue3-chu-ti-yan/"/>
      <url>/2021/11/02/src/vue/vue3-chu-ti-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-Composition-API-一"><a href="#Vue3-Composition-API-一" class="headerlink" title="Vue3-Composition-API(一)"></a>Vue3-Composition-API(一)</h1><h2 id="前置补充"><a href="#前置补充" class="headerlink" title="前置补充"></a>前置补充</h2><h3 id="认识-Mixin"><a href="#认识-Mixin" class="headerlink" title="认识 Mixin"></a>认识 Mixin</h3><p>目前我们是使用组件化的方式在开发整个 Vue 的应用程序，但是组件和组件之间有时候会<strong>存在相同的代码逻辑</strong>，我 们希望对<strong>相同的代码逻辑进行抽取。</strong></p><p>在 Vue2 和 Vue3 中都支持的一种方式就是<strong>使用 Mixin 来完成：</strong></p><ol><li>Mixin 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能；</li><li>一个 Mixin 对象可以包含任何组件选项；</li><li>当组件使用 Mixin 对象时，所有 Mixin 对象的选项将被 混合 进入该组件本身的选项中；</li></ol><h3 id="Mixin-的基本使用"><a href="#Mixin-的基本使用" class="headerlink" title="Mixin 的基本使用"></a>Mixin 的基本使用</h3><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817103436943.png" alt="image-20210817103436943"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817103455764.png" alt="image-20210817103455764"></p><h3 id="Mixin-的合并规则"><a href="#Mixin-的合并规则" class="headerlink" title="Mixin 的合并规则"></a>Mixin 的合并规则</h3><p><strong>如果 Mixin 对象中的选项和组件对象中的选项发生了冲突，那么 Vue 会如何操作呢？</strong></p><p>这里<strong>分成不同的情况</strong>来进行处理；</p><p><strong>情况一：如果是 data 函数的返回值对象</strong></p><ul><li>返回值对象默认情况下会进行合并；</li><li>如果 data 返回值对象的属性发生了冲突，那么会保留组件自身的数据；</li></ul><p><strong>情况二：如何生命周期钩子函数</strong></p><ul><li>生命周期的钩子函数会被合并到数组中，都会被调用；</li></ul><p><strong>情况三：值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。</strong></p><ul><li>比如都有 methods 选项，并且<strong>都定义了方法，那么它们都会生效</strong>；</li><li>但是如果<strong>对象的 key 相同</strong>，那么<strong>会取组件对象的键值对</strong>；</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817125624404.png" alt="image-20210817125624404"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817125637070.png" alt="image-20210817125637070"></p><h3 id="全局混入-Mixin"><a href="#全局混入-Mixin" class="headerlink" title="全局混入 Mixin"></a>全局混入 Mixin</h3><p><strong>如果组件中的某些选项，是所有的组件都需要拥有的，那么这个时候我们可以使用全局的 mixin：</strong></p><ul><li>全局的 Mixin 可以使用 应用 app 的方法 mixin 来完成注册；</li><li>一旦注册，那么全局混入的选项将会影响每一个组件；</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817130238279.png" alt="image-20210817130238279"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817130247318.png" alt="image-20210817130247318"></p><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p><strong>另外一个类似于 Mixin 的方式是通过 extends 属性：</strong></p><p>允许声明扩展另外一个组件，类似于 Mixins；</p><p><strong>在开发中 extends 用的非常少，在 Vue2 中比较推荐大家使用 Mixin，而在 Vue3 中推荐使用 Composition API。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817132414819.png" alt="image-20210817132414819"></p><h2 id="Options-API-的弊端"><a href="#Options-API-的弊端" class="headerlink" title="Options API 的弊端"></a>Options API 的弊端</h2><p>在 Vue2 中，我们编写组件的方式是 Options API：</p><ol><li>Options API 的一大特点就是在对应的属性中编写对应的功能模块；</li><li>比如 data 定义数据、methods 中定义方法、computed 中定义计算属性、watch 中监听属性改变，也包括生命 周期钩子；</li></ol><p>但是这种代码有一个很大的弊端：</p><ol><li>当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中；</li><li>当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散；</li><li>尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）；</li></ol><p><strong>如果我们能将同一个逻辑关注 点相关的代码收集在一起会更 好。</strong></p><p><strong>这就是 Composition API 想 要做的事情，以及可以帮助我 们完成的事情。</strong></p><p><strong>也有人把 Vue Composition API 简称为 VCA。</strong></p><h2 id="认识-Composition-API"><a href="#认识-Composition-API" class="headerlink" title="认识 Composition API"></a>认识 Composition API</h2><p>那么既然知道 Composition API 想要帮助我们做什么事情，接下来看一下到底是怎么做呢？</p><ol><li>为了开始使用 Composition API，我们需要有一个可以实际使用它（编写代码）的地方；</li><li>在 Vue 组件中，这个位置<strong>就是 setup 函数；</strong></li></ol><p><strong>setup 其实就是组件的另外一个选项：</strong></p><ol><li>只不过这个选项强大到我们可以用它来替代之前所编写的大部分其他选项；</li><li>比如 methods、computed、watch、data、生命周期等等；</li></ol><p><strong>接下来我们一起学习这个函数的使用</strong></p><ul><li>函数的参数</li><li>函数的返回值</li></ul><h3 id="setup-函数的参数"><a href="#setup-函数的参数" class="headerlink" title="setup 函数的参数"></a>setup 函数的参数</h3><p>我们先来研究一个 setup 函数的参数，它主要有两个参数：</p><ul><li>第一个参数：props</li><li>第二个参数：context</li></ul><p>props 非常好理解，它其实就是父组件传递过来的属性会被<strong>放到 props 对象</strong>中，我们在 setup 中如果需要使用，那么就可 以<strong>直接通过 props 参数</strong>获取：</p><ol><li>对于定义 props 的类型，我们还是和之前的规则是一样的，在 props 选项中定义； p</li><li>并且在 template 中依然是可以正常去使用 props 中的属性，比如 message；</li><li>如果我们在 setup 函数中想要使用 props，那么不可以通过 this 去获取（后面我会讲到为什么）；</li><li>因为 props 有直接作为参数传递到 setup 函数中，所以我们可以直接通过参数来使用即可；</li></ol><p><strong>另外一个参数是 context，我们也称之为是一个 SetupContext，它里面包含三个属性：</strong></p><ul><li>attrs：所有的非 prop 的 attribute；</li><li>slots：父组件传递过来的插槽（这个在以渲染函数返回时会有作用，后面会讲到）；</li><li>emit：当我们组件内部需要发出事件时会用到 emit（因为我们不能访问 this，所以不可以通过 this.$emit 发出事件）；</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817141859483.png" alt="image-20210817141859483"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817141907813.png" alt="image-20210817141907813"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817141917796.png" alt="image-20210817141917796"></p><h3 id="setup-函数的返回值"><a href="#setup-函数的返回值" class="headerlink" title="setup 函数的返回值"></a>setup 函数的返回值</h3><p>setup 既然是一个函数，那么它也可以有返回值，它的返回值用来做什么呢？</p><ul><li>setup 的返回值可以在模板 template 中被使用；</li><li>也就是说我们可以通过 setup 的返回值来替代 data 选项；</li></ul><p>甚至是我们可以返回一个执行函数来代替在 methods 中定义的方法：</p><p><strong>但是，如果我们将 counter 在 increment 或者 decrement 进行操作时，是否可以实现界面的响应式呢？</strong></p><ul><li>答案是不可以；</li><li>这是因为对于一个定义的变量来说，默认情况下，Vue 并不会跟踪它的变化，来引起界面的响应式操作；</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817161645538.png" alt="image-20210817161645538"></p><h3 id="setup-不可以使用-this"><a href="#setup-不可以使用-this" class="headerlink" title="setup 不可以使用 this"></a>setup 不可以使用 this</h3><p><strong>官方关于 this 有这样一段描述</strong></p><ul><li>表达的含义是 this 并没有指向当前组件实例；</li><li>并且在 setup 被调用之前，data、computed、methods 等都没有被解析；</li><li>所以无法在 setup 中获取 this；</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817163136789.png" alt="image-20210817163136789"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817163156525.png" alt="image-20210817163156525"></p><h3 id="Reactive-API"><a href="#Reactive-API" class="headerlink" title="Reactive API"></a>Reactive API</h3><p>如果想为在 setup 中定义的数据提供响应式的特性，那么我们可以<strong>使用 reactive 的函数</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817164854036.png" alt="image-20210817164854036"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817164925535.png" alt="image-20210817164925535"></p><p><strong>那么这是什么原因呢？为什么就可以变成响应式的呢？</strong></p><ul><li>这是因为当我们使用 reactive 函数处理我们的数据之后，数据再次被使用时就会进行依赖收集；</li><li>当数据发生改变时，所有收集到的依赖都是进行对应的响应式操作（比如更新界面）；</li><li>事实上，我们编写的 data 选项，也是在内部交给了 reactive 函数将其编程响应式对象的；</li></ul><h3 id="Ref-API-尤大大推荐使用"><a href="#Ref-API-尤大大推荐使用" class="headerlink" title="Ref API(尤大大推荐使用)"></a>Ref API(尤大大推荐使用)</h3><p><strong>reactive API 对</strong>传入的<strong>类型是有限制</strong>的，它要求我们必须传入的是<strong>一个对象或者数组</strong>类型：</p><p><strong>如果我们传入一个基本数据类型（String、Number、Boolean）会报一个警告；</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817170808693.png" alt="image-20210817170808693"></p><p>这个时候 Vue3 给我们提供了另外一个<strong>API：ref API</strong></p><ul><li>ref 会返回一个可变的响应式对象，该对象作为一个 响应式的引用 维护着它内部的值，这就是 ref 名称的来源；</li><li>它内部的值是在 ref 的 value 属性中被维护的；</li></ul><p><strong>这里有两个注意事项：</strong></p><ul><li>在模板中引入 ref 的值时，Vue 会自动帮助我们进行解包操作，所以我们并不需要在模板中通过 ref.value 的方式 来使用；</li><li>但是在 setup 函数内部，它依然是一个 ref 引用， 所以对其进行操作时，我们依然需要使用 ref.value 的方式；</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817171151124.png" alt="image-20210817171151124"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817171207810.png" alt="image-20210817171207810"></p><h4 id="Ref-自动解包"><a href="#Ref-自动解包" class="headerlink" title="Ref 自动解包"></a>Ref 自动解包</h4><p>模板中的解包是浅层的解包，如果我们的代码是下面的方式，<strong>现在也可以自动解包了</strong>：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817172326881.png" alt="image-20210817172326881"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817172343208.png" alt="image-20210817172343208"></p><p>如果我们将 ref 放到一个 reactive 的属性当中，那么在模板中使用时，它会自动解包：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817172826882.png" alt="image-20210817172826882"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817172837494.png" alt="image-20210817172837494"></p><h3 id="认识-readonly"><a href="#认识-readonly" class="headerlink" title="认识 readonly"></a>认识 readonly</h3><p>我们<strong>通过 reactive 或者 ref 可以</strong>获取到一个<strong>响应式的对象</strong>，但是某些情况下，我们传入给其他地方（组件）的这个 响应式对象希望在另外一个地方（<strong>组件）被使用</strong>，但是<strong>不能被修改</strong>，这个时候如何防止这种情况的出现呢？</p><ul><li>Vue3 为我们提供了 readonly 的方法；</li><li>readonly 会返回原生对象的只读代理（也就是它依然是一个 Proxy，这是一个 proxy 的 set 方法被劫持，并且不 能对其进行修改）；</li></ul><p><strong>在开发中常见的 readonly 方法会传入三个类型的参数：</strong></p><ul><li>类型一：普通对象；</li><li>类型二：reactive 返回的对象；</li><li>类型三：ref 的对象；</li></ul><h4 id="readonly-的使用"><a href="#readonly-的使用" class="headerlink" title="readonly 的使用"></a>readonly 的使用</h4><p><strong>在 readonly 的使用过程中，有如下规则：</strong></p><ul><li>readonly 返回的对象都是不允许修改的；</li><li>但是经过 readonly 处理的<strong>原来的对象</strong>是允许被修改的；<ul><li>比如 const info = readonly(obj)，info 对象是不允许被修改的；</li><li>当 obj 被修改时，readonly 返回的 info 对象也会被修改；</li><li>但是我们不能去修改 readonly 返回的对象 info；</li></ul></li><li>其实本质上就是 readonly 返回的对象的 setter 方法被<strong>劫持了而已；</strong></li></ul><h4 id="readonly-的应用"><a href="#readonly-的应用" class="headerlink" title="readonly 的应用"></a>readonly 的应用</h4><p><strong>那么这个 readonly 有什么用呢？</strong></p><p>在我们传递给其他组件数据时，往往希望其他组件使用我们传递的内容，但是不允许它们修改时，就可以使用 readonly 了</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817180815814.png" alt="image-20210817180815814"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817180921569.png" alt="image-20210817180921569"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210817180954082.png" alt="image-20210817180954082"></p><h1 id="Vue3-Composition-API-二"><a href="#Vue3-Composition-API-二" class="headerlink" title="Vue3-Composition-API(二)"></a>Vue3-Composition-API(二)</h1><h2 id="Reactive-API-1"><a href="#Reactive-API-1" class="headerlink" title="Reactive-API"></a>Reactive-API</h2><h3 id="Reactive-判断的-API"><a href="#Reactive-判断的-API" class="headerlink" title="Reactive 判断的 API"></a>Reactive 判断的 API</h3><ul><li><p><strong>isProxy</strong></p><p>检查对象是否是由 reactive 或 readonly 创建的 proxy。</p></li><li><p><strong>isReactive</strong></p><ol><li>检查对象是否是由 reactive 创建的响应式代理：</li><li>如果该代理是 readonly 建的，但包裹了由 reactive 创建的另一个代理，它也会返回 true；</li></ol></li><li><p><strong>isReadonly</strong></p><ol><li>检查对象是否是由 readonly 创建的只读代理。</li></ol></li><li><p><strong>toRaw</strong></p><ol><li>返回 reactive 或 readonly 代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用）。</li></ol></li><li><p><strong>shallowReactive</strong></p><ol><li>创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (深层还是原生对象)。</li></ol></li><li><p><strong>shallowReadonly</strong></p><ol><li>创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）。</li></ol></li></ul><h2 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h2><p>如果我们<strong>使用 ES6 的解构语法</strong>，<strong>对 reactive 返回的对象进行解构获取值</strong>，那么之后无论是修改结构后的变量，还是修改 reactive 返回的 state 对象，<strong>数据都不再是响应式的：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819110318174.png" alt="image-20210819110318174"></p><p>那么有没有办法让我们解构出来的属性是<strong>响应式</strong>的呢？</p><ol><li><p>Vue 为我们提供了一个 toRefs 的函数，可以将 reactive 返回的对象中的属性都转成 ref；</p></li><li><p>那么我们再次进行解构出来的 name 和 age 本身都是 ref 的；</p></li></ol><p>这种做法相当于已经在<strong>state.name 和 ref.value 之间建立了 链接，</strong>任何一个修改都会引起另外一个变化；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819111534916.png" alt="image-20210819111534916"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819111537988.png" alt="image-20210819111537988"></p><h2 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h2><p>如果我们只希望转换一个 reactive 对象中的属性为 ref, 那么可以使<strong>用 toRef 的方法：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819112216206.png" alt="image-20210819112216206"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// toRef函数，对其中一个属性进行解构为ref响应式对象</span><span class="token comment">/*  toRef(对象，'对象需要转为ref的属性')*/</span><span class="token keyword">let</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span> <span class="token operator">=</span> info2<span class="token punctuation">;</span><span class="token keyword">let</span> age <span class="token operator">=</span> <span class="token function">toRef</span><span class="token punctuation">(</span>info2<span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ref-其他的-API"><a href="#ref-其他的-API" class="headerlink" title="ref 其他的 API"></a>ref 其他的 API</h2><p><strong>unref</strong></p><p>如果我们想要获取一个<strong>ref 引用中的 value</strong>，那么也可以<strong>通过 unref 方法：</strong></p><ul><li><p>如果参数是一个 ref，则返回内部值，否则返回参数本身；</p></li><li><p>这是 <strong>val = isRef(val) ? val.value : val</strong> 的语法糖函数；</p></li></ul><p><strong>isRef</strong></p><p>判断值是否是一个 ref 对象。</p><p><strong>shallowRef</strong></p><p>创建一个浅层的 ref 对象；</p><p><strong>triggerRef</strong></p><p><strong>手动触发和 shallowRef 相关联的副作用：(比如页面的响应式刷新，就是刷新响应式数据以后的副作用</strong>)</p><h2 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h2><p>创建一个<strong>自定义的 ref</strong>，并<strong>对其依赖项跟踪和更新触发</strong>进行显示控制：</p><p>它需要一个工厂函数，该函数接受 <strong>track 和 trigger</strong> 函数作为参数；并且应该返回一个<strong>带有 get 和 set 的对象；</strong></p><p><strong>这里我们使用一个的案例：</strong></p><p>对双向绑定的属性进行 debounce**(节流)**的操作；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819152343898.png" alt="image-20210819152343898"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819152356575.png" alt="image-20210819152356575"></p><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>在前面我们讲解过计算属性 computed：当我们的某些属性是依赖其他状态时，我们可以使用计算属性来处理</p><ol><li>在前面的 Options API 中，我们是使用 computed 选项来完成的；</li><li>在 Composition API 中，我们可以在 setup 函数中使用 computed 方法来编写一个计算属性；</li></ol><p>如何使用 computed 呢？</p><ol><li>方式一：接收一个 getter 函数，并为 getter 函数返回的值，返回一个不变的 ref 对象；</li><li>方式二：接收一个具有 get 和 set 的对象，返回一个可变的（可读写）ref 对象；</li></ol><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819154035057.png" alt="image-20210819154035057"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819154045046.png" alt="image-20210819154045046"></p><h2 id="侦听数据的变化"><a href="#侦听数据的变化" class="headerlink" title="侦听数据的变化"></a>侦听数据的变化</h2><p>在前面的 Options API 中，我们可以通过 watch 选项来侦听 data 或者 props 的数据变化，当数据变化时执行某一些 操作。</p><p>在 Composition API 中，我们可以使用 watchEffect 和 watch 来完成响应式数据的侦听；</p><ol><li>watchEffect 用于自动收集响应式数据的依赖；</li><li>watch 需要手动指定侦听的数据源；</li></ol><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p>当侦听到某些响应式数据变化时，我们希望执行某些操作，这个时候可以使用 watchEffect。</p><p>我们来看一个案例：</p><ul><li>首先，watchEffect 传入的函数会被立即执行一次，并且在执行的过程中会收集依赖；</li><li>其次，只有收集的依赖发生变化时，watchEffect 传入的函数才会再次执行；</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819155923525.png" alt="image-20210819155923525"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819160013737.png" alt="image-20210819160013737"></p><h3 id="watchEffect-的停止侦听"><a href="#watchEffect-的停止侦听" class="headerlink" title="watchEffect 的停止侦听"></a>watchEffect 的停止侦听</h3><p>如果在发生某些情况下，我们希望<strong>停止侦听</strong>，这个时候我们可以获取 watchEffect 的<strong>返回值函数</strong>，调用该函数即可。</p><p>比如在上面的案例中，我们 age 达到 25 的时候就停止侦听：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819161134008.png" alt="image-20210819161134008"></p><h3 id="watchEffect-清除副作用"><a href="#watchEffect-清除副作用" class="headerlink" title="watchEffect 清除副作用"></a>watchEffect 清除副作用</h3><p>什么是清除副作用呢？</p><ul><li>比如在开发中我们需要在侦听函数中执行网络请求，但是在网络请求还没有达到的时候，我们停止了侦听器， 或者侦听器侦听函数被再次执行了。</li><li>那么上一次的网络请求应该被取消掉，这个时候我们就可以清除上一次的副作用；</li></ul><p>在我们给 watchEffect 传入的函数被回调时，其实可以获取到一个参数：<strong>onInvalidate</strong></p><ul><li>当<strong>副作用即将重新执行 或者 侦听器被停止</strong> 时会执行该函数传入的回调函数；</li><li>我们可以在传入的回调函数中，<strong>执行一些清除工作；</strong></li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819162743948.png" alt="image-20210819162743948"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819162857567.png" alt="image-20210819162857567"></p><h3 id="setup-中使用-ref"><a href="#setup-中使用-ref" class="headerlink" title="setup 中使用 ref"></a>setup 中使用 ref</h3><p>在<strong>讲解 watchEffect 执行时机之前</strong>，我们先补充一个知识：在 setup 中如何使用 ref 或者元素或者组件？</p><p>其实非常简单，我们只需要定义一个 ref 对象，绑定到元素或者组件的 ref 属性上即可；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819203324866.png" alt="image-20210819203324866"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819203358058.png" alt="image-20210819203358058"></p><h3 id="watchEffect-的执行时机"><a href="#watchEffect-的执行时机" class="headerlink" title="watchEffect 的执行时机"></a>watchEffect 的执行时机</h3><p>默认情况下，组件的更新会在副作用函数执行之前：</p><p>如果我们希望在副作用函数中获取到元素，是否可行呢？</p><p><strong>结果如上图</strong></p><p>我们会发现打印结果打印了两次：</p><ul><li>这是因为 setup 函数在执行时就会立即执行传入的副作用函数，这个时候 DOM 并没有挂载，所以打印为 null；</li><li>而当 DOM 挂载时，会给 title 的 ref 对象赋值新的值，副作用函数会再次执行，打印出来对应的元素；</li></ul><h3 id="调整-watchEffect-的执行时机"><a href="#调整-watchEffect-的执行时机" class="headerlink" title="调整 watchEffect 的执行时机"></a>调整 watchEffect 的执行时机</h3><p>如果我们希望在第一次的时候就打印出来对应的元素呢？</p><ul><li>这个时候我们需要改变副作用函数的执行时机；</li><li>它的默认值是 pre，它会在元素 挂载 或者 更新 之前执行；</li><li>所以我们会先打印出来一个空的，当依赖的 title 发生改变时，就会再次执行一次，打印出元素；</li></ul><p>我们可以设置副作用函数的执行时机：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819203730628.png" alt="image-20210819203730628"></p><p><strong>flush 选项还接受 sync</strong>，这将<strong>强制效果始终同步触发</strong>。然而，这是低效的，应该很少需要。</p><h2 id="Watch-的使用"><a href="#Watch-的使用" class="headerlink" title="Watch 的使用"></a>Watch 的使用</h2><p>watch 的 API 完全等同于组件 watch 选项的 Property：</p><ul><li>watch 需要侦听特定的数据源，并在回调函数中执行副作用；</li><li>默认情况下它是惰性的，只有当被侦听的源发生变化时才会执行回调；</li></ul><p>与 watchEffect 的比较，watch 允许我们：</p><ul><li>懒执行副作用（第一次不会直接执行）；</li><li>更具体的说明当哪些状态发生变化时，触发侦听器的执行；</li><li>访问侦听状态变化前后的值；</li></ul><h3 id="侦听单个数据源"><a href="#侦听单个数据源" class="headerlink" title="侦听单个数据源"></a>侦听单个数据源</h3><p>watch 侦听函数的数据源有两种类型：</p><p>侦听器数据源可以是<strong>返回值的 getter 函数</strong>，也可以直接是 <code>ref</code>：</p><ul><li><p>一个 getter 函数：但是该 getter 函数必须引用可响应式的对象（比如 reactive 或者 ref）；</p></li><li><p>直接写入一个可响应式的对象，reactive 或者 ref（比较常用的是 ref）；</p></li></ul><p><strong>下面这种方式就侦听失败了，新值旧值是一样的。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819205627220.png" alt="image-20210819205627220"></p><p><strong>方式一</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819211938552.png" alt="image-20210819211938552"></p><p><strong>方式二</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819212058408.png" alt="image-20210819212058408"></p><h3 id="侦听多个数据源"><a href="#侦听多个数据源" class="headerlink" title="侦听多个数据源"></a>侦听多个数据源</h3><p>侦听器还可以使用数组同时侦听多个源：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819213624892.png" alt="image-20210819213624892"></p><h3 id="侦听响应式对象"><a href="#侦听响应式对象" class="headerlink" title="侦听响应式对象"></a>侦听响应式对象</h3><p>如果我们希望侦听一个数组或者对象，那么可以使用一个 getter 函数，并且对可响应对象进行解构：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819215123772.png" alt="image-20210819215123772"></p><h3 id="watch-的选项"><a href="#watch-的选项" class="headerlink" title="watch 的选项"></a>watch 的选项</h3><p>如果我们希望侦听一个深层的侦听，那么依然需要设置 deep 为 true：</p><p>也可以传入 immediate 立即执行；</p><p><strong>如果传入的是一个 reactive 对象，默认情况就是会自动进行深度侦听的，输入获取到的新值旧值都是还是同一个对象</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819215717291.png" alt="image-20210819215717291"></p><p><strong>设置深度侦听</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819220928428.png" alt="image-20210819220928428"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210819221004914.png" alt="image-20210819221004914"></p><h1 id="Composition-API（三）-高级语法补充"><a href="#Composition-API（三）-高级语法补充" class="headerlink" title="Composition API（三） 高级语法补充"></a>Composition API（三） 高级语法补充</h1><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><p>我们前面说过 setup 可以用来替代 data 、 methods 、 computed 、watch 等等这些选项，也可以替代 生命周 期钩子。</p><p><strong>那么 setup 中如何使用生命周期函数呢？</strong></p><p>可以使用直接导入的 onX 函数注册生命周期钩子；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210821145225776.png" alt="image-20210821145225776"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210821144149835.png" alt="image-20210821144149835"></p><table><thead><tr><th>选项式 API</th><th>Hook inside <code>setup</code></th></tr></thead><tbody><tr><td><code>beforeCreate</code></td><td>Not needed*</td></tr><tr><td><code>created</code></td><td>Not needed*</td></tr><tr><td><code>beforeMount</code></td><td><code>onBeforeMount</code></td></tr><tr><td><code>mounted</code></td><td><code>onMounted</code></td></tr><tr><td><code>beforeUpdate</code></td><td><code>onBeforeUpdate</code></td></tr><tr><td><code>updated</code></td><td><code>onUpdated</code></td></tr><tr><td><code>beforeUnmount</code></td><td><code>onBeforeUnmount</code></td></tr><tr><td><code>unmounted</code></td><td><code>onUnmounted</code></td></tr><tr><td><code>errorCaptured</code></td><td><code>onErrorCaptured</code></td></tr><tr><td><code>renderTracked</code></td><td><code>onRenderTracked</code></td></tr><tr><td><code>renderTriggered</code></td><td><code>onRenderTriggered</code></td></tr><tr><td><code>activated</code></td><td><code>onActivated</code></td></tr><tr><td><code>deactivated</code></td><td><code>onDeactivated</code></td></tr></tbody></table><blockquote><p>因为 <code>setup</code> 是围绕 <code>beforeCreate</code> 和 <code>created</code> 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 <code>setup</code> 函数中编写。</p></blockquote><p><strong>这些函数接受一个回调函数，当钩子被组件调用时将会被执行:</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// mounted</span>    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Component is mounted!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span style="color:red">我们发现，最上面的两个生命周期函数，也就是<code>beforeCreate</code>&nbsp; 和 <code>created</code>&nbsp; 两个生命周期函数没有对应的 composition-API 的生命周期函数。实际上，setup 函数的执行时机是在这两个生命周期之前的，如果有需要放在这两个生命周期里需要执行的，完全可以直接写在 setup 函数里面。</span></p><p>其他的生命周期都是一一对应的关系。</p><h2 id="Provide-函数"><a href="#Provide-函数" class="headerlink" title="Provide 函数"></a>Provide 函数</h2><p>事实上我们之前还学习过 Provide 和 Inject，Composition API 也可以替代之前的 Provide 和 Inject 的选项。</p><p><strong>我们可以通过 provide 来提供数据</strong></p><ul><li>可以通过 provide 方法来定义每个 Property；</li><li>provide 可以传入两个参数：<ul><li>name：提供的属性名称；</li><li>value：提供的属性值；</li></ul></li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210821151840084.png" alt="image-20210821151840084"></p><h2 id="Inject-函数"><a href="#Inject-函数" class="headerlink" title="Inject 函数"></a>Inject 函数</h2><p>在 后代组件 中可以通过 inject 来注入需要的属性和对应的值：</p><ul><li><p>可以通过 inject 来注入需要的内容；</p></li><li><p>inject 可以传入两个参数：</p><ul><li>参数一：要 inject 的 property 的 name；</li><li>参数二：默认值；</li></ul></li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210821152127496.png" alt="image-20210821152127496"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210821152144802.png" alt="image-20210821152144802"></p><h2 id="数据的响应式"><a href="#数据的响应式" class="headerlink" title="数据的响应式"></a>数据的响应式</h2><p>为了增加 provide 值和 inject 值之间的响应性，我们可以在 provide 值时使用 ref 和 reactive。<strong>如上面代码所示</strong></p><h2 id="修改响应式-Property"><a href="#修改响应式-Property" class="headerlink" title="修改响应式 Property"></a>修改响应式 Property</h2><p>如果我们需要修改可响应的数据，那么最好是在数据提供的位置来修改：</p><p>我们可以将修改方法进行共享，在后代组件中进行调用；</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210821154947452.png" alt="image-20210821154947452"></p><h2 id="script-setup-实验性特性"><a href="#script-setup-实验性特性" class="headerlink" title="script setup 实验性特性"></a>script setup 实验性特性</h2><h3 id="setup-顶层写法"><a href="#setup-顶层写法" class="headerlink" title="setup 顶层写法"></a>setup 顶层写法</h3><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210821171738689.png" alt="image-20210821171738689"></p><h2 id="认识-h-函数"><a href="#认识-h-函数" class="headerlink" title="认识 h 函数"></a>认识 h 函数</h2><p>Vue 推荐在绝大数情况下<strong>使用模板</strong>来创建你的 HTML，然后一些特殊的场景，你真的需要<strong>JavaScript 的完全编程的 能力</strong>，这个时候你可以使用 <strong>渲染函数</strong> ，它比<strong>模板更接近编译器</strong>；</p><ul><li>前面我们讲解过 VNode 和 VDOM 的改变：</li><li>Vue 在生成真实的 DOM 之前，会将我们的节点转换成 VNode，而 VNode 组合在一起形成一颗树结构，就是虚 拟 DOM（VDOM）；</li><li>事实上，我们之前编写的 template 中的 HTML 最终也是使用渲染函数生成对应的 VNode；</li><li>那么，如果你想<strong>充分的利用 JavaScript 的编程能力</strong>，我们可以自己来<strong>编写 createVNode 函数，生成对应的 VNode</strong>；</li></ul><p><strong>那么我们应该怎么来做呢？使用 h()函数：</strong></p><ul><li>h() 函数是一个用于创建 vnode 的一个函数；</li><li>其实更准备的命名是 createVNode() 函数，但是为了简便在 Vue 将之简化为 h() 函数；</li></ul><h3 id="h-函数-如何使用呢？"><a href="#h-函数-如何使用呢？" class="headerlink" title="h()函数 如何使用呢？"></a>h()函数 如何使用呢？</h3><p>h()函数 如何使用呢？它接受三个参数：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210821211501955.png" alt="image-20210821211501955"></p><p><strong>注意事项：</strong></p><ul><li>如果没有 props，那么通常可以将 children 作为第二个参数传入；</li><li>如果会产生歧义，可以将<strong>null</strong>作为第二个参数传入，将 children 作为第三个参数传入；</li></ul><h3 id="h-函数的基本使用"><a href="#h-函数的基本使用" class="headerlink" title="h 函数的基本使用"></a>h 函数的基本使用</h3><p><strong>h 函数可以在两个地方使用：</strong></p><ul><li>render 函数选项中；</li><li>setup 函数选项中（setup 本身需要是一个函数类型，函数再返回 h 函数创建的 VNode）；</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210821211940463.png" alt="image-20210821211940463"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210821212733915.png" alt="image-20210821212733915"></p><h3 id="h-函数计数器案例"><a href="#h-函数计数器案例" class="headerlink" title="h 函数计数器案例"></a>h 函数计数器案例</h3><h4 id="1-render-函数实现"><a href="#1-render-函数实现" class="headerlink" title="1. render 函数实现"></a>1. render 函数实现</h4><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210821214240353.png" alt="image-20210821214240353"></p><h4 id="2-setup-函数实现"><a href="#2-setup-函数实现" class="headerlink" title="2. setup 函数实现"></a>2. setup 函数实现</h4><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210821214316584.png" alt="image-20210821214316584"></p><h3 id="函数组件和插槽的使用"><a href="#函数组件和插槽的使用" class="headerlink" title="函数组件和插槽的使用"></a>函数组件和插槽的使用</h3><p><strong>了解 render 函数的使用方式即可。不说难不难，这种方式的阅读性应该大部分人是受不了的。</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210821221823552.png" alt="image-20210821221823552"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210821221836619.png" alt="image-20210821221836619"></p><h2 id="jsx-的-babel-配置"><a href="#jsx-的-babel-配置" class="headerlink" title="jsx 的 babel 配置"></a>jsx 的 babel 配置</h2><p>如果我们希望在<strong>项目中使用 jsx</strong>，那么我们需要<strong>添加对 jsx 的支持</strong>：</p><p>jsx 我们通常会<strong>通过 Babel 来进行转换</strong>（React 编写的 jsx 就是通过 babel 转换的）；</p><p>对于 Vue 来说，我们只需要在 Babel 中配置对应的插件即可；</p><p><strong>安装 Babel 支持 Vue 的 jsx 插件：</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i @vue/babel-plugin-jsx -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 babel.config.js 配置文件中配置插件：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  presets<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"@vue/cli-plugin-babel/preset"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"@vue/babel-plugin-jsx"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>但是笔者这里使用最新的 vue 脚手架的时候，发现已经支持了 jsx 的写法，应该是已经预装了该插件，已经内置支持该 jsx 写法，不需要再重新安装</strong></p><h3 id="jsx-的基本使用和计数器案例"><a href="#jsx-的基本使用和计数器案例" class="headerlink" title="jsx 的基本使用和计数器案例"></a>jsx 的基本使用和计数器案例</h3><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210821224756607.png" alt="image-20210821224756607"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210821224811395.png" alt="image-20210821224811395"></p><p><strong>效果</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210821224833337.png" alt="image-20210821224833337"></p><pre class="line-numbers language-html" data-language="html"><code class="language-html">// Home.vue<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token comment">// 定义好默认的组件插槽，外面使用了插槽就调用</span>        <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>          <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span>哈哈Home <span class="token number">111</span>！！！<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>          <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>$slots<span class="token punctuation">.</span>default <span class="token operator">?</span> <span class="token punctuation">(</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$slots<span class="token punctuation">.</span><span class="token function">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>            <span class="token operator">&lt;</span>h3<span class="token operator">&gt;</span>我是插槽的默认值<span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">&gt;</span>          <span class="token punctuation">)</span><span class="token punctuation">}</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>      <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!--App.vue--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">import</span> Home <span class="token keyword">from</span> <span class="token string">"./Home.vue"</span><span class="token punctuation">;</span>  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token punctuation">{</span>        counter<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> <span class="token function-variable function">increment</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>counter<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> <span class="token function-variable function">decrement</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>counter<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token comment">// jsx语法</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token comment">// 使用小括号括起来，方便换行，且这个括号里面的都是返回值</span>        <span class="token comment">// jsx里面使用变量和函数 都是使用花括号获取</span>        <span class="token comment">// 使用组件 必须使用导入的组件名称，比如导入的是 Home 标签也必须大写为 Home</span>        <span class="token comment">// 也可以在组件内使用插槽，直接使用{}传递过去，当然传递的也必须是变量，所以就 {{default:()=&gt;{}}}</span>        <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>          <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span>哈哈哈 ！！！<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>          <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span>当前计数：<span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>counter<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>          <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>increment<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>          <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>decrement<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>          <span class="token operator">&lt;</span>Home<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token function-variable function">default</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">&lt;</span>h3<span class="token operator">&gt;</span>哈哈。。。。<span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">&gt;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>Home<span class="token operator">&gt;</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>      <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Vue3-高级语法补充"><a href="#Vue3-高级语法补充" class="headerlink" title="Vue3 高级语法补充"></a>Vue3 高级语法补充</h1><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><h3 id="认识自定义指令"><a href="#认识自定义指令" class="headerlink" title="认识自定义指令"></a>认识自定义指令</h3><p>在 Vue 的模板语法中我们学习过各种各样的指令：v-show、v-for、v-model 等等，除了使用这些指令之外，<strong>Vue 也允许我们来自定义自己的指令。</strong></p><ul><li>注意：在 Vue 中，代码的复用和抽象主要还是通过组件；</li><li>通常在某些情况下，你需要对 DOM 元素进行底层操作，这个时候就会用到自定义指令；</li></ul><p><strong>自定义指令分为两种：</strong></p><ul><li>自定义局部指令：组件中通过 directives 选项，只能在当前组件中使用；</li><li>自定义全局指令：app 的 directive 方法，可以在任意组件中被使用；</li></ul><p><strong>比如我们来做一个非常简单的案例：当某个元素挂载完成后可以自定获取焦点</strong></p><ul><li>实现方式一：如果我们使用默认的实现方式；</li><li>实现方式二：自定义一个 v-focus 的局部指令；</li><li>实现方式三：自定义一个 v-focus 的全局指令；</li></ul><h4 id="实现方式一：默认实现"><a href="#实现方式一：默认实现" class="headerlink" title="实现方式一：默认实现"></a>实现方式一：默认实现</h4><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210822202810574.png" alt="image-20210822202810574"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210822202901896.png" alt="image-20210822202901896"></p><h4 id="实现方式二：局部自定义指令"><a href="#实现方式二：局部自定义指令" class="headerlink" title="实现方式二：局部自定义指令"></a>实现方式二：局部自定义指令</h4><p><strong>实现方式二：自定义一个 v-focus 的局部指令</strong></p><ul><li>这个<strong>自定义指令</strong>实现非常简单，我们只需要在组件选项中使用 <strong>directives</strong> 即可；</li><li>它是一个对象，在对象中编写我们自定义指令的名称（注意：这里不需要加 v-）；</li><li><strong>自定义指令有一个生命周期</strong>，是在组件挂载后调用的 <strong>mounted</strong>，我们可以在其中完成操作；</li></ul><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210822204614559.png" alt="image-20210822204614559"></p><p><strong>注意：参数 bindings 可以拿到使用该指令的组件或元素上指令的参数和修饰符等信息。后面会说。</strong></p><h4 id="方式三：自定义全局指令"><a href="#方式三：自定义全局指令" class="headerlink" title="方式三：自定义全局指令"></a>方式三：自定义全局指令</h4><p>自定义一个<strong>全局的 v-focus 指令</strong>可以让我们在任何地方直接使用</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210822204940163.png" alt="image-20210822204940163"></p><h3 id="指令的生命周期"><a href="#指令的生命周期" class="headerlink" title="指令的生命周期"></a>指令的生命周期</h3><p><strong>一个指令定义的对象，Vue 提供了如下的几个钩子函数：</strong></p><ul><li><strong>created：</strong>在绑定元素的 attribute 或事件监听器被应用之前调用；</li><li><strong>beforeMount：</strong>当指令第一次绑定到元素并且在挂载父组件之前调用；</li><li><strong>mounted：</strong>在绑定元素的父组件被挂载后调用； n</li><li><strong>beforeUpdate：</strong>在更新包含组件的 VNode 之前调用；</li><li><strong>updated：</strong>在包含组件的 VNode 及其子组件的 VNode 更新后调用；</li><li><strong>beforeUnmount：</strong>在卸载绑定元素的父组件之前调用；</li><li><strong>unmounted：</strong>当指令与元素解除绑定且父组件已卸载时，只调用一次；</li></ul><h3 id="指令的参数和修饰符"><a href="#指令的参数和修饰符" class="headerlink" title="指令的参数和修饰符"></a>指令的参数和修饰符</h3><p>如果我们指令需要<strong>接受一些参数或者修饰符</strong>应该如何操作呢？</p><ul><li>info 是参数的名称；</li><li>aaa-bbb 是修饰符的名称；</li><li>后面是传入的具体的值；</li></ul><p>在我们的生命周期中，我们可以<strong>通过 bindings 获取</strong>到对应的内容：</p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210822213505316.png" alt="image-20210822213505316"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210822213609137.png" alt="image-20210822213609137"></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>当前计数：{{ counter }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 事件修饰符和参数 aaa bbb 是修饰符 等于号右边参数 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">v-mao.aaa.bbb</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">'</span>字符串毛毛！<span class="token punctuation">'</span><span class="token punctuation">"</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>increment<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>+1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> watch<span class="token punctuation">,</span> onMounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span>  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token comment">// 局部组件在 directives属性里面定义</span>    directives<span class="token operator">:</span> <span class="token punctuation">{</span>      mao<span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token comment">// 指令的生命周期</span>        <span class="token function">created</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> bindings<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> preVnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"v-mao created ......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> bindings<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> preVnode<span class="token punctuation">)</span><span class="token punctuation">;</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"v-mao指令的参数："</span><span class="token punctuation">,</span> bindings<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 通过 bindings的 modifiers 属性获取修饰符， modifiers是一个对象，修饰符是该对象的属性</span>          <span class="token comment">// 只要用了这个修饰符，值就是 true</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"v-mao指令的修饰符："</span><span class="token punctuation">,</span> bindings<span class="token punctuation">.</span>modifiers<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">beforeMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"v-mao beforeMount ......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"v-mao mounted ......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment">// 只要指令所在的元素或组件发生了改变，包括属性等发生改变，都会调用这两个生命周期</span>        <span class="token function">beforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"v-mao beforeUpdate ......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">updated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"v-mao updated ......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">beforeUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"v-mao beforeUnmount ......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">unmounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"v-mao unmounted ......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> counter <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> <span class="token function-variable function">increment</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> counter<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token punctuation">{</span>        counter<span class="token punctuation">,</span>        increment<span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">&gt;</span></span><span class="token style"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自定义指令练习"><a href="#自定义指令练习" class="headerlink" title="自定义指令练习"></a>自定义指令练习</h3><p>自定义指令案例：时间戳的显示需求:</p><ul><li>在开发中，<strong>大多数情况</strong>下<strong>从服务器获取到的都是时间戳</strong>；</li><li>我们需要将时间戳转换成具体<strong>格式化的时间</strong>来展示；</li><li>在<strong>Vue2 中我们可以通过过滤器</strong>来完成；</li><li>在 Vue3 中我们可以通过 计算属性（computed） 或者 自定义一个方法（methods） 来完成；</li><li>其实我们还可以通过一个<strong>自定义的指令</strong>来完成；</li></ul><p>我们来实现一个可以<strong>自动对时间格式化的指令 v-format-time：</strong></p><p>这里我封装了一个函数，在首页中我们只需要<strong>调用这个函数并且传入 app 即可；</strong></p><h4 id="时间格式化指令"><a href="#时间格式化指令" class="headerlink" title="时间格式化指令"></a>时间格式化指令</h4><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210822220805982.png" alt="image-20210822220805982"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210822220945803.png" alt="image-20210822220945803"></p><h2 id="认识-Teleport-vue3"><a href="#认识-Teleport-vue3" class="headerlink" title="认识 Teleport(vue3)"></a>认识 Teleport(vue3)</h2><p>在组件化开发中，我们<strong>封装一个组件 A，在另外一个组件 B 中使用：</strong></p><ul><li>那么组件 A 中 template 的元素，会被挂载到组件 B 中 template 的某个位置；</li><li>最终我们的应用程序会形成一颗 DOM 树结构；</li></ul><p>但是某些情况下，我们<strong>希望组件不是挂载在这个组件树</strong>上的，可能是<strong>移动到 Vue app 之外的</strong>其他位置：</p><ul><li>比如移动到 body 元素上，或者我们有其他的 div#app 之外的元素上；</li><li>这个时候我们就可以通过 teleport 来完成；</li></ul><p><strong>Teleport 是什么呢？</strong></p><ul><li><p>它是一个 Vue 提供的内置组件，类似于 react 的 Portals；</p></li><li><p>teleport 翻译过来是心灵传输、远距离运输的意思；</p></li></ul><p><strong>它有两个属性：</strong></p><ul><li><strong>to：</strong>指定将其中的内容移动到的目标元素，可以使用选择器；</li><li><strong>disabled：</strong>是否禁用 teleport 的功能；</li></ul><h4 id="和组件结合使用"><a href="#和组件结合使用" class="headerlink" title="和组件结合使用"></a>和组件结合使用</h4><p>当然，teleport 也可以和组件结合一起来使用：</p><p>我们可以在 teleport 中使用组件，并且也可以给他传入一些数据；</p><h4 id="多个-teleport"><a href="#多个-teleport" class="headerlink" title="多个 teleport"></a>多个 teleport</h4><p><strong>如果我们将多个 teleport 应用到同一个目标上（to 的值相同），那么这些目标会进行合并：</strong></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210822230012209.png" alt="image-20210822230012209"></p><h2 id="认识-Vue-插件"><a href="#认识-Vue-插件" class="headerlink" title="认识 Vue 插件"></a>认识 Vue 插件</h2><p>通常我们向 Vue 全局添加一些功能时，会采用插件的模式，它有两种编写方式：</p><ul><li>对象类型：一个对象，但是必须包含一个 install 的函数，该函数会在安装插件时执行；</li><li>函数类型：一个 function，这个函数会在安装插件时自动执行；</li></ul><p>插件可以完成的<strong>功能没有限制</strong>，比如下面的几种都是可以的：</p><ul><li>添加全局方法或者 property，通过把它们添加到 config.globalProperties 上实现；</li><li>添加全局资源：指令/过滤器/过渡等；</li><li>通过全局 mixin 来添加一些组件选项；</li><li>一个库，提供自己的 API，同时提供上面提到的一个或多个功能；</li></ul><h3 id="插件的编写方式"><a href="#插件的编写方式" class="headerlink" title="插件的编写方式"></a>插件的编写方式</h3><h4 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h4><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210822232344537.png" alt="image-20210822232344537"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210822232433107.png" alt="image-20210822232433107"></p><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210822232508121.png" alt="image-20210822232508121"></p><h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p><img src="https://gitee.com/mao0826/picture/raw/master/images/web/vue/image-20210822232803913.png" alt="image-20210822232803913"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> ts </tag>
            
            <tag> webpack </tag>
            
            <tag> compositionAPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jpa的学习</title>
      <link href="/2021/10/31/src/java/jpa-de-xue-xi/"/>
      <url>/2021/10/31/src/java/jpa-de-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="JPA-框架"><a href="#JPA-框架" class="headerlink" title="JPA 框架"></a>JPA 框架</h1><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="实体类注解"><a href="#实体类注解" class="headerlink" title="实体类注解"></a>实体类注解</h3><h4 id="实体注解-Entity"><a href="#实体注解-Entity" class="headerlink" title="实体注解 @Entity"></a>实体注解 @Entity</h4><p>使用 <code>@Entity</code>注解标识在一个模型类（也可以说是实体类 bean）上，表明当前类是一个数据库模型类了。</p><h4 id="主键-Id"><a href="#主键-Id" class="headerlink" title="主键 @Id"></a>主键 @Id</h4><p>每个模型类都需要一个主键字段，使用<code>@Id</code>注解标识该注解字段。</p><h4 id="Column-限制长度"><a href="#Column-限制长度" class="headerlink" title="@Column 限制长度"></a>@Column 限制长度</h4><p>该注解标记的属性，可以限制在数据库中生成表字段的长度。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>length <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Table-标识表名"><a href="#Table-标识表名" class="headerlink" title="@Table 标识表名"></a>@Table 标识表名</h4><p>如果我们想要让生成的表的表名不是我们的类型，我们可以使用该注解进行指定表名。需要指定表中字段的名称我们也可以通过@Id，@Column 注解等的 name 属性进行指定。让我们模型类的属性名和生成的字段名不一致。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>mao<span class="token punctuation">.</span>sleeve<span class="token punctuation">.</span>model_bak</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span></span><span class="token class-name">Column</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span></span><span class="token class-name">Entity</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span></span><span class="token class-name">Id</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span></span><span class="token class-name">Table</span><span class="token punctuation">;</span><span class="token comment">/** * @ClassName: Banner * @Description: banner模型类 * @Author 毛毛 * @CreateDate 2021/10/29/周五 15:01 * @Version: v1.0 */</span><span class="token annotation punctuation">@Entity</span><span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"banner"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Banner</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * 主键     */</span>    <span class="token annotation punctuation">@Id</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token comment">/**     * @Column(length = 16) 限制长度不超过16     */</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>length <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">,</span> name <span class="token operator">=</span> <span class="token string">"name"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token comment">/**     * 描述     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> description<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> img<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> title<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Transient-忽略属性"><a href="#Transient-忽略属性" class="headerlink" title="@Transient 忽略属性"></a>@Transient 忽略属性</h4><p>使用该注解标记的属性，在创建表的时候，会忽略该属性，不和表的字段进行对应。也就是说模型类中有该属性，但是生成的表中不会有该字段。</p><h4 id="JSON-序列化-JsonIgnore-忽略该属性"><a href="#JSON-序列化-JsonIgnore-忽略该属性" class="headerlink" title="JSON 序列化 @JsonIgnore 忽略该属性"></a>JSON 序列化 @JsonIgnore 忽略该属性</h4><p>在进行 json 序列化返回给前端数据的时候，如果某些属性我们不想返回给前端，那么在序列化的时候，我们需要使用该注解@JsonIgnore 标记在不被序列化的属性上。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Getter</span><span class="token annotation punctuation">@Setter</span><span class="token annotation punctuation">@MappedSuperclass</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">BaseEntity</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * 三个基础字段 且这三个字段 不应该返回给前端 也就是不应该序列化     *     */</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">protected</span> <span class="token class-name">Date</span> createTime<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">protected</span> <span class="token class-name">Date</span> updateTime<span class="token punctuation">;</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">protected</span> <span class="token class-name">Date</span> deleteTime<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="OneToMany-一对多"><a href="#OneToMany-一对多" class="headerlink" title="@OneToMany 一对多"></a>@OneToMany 一对多</h4><p><strong>使用该注解标记的属性，也叫做导航属性。</strong>通过当前所在的模型类可以找到这个关联的多方的数据。</p><p>该注解用来生成一对多的关系。一个 banner 对应多个 bannerItem。表示两个表之间的关系是一对多。当前所在模型是一，标记的 BannerItem 类型是多方。</p><p><strong>默认情况下，使用了该注解以后，会生成三个表。其中的 banner 和 banner_item 表是模型类对应的表模型，还有一张表名称是当前所在模型类对应的名称加上我们的一对多的该属性的名称结合，生成的新表 banner_banner_items。默认情况下，这个表有两个属性，是其他两张表的主键构成的。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Entity</span><span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"banner_item"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BannerItem</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Id</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> img<span class="token punctuation">;</span>    <span class="token comment">/**     * 关键字 跳转到spu的时候，需要携带spu的id 跳转到专题的时候，需要携带的是专题的标识     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> keyword<span class="token punctuation">;</span>    <span class="token comment">/**     * TODO 点击这个广告，应该跳转到spu商品页面，还是专题页面，主题页面等     */</span>    <span class="token keyword">private</span> <span class="token class-name">Short</span> type<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> banner_id<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@OneToMany</span><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BannerItem</span><span class="token punctuation">&gt;</span></span> bannerItems<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果想要消除第三张表的产生：我们需要在 BannerItem 实体类中，建立和 banner 表的联系。</p><p>之所以生成第三张表，是因为我们 jpa 不知道 banner 和 BannerItem 之间的联系和关系。所以我们需要在 BannerItem 中添加一个外键属性，表明当前的 BannerItem 是属于那个 Banner 的。</p><p>这样就不会有第三张表的出现了。</p><h4 id="JoinColumn-指定关联的外键"><a href="#JoinColumn-指定关联的外键" class="headerlink" title="@JoinColumn 指定关联的外键"></a>@JoinColumn 指定关联的外键</h4><p>该注解指定当前一对多的关系中，当前表的主键去作为多方的表的外键。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@OneToMany</span><span class="token annotation punctuation">@JoinColumn</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"bannerId"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BannerItem</span><span class="token punctuation">&gt;</span></span> bannerItems<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Entity</span><span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"banner_item"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BannerItem</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Id</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> img<span class="token punctuation">;</span>    <span class="token comment">/**     * 关键字 跳转到spu的时候，需要携带spu的id 跳转到专题的时候，需要携带的是专题的标识     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> keyword<span class="token punctuation">;</span>    <span class="token comment">/**     * TODO 点击这个广告，应该跳转到spu商品页面，还是专题页面，主题页面等     */</span>    <span class="token keyword">private</span> <span class="token class-name">Short</span> type<span class="token punctuation">;</span>    <span class="token comment">/**     * 外键 属于那个banner     */</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> bannerId<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>当我们使用该注解以后，就会生成数据库中两张表之间的物理外键。这种情况下，我们应该当被关联表先创建出来。所以我们可以在模型类上加上注解@Proxy</strong></p><h4 id="Proxy"><a href="#Proxy" class="headerlink" title="@Proxy"></a>@Proxy</h4><p>实现模型类创建出表的时候，是懒创建还是直接创建。<strong>注意：这个注解是 hibernate 提供的。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Table</span><span class="token annotation punctuation">@Proxy</span><span class="token punctuation">(</span>lazy <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="GeneratedValue-生成策略"><a href="#GeneratedValue-生成策略" class="headerlink" title="@GeneratedValue 生成策略"></a>@GeneratedValue 生成策略</h4><p>如果我们想要让主键自增，主键唯一等，可以使用该注解标注在主键上。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Id</span><span class="token comment">// strategy 策略</span><span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> <span class="token class-name">GenerationType</span><span class="token punctuation">.</span>IDENTITY<span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>strategy = GenerationType.AUTO</code>这个不是主键自增，而是将表交给 JPA 管理，会生成新的表来管理数据。</p><p><code>strategy = GenerationType.IDENTITY</code>表示主键自增。</p><h4 id="MappedSuperclass-映射的基类"><a href="#MappedSuperclass-映射的基类" class="headerlink" title="@MappedSuperclass 映射的基类"></a>@MappedSuperclass 映射的基类</h4><p>当我们在一个类上标注了该注解以后，表明当前类是一个可以被模型类继承的基类。会拥有当前类的属性，且可以映射到数据库表中。</p><p>使用该注解标记一个基类，是为了把某些公共的属性抽取出来，但不想让当前类成为一个模型类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Getter</span><span class="token annotation punctuation">@Setter</span><span class="token annotation punctuation">@MappedSuperclass</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">BaseEntity</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * 三个基础字段 且这三个字段 不应该返回给前端 也就是不应该序列化     */</span>    <span class="token keyword">protected</span> <span class="token class-name">Date</span> createTime<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token class-name">Date</span> updateTime<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token class-name">Date</span> deleteTime<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JPA-操作读写数据"><a href="#JPA-操作读写数据" class="headerlink" title="JPA 操作读写数据"></a>JPA 操作读写数据</h3><p>定义接口（仓储模式）继承 JpaRepository 接口，实现数据库的读写操作</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>mao<span class="token punctuation">.</span>sleeve<span class="token punctuation">.</span>repository<span class="token punctuation">.</span>banner</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>mao<span class="token punctuation">.</span>sleeve<span class="token punctuation">.</span>model_bak<span class="token punctuation">.</span></span><span class="token class-name">Banner</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>jpa<span class="token punctuation">.</span>repository<span class="token punctuation">.</span></span><span class="token class-name">JpaRepository</span><span class="token punctuation">;</span><span class="token comment">/** * @ClassName: BannerRepository * @Description: Repository 仓储模式 使用jpa操作数据库，读写 * JpaRepository&lt;Banner,Long&gt; * 泛型一： 是我们操作的表对应的模型的类型 * 泛型二： 是操作表的主键的类型 * @Author 毛毛 * @CreateDate 2021/10/29/周五 23:54 * @Version: v1.0 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BannerRepository</span> <span class="token keyword">extends</span> <span class="token class-name">JpaRepository</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Banner</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">/**     * 根据id查询相应的banner     *     * @param id     * @return     */</span>    <span class="token class-name">Banner</span> <span class="token function">findOneById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 根据name查询相应的banner     *     * @param name     * @return     */</span>    <span class="token class-name">Banner</span> <span class="token function">findOneByName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><p>默认情况下，JPA 查询某张表中的数据的时候，如果有某个属性是关联其他表的字段，JPA 并不会直接把关联的数据一起查询出，只有在我们用到了关联数据的时候才会进行查询，这就是 JPA 的懒加载。</p><p>如果我们想实现一次性加载完所有数据，其实也很简单。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@OneToMany</span><span class="token punctuation">(</span>fetch <span class="token operator">=</span> <span class="token class-name">FetchType</span><span class="token punctuation">.</span>EAGER<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="双向一对多配置"><a href="#双向一对多配置" class="headerlink" title="双向一对多配置"></a>双向一对多配置</h4><p><strong>双向一对一（@OneToOne），类似双向一对多，mappedBy 设置在关系被维护端，外键由关系维护端维护；</strong></p><p>我们可以在模型类 banner 中配置当前 banner 所存在的所有子项 bannerItems，那么肯定也可以在 bannerItem 模型类中配置当前子项所属的 banner。在 banner 中是一对多个 item，那么在 item 中就是多个 item 对应一个 banner。</p><p><strong>维护双向一对多的关系中，</strong>我们也叫做关系维护端和关系被维护端。</p><p>关系维护端：我们把多方的那一端叫做维护端。</p><p>关系被维护端：一方</p><p><strong>在双向一对多的模型中，我们使用的@JoinColumn 注解是打在多端维护关系的属性上面的。</strong></p><p>在一方的那个维护的属性上，是不需要使用该属性了。</p><p>然后还需要在一方（这里的 banner）模型类中的维护多方关系的导航属性上使用的注解**<code>@OneToMany</code>**里面设置一个属性 mappedBy 的属性值为多方模型中维护关系的导航属性的属性名。</p><p><strong>Many 端，为关系维护端，负责外键的更新（删除时候注意先删除 Many 端再删除 One 端）；</strong><br><strong>One 端，为关系被维护端，不能更新外键；</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Entity</span><span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"banner"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Proxy</span><span class="token punctuation">(</span>lazy <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Getter</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Banner</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * 主键     */</span>    <span class="token annotation punctuation">@Id</span>    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> <span class="token class-name">GenerationType</span><span class="token punctuation">.</span>IDENTITY<span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token comment">/**     * @Column(length = 16) 限制长度不超过16     */</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>length <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">,</span> name <span class="token operator">=</span> <span class="token string">"name"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token comment">/**     * 描述     *     * @Transient: 该注解实现 标注的属性不在表中体现     */</span>    <span class="token annotation punctuation">@Transient</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> description<span class="token punctuation">;</span>    <span class="token comment">/**     * 广告板块首图     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> img<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> title<span class="token punctuation">;</span>    <span class="token comment">/**     * 一个banner拥有多个item，一对多     * mappedBy = "banner" 该属性的值就是多端维护关系的属性的属性名，也就是导航属性名     */</span>    <span class="token annotation punctuation">@OneToMany</span><span class="token punctuation">(</span>mappedBy <span class="token operator">=</span> <span class="token string">"banner"</span><span class="token punctuation">)</span>    <span class="token comment">//@JoinColumn(name = "banner_id")</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BannerItem</span><span class="token punctuation">&gt;</span></span> bannerItems<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Entity</span><span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"banner_item"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BannerItem</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Id</span>    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> <span class="token class-name">GenerationType</span><span class="token punctuation">.</span>IDENTITY<span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> img<span class="token punctuation">;</span>    <span class="token comment">/**     * 关键字 跳转到spu的时候，需要携带spu的id 跳转到专题的时候，需要携带的是专题的标识     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> keyword<span class="token punctuation">;</span>    <span class="token comment">/**     * TODO 点击这个广告，应该跳转到spu商品页面，还是专题页面，主题页面等     */</span>    <span class="token keyword">private</span> <span class="token class-name">Short</span> type<span class="token punctuation">;</span>    <span class="token comment">/**     * 外键 属于那个banner jpa自动生成，不能显示的写出来了     */</span>    <span class="token comment">// private Long bannerId;</span>    <span class="token comment">/**     * 当前banner子项属于的banner     */</span>    <span class="token annotation punctuation">@ManyToOne</span>    <span class="token comment">// @JoinColumn(name = "banner_id") jpa会维护该外键字段</span>    <span class="token keyword">private</span> <span class="token class-name">Banner</span> banner<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>或者：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Entity</span><span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"banner_item"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BannerItem</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Id</span>    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> <span class="token class-name">GenerationType</span><span class="token punctuation">.</span>IDENTITY<span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> img<span class="token punctuation">;</span>    <span class="token comment">/**     * 关键字 跳转到spu的时候，需要携带spu的id 跳转到专题的时候，需要携带的是专题的标识     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> keyword<span class="token punctuation">;</span>    <span class="token comment">/**     * TODO 点击这个广告，应该跳转到spu商品页面，还是专题页面，主题页面等     */</span>    <span class="token keyword">private</span> <span class="token class-name">Short</span> type<span class="token punctuation">;</span>    <span class="token comment">/**     * 外键 属于那个banner     * TODO JPA会自动帮我们创建，不需要显示手写，也不能定义     * 如果想要显示的定义该属性，需要在下面的导航属性上的@joinColumn注解上配置一些属性     */</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> bannerId<span class="token punctuation">;</span>    <span class="token comment">/**     * 当前banner子项属于的banner     */</span>    <span class="token annotation punctuation">@ManyToOne</span>    <span class="token annotation punctuation">@JoinColumn</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"banner_id"</span><span class="token punctuation">,</span> insertable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Banner</span> banner<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多对多-ManyToMany"><a href="#多对多-ManyToMany" class="headerlink" title="多对多@ManyToMany"></a>多对多@ManyToMany</h3><h4 id="单向多对多"><a href="#单向多对多" class="headerlink" title="单向多对多"></a>单向多对多</h4><p>表之间多对多的关系，其实是双向的。一般都需要三种表，需要中间表来维护两张表之间的关系的。</p><p>但是很多时候，我们在模型类中只需要体现出单向的多对多即可，有时候不需要另一方也使用导航属性来关联。</p><h4 id="多对多生成第三张表的表名"><a href="#多对多生成第三张表的表名" class="headerlink" title="多对多生成第三张表的表名"></a>多对多生成第三张表的表名</h4><p>默认情况下，我们生成的一对多或者是多对多的第三张中间表的名称是当前模型类对应的表名和关联的导航属性的名称的结合。如果我们想指定生成的中间表的表名，可以使用 **@JoinTable ** 注解来显示的指定。还可以通过该注解的<code>joinColumns</code>属性来指定中间表中关联的两个外键的名称</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Entity</span><span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"theme"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Theme</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Id</span>    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> <span class="token class-name">GenerationType</span><span class="token punctuation">.</span>IDENTITY<span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> title<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@ManyToMany</span>    <span class="token annotation punctuation">@JoinTable</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"theme_spu"</span><span class="token punctuation">,</span>            joinColumns <span class="token operator">=</span> <span class="token annotation punctuation">@JoinColumn</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"theme_id"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            inverseJoinColumns <span class="token operator">=</span> <span class="token annotation punctuation">@JoinColumn</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"spu_id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Spu</span><span class="token punctuation">&gt;</span></span> spuList<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>双向多对多（@ManyToMany），注意关系维护端的定义；所有关系定义都是在关系维护端来定义的；<br><strong>@JoinTable(name=”关联表名称”, inverseJoinColumns=@JoinColumn(name=”被维护端外键”),</strong></p><p><strong>joinColumns=@JoinColumn(name=”维护端外键”))</strong></p><p>注意，在关系维护端对被维护端的集合进行增加、删除操作时候，需要重载 hashCode 与 equals 方法，通过 ID 来判</p><p>断是否相同，而不是内存引用地址；<br>对关系被维护端进行级联删除时候，需要先解除关系，然后删除；</p><h4 id="JPA-级联更新去孤子-了解"><a href="#JPA-级联更新去孤子-了解" class="headerlink" title="JPA 级联更新去孤子(了解)"></a>JPA 级联更新去孤子(了解)</h4><blockquote><p>在是使用 JPA(hibernate)配置实体关系中，经常会遇到通过父实体对象级联批量更新子对象的需求，而且每次更新必须采用合并方式，即原来的所有子删除，只保留本次保存的所有子实体对象。</p><p>例子：</p><p>A 为父对象，持有一个 B 的集合，A 与 B 的关系为 oneToMany.</p><p>第一次保存：设置 A 下的 B 集合成员为：1,2,3, 保存 A 后，B 对象对应的数据表为:1,2,3</p><p>第二次保存：设置 A 下的 B 集合成员为：2,3,4, 保存 A 后，B 对象对应的数据表为:2,3,4 (自动删除无效数据 1)</p><p>这个就是自动去孤子功能。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>       <span class="token keyword">private</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">B</span><span class="token punctuation">&gt;</span></span> bs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">B</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@OneToMany</span><span class="token punctuation">(</span>cascade <span class="token operator">=</span> <span class="token class-name">CascadeType</span><span class="token punctuation">.</span>ALL<span class="token punctuation">,</span> fetch <span class="token operator">=</span> <span class="token class-name">FetchType</span><span class="token punctuation">.</span>LAZY<span class="token punctuation">,</span> mappedBy <span class="token operator">=</span> <span class="token string">"flowNode"</span><span class="token punctuation">,</span> orphanRemoval <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@OrderBy</span><span class="token punctuation">(</span>clause <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">B</span><span class="token punctuation">&gt;</span></span> <span class="token function">getBs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> bs<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><h3 id="物理外键和逻辑外键"><a href="#物理外键和逻辑外键" class="headerlink" title="物理外键和逻辑外键"></a>物理外键和逻辑外键</h3><p>我们使用 JPA 框架的时候，通过模型类创建数据库表，相关联的字段都会生成物理外键。实际上我们应该不使用或者少使用物理外键在数据库表中。应该是在模型类中体现这些逻辑外键，在数据库中不建立物理外键。</p><p>使用 hibernate 的一个被废弃的注解可以实现不生成物理外键</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*** 关系被维护端* 忽略物理外键*/</span><span class="token annotation punctuation">@ManyToMany</span><span class="token punctuation">(</span>mappedBy <span class="token operator">=</span> <span class="token string">"spuList"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@org.hibernate.annotations.ForeignKey</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"null"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Theme</span><span class="token punctuation">&gt;</span></span> themeList<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以使用@JoinColumn 注解中新增的属性 foreign 属性来禁止生成物理外键</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Entity</span><span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"spu"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Spu</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Id</span>    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> <span class="token class-name">GenerationType</span><span class="token punctuation">.</span>IDENTITY<span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token comment">/**     * 主标题     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> title<span class="token punctuation">;</span>    <span class="token comment">/**     * 副标题     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> subTitle<span class="token punctuation">;</span>    <span class="token comment">/**     * 关系被维护端     * 忽略物理外键     */</span>    <span class="token annotation punctuation">@ManyToMany</span><span class="token punctuation">(</span>mappedBy <span class="token operator">=</span> <span class="token string">"spuList"</span><span class="token punctuation">)</span>    <span class="token comment">//@org.hibernate.annotations.ForeignKey(name = "null")</span>    <span class="token comment">// 上面是被废弃的方式，下面的方式是新增的，也是用来禁止生成物理外键的，设置模式是无限制</span>    <span class="token annotation punctuation">@JoinColumn</span><span class="token punctuation">(</span>foreignKey <span class="token operator">=</span> <span class="token annotation punctuation">@ForeignKey</span><span class="token punctuation">(</span><span class="token class-name">ConstraintMode</span><span class="token punctuation">.</span>NO_CONSTRAINT<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Theme</span><span class="token punctuation">&gt;</span></span> themeList<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring Data </category>
          
          <category> JPA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Data </tag>
            
            <tag> JPA </tag>
            
            <tag> java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
